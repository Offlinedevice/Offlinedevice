#!/usr/bin/myenv python3
#
#  GUIApp.py
#  Version:0.5.0 for Raspberry Pi 5
#  Git repo: https://github.com/Offlinedevice
#  Offline Device for:
#     Managing GPG keys on local keychain.
#     Storing passwords, digital wallets and files.
#     Managing Yubikey 5 NFC. OpenPGP and FIDO2.
#     Encrypting and/or signing files. 
#     Decrypting and/or verifying messages and files.
#     Generating, importing and storing Bitcoin wallets.
#     Signing Bitcoin messages (to prove wallet ownership).
#     Generating and managing private Digital ID's.
#     Generating and managing private Nostr ID's (Npub and Nsec).
#     Transferring Nostr keys to Nostr Signing Devices (NSD).
#     Managing Bolt Cards for BTC payments.
#     Managing Passkeys (FIDO) for passwordless login.
#     Adding and creating Bitcoi wallets (with air-gapped functionality).
#     Signing Partially signed bitcoin transactions (PSBTs) using built-in camera.
#     Signing Bitcoin messages (proof of wallet ownership).
#     Generating and managing Bitcoin wallet statements.
#     Generate strong passwords by throughing dices.
#     Timestamp signaure and associated document on Bitcoin main chain (hashed transaction as proof).
#     Calculate verification timestamp transaction for document hash (sha256) or for combined signature and document (or only document). 
#     Generating a inheritance package with encrypted and signed data that can together with trusted third parties secure your data for the future.
#  
#  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, 
#  version 2 of the License. 

#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
#  See the GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

#  SPDX-License-Identifier: GPL-2.0-only
#  GUIApp.py - Offline device.
#  Copyright (c) 2024 

import sys
import gc
import tkinter as tk
from tkinter import *
from tkinter import messagebox, ttk
from tkinter import filedialog
from tkinter import simpledialog
from pathlib import Path
import pathlib
import customtkinter as ctk
from PIL import Image, ImageTk
import gnupg
import shutil
import gzip
import webbrowser
import os
import os.path
import glob
import tarfile
import yubico
import usb.core
import usb.backend.libusb1
import subprocess
from subprocess import check_output
import time
import math
import nostr
from seedsigner.models.psbt_parser import PSBTParser
from seedsigner.models.decode_qr import DecodeQR
from seedsigner.models.seed import Seed
from seedsigner.helpers.embit_utils import sign_message, parse_derivation_path
from seedsigner.helpers.ur2.ur import UR
from seedsigner.helpers.ur2.ur_encoder import UREncoder
from seedsigner.models.encode_qr import UrPsbtQrEncoder
from seedsigner.models.encode_qr import BaseStaticQrEncoder
from seedsigner.models.settings import SettingsConstants
from seedsigner.helpers.cbor_helper import make_message_ur
from embit import psbt
from embit import bip32
from embit import bip39
from embit.networks import NETWORKS
from seedsigner.urtypes.crypto.psbt import PSBT as UR_PSBT
from seedsigner.urtypes.cbor.encoder import Encoder
from binascii import a2b_base64, b2a_base64
import threading
from datetime import date
from tkcalendar import Calendar,DateEntry 
from tktimepicker import AnalogPicker, AnalogThemes,constants
import csv, operator, ast
import binascii
from bip32utils import BIP32Key
from mnemonic import Mnemonic
import bech32
import base58
from datetime import datetime
from typing import Optional
import hashlib
import hashlib
from functools import partial
import qrcode
from random import SystemRandom, randrange
from pywallet import wallet
from bitcoinlib.wallets import Wallet
from bitcoinlib.keys import Address, HDKey
from bitcoinlib.mnemonic import Mnemonic as bitcoinlibMnemonic
from bitcoinlib.bitcoin.wallet import CBitcoinSecret, P2PKHBitcoinAddress
from bitcoinlib.bitcoin.signmessage import BitcoinMessage, VerifyMessage, SignMessage
import pyscreenshot as ImageGrab
from pyzbar.pyzbar import decode
from nostr.key import PrivateKey
from bip32 import BIP32, HARDENED_INDEX
from bip39 import (
    encode_bytes,
    decode_phrase,
    phrase_to_seed,
    EncodingError,
    DecodingError,
)

check_var = ' '
my_text_buffer = ' '
path_to_USB_secure = 'Secure USB folder is not available'
PersonalGPGKey = ''
clicked_privateKey = ' '
clicked_privateSubKey = ' '
stored_name = ''
stored_email = ''
filepathdestinationfolder = '/home/user1'
view_btcAddr = 'none'
ext_flag = 'none'
use_filter = 'all'
use_status = 'all'
do_sort = 'none'
commkey = ' '
timeSecUSBLastModified = '<Unknown>'
softwareVersion = '0.5.0'
softwareStatus = 'Beta'
newIDflag = False
statt = True
layout = 'normal' 
n_Alias = 1
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("dark-blue")

path_to_data_file = ' '
path_to_sig = ' '
		
captured_QR = False
text_file_data = ' '
s_width = 0
s_height = 0
U2F_VENDOR_FIRST = 0x40
cnt = 0
combinedValueStr = ''
combinedValueBase58 = ''
g_Updated_name = ''
g_Updated_description = ''
g_cardidentification = ''
g_LNURL = ''
g_program_keys = ''
g_program_link = ''
g_maxLimit = ''
g_maxDailyLimit = ''
g_url_link = ''
g_account_name = ''
diceFunction = ''
key_record = ''
key_record2 = ''
System_button_color = 'DarkBlue'
GPG_button_color = 'green'
SecUSB_button_color = 'purple'
Yubikey_button_color = 'red'
DigitalID_button_color = 'brown'
Boltcard_button_color = 'orange'
Help_button_color = 'orange'

diceWordsList = []
		
# FIPS specific INS values
INS_FIPS_VERIFY_PIN = U2F_VENDOR_FIRST + 3
INS_FIPS_SET_PIN = U2F_VENDOR_FIRST + 4
INS_FIPS_RESET = U2F_VENDOR_FIRST + 5
INS_FIPS_VERIFY_FIPS_MODE = U2F_VENDOR_FIRST + 6
  
class App(ctk.CTk):
	def __init__(self):
		global s_width, s_height
		#main setup
		super().__init__()
		self.title("Offline Device GUI")
		s_width = self.winfo_screenwidth()
		s_height = self.winfo_screenheight()
		geom = str(s_width) + 'x' + str(s_height)
		self.geometry(geom)
		self.wm_attributes('-fullscreen', True)
		
		self.state('normal')
		self.option_add('*Dialog.msg.font', 'Helvetica 14')
		# widget
		self.menu = Menu(self)
		
		self.mainloop()
		
class Menu(ctk.CTkFrame):	
	def msg_box_textbox(self, msg_text, size_width, size_height):
		global meny
		pop = Toplevel()
		pop.title("Information")
		box_size = size_width + 'x' + size_height
		pop.geometry(box_size)
		pop.focus()
		pop.grab_set()
		
		pop.config(bg="grey")
		
		my_text = ctk.CTkTextbox(pop, width=int(size_width), height=int(size_height), corner_radius=1, border_width=2, border_color="black", border_spacing=10, fg_color="light grey", text_color="black", font=("Arial", 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="blue", scrollbar_button_hover_color="red")
		my_text.insert('end', msg_text)
	
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")		
			
		def exit_msg():
			pop.destroy()
			
		def stay_on_top():
			pop.lift()
			pop.after(1000, stay_on_top)	
		ok_button = ctk.CTkButton(pop, text="OK", text_color="black", fg_color="light grey", border_width=2, border_color="black", command=exit_msg)
		ok_button.place(relx=0.5, rely=0.9, anchor="center")
		stay_on_top()
		
	def __init__(self, parent):
		super().__init__(parent)
		global s_width,s_height
		global filepathdestinationfolder
		self.place(x=0, y=0, relwidth = 1, relheight = 1)
		
		my_image = ctk.CTkImage(light_image=Image.open('/home/user1/images/blue.jpg'), dark_image=Image.open('/home/user1/images/blue.jpg'), size=(s_width,s_height))
		
		my_label = ctk.CTkLabel(self, text="", image=my_image)
		my_label.pack()
		
		full_path = filepathdestinationfolder + "/secure"
		if os.path.isdir(full_path):
			cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
			os.system(cmd)
			cmd = 'rm -r ' +  full_path
			os.system(cmd)
			
		self.create_meny()
	
	def pre_encryptanddestroy(self):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Shutting down! Please wait......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		time.sleep(1)
		time.sleep(.2)
		self.encryptanddestroy()
					
	def encryptanddestroy(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global s_width,s_height
		
		my_big_Frame = ctk.CTkFrame(self, 
		width=s_width, 
		height=s_height,
		border_width=0,
		border_color="black"
		)
		my_big_Frame.place(relx=0.5, rely=0.5, anchor="center")
		
		pathtobackg = "/home/user1/images/black.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(s_width, s_height))
		Label_backg = ctk.CTkLabel(my_big_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		Label_backg.focus_set()
		Label_backg.focus_force()
		
		my_big_Frame.focus_set()
		my_big_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
		
		infoLabel = ctk.CTkLabel(my_big_Frame, text="Encrypting the device and shutting down...", text_color="white", font=my_font, fg_color="navy blue")
		infoLabel.place(relx=0.5, rely=0.42, anchor="center")
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if path_to_USB_secure == 'Secure USB folder is available':
			# Try to copy over a copy of any external aliases (in case a recovery is needed in the future)
			path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
			path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
			if os.path.isfile(path_to_externalAliases):
				shutil.copy(path_to_externalAliases, path_to_externalAliases_localcopy)
			full_path = str(filepathdestinationfolder) + "/secure/"
			compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
			# Encrypt the tarfile and remove the unencrypted tarfile
			encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
			
			cmd = 'shred -zu -n7 ' + filepathdestinationfolder + "/" + "secure.tar.gz"
			os.system(cmd)

			# Write the encrypted file to disk and also make a recovery if not zero
			compressedoutfile = open(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', 'w')
			compressedoutfile.write(str(encrypted_data))
			compressedoutfile.close()
			if os.stat(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg').st_size > 1000:
				shutil.copy(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', filepathdestinationfolder + '/Documents/RecoveryFor' + PersonalGPGKey + 'securefolder.tar.gz.gpg')
			full_path = str(filepathdestinationfolder) + "/secure"
			cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
			os.system(cmd)
			cmd = 'rm -r ' +  full_path
			os.system(cmd)
			os.system('sudo shutdown -h now')
		else:
			os.system('sudo shutdown -h now')
			
	def set_colors(self, color):
		global System_button_color
		global GPG_button_color
		global SecUSB_button_color
		global Yubikey_button_color
		global DigitalID_button_color
		global Boltcard_button_color
		global Help_button_color
		
		if color != 'Varied':
			if color == 'Navy blue':
				color = 'navy'
			if color == 'Gray':
				color = 'gray13'
			if color == 'Pink':
				color = 'deep pink'
			if color == 'Red':
				color = 'brown'
			System_button_color = color
			GPG_button_color = color
			SecUSB_button_color  = color
			Yubikey_button_color  = color
			DigitalID_button_color = color
			Boltcard_button_color = color
			Help_button_color = 'dark orange'
		else:
			System_button_color = 'Navy blue'
			GPG_button_color = 'green'
			SecUSB_button_color = 'purple'
			Yubikey_button_color = 'brown'
			DigitalID_button_color = 'brown'
			Boltcard_button_color = 'dark orange'
			Help_button_color = 'dark orange'
				
	def create_meny(self):
		global System_button_color
		global GPG_button_color
		global SecUSB_button_color
		global Yubikey_button_color
		global DigitalID_button_color
		global Boltcard_button_color
		global Help_button_color
		global s_width,s_height
		global use_filter
		
		layout = "Standard"
		my_big_Frame = ctk.CTkFrame(self, 
		width=s_width, 
		height=s_height,
		border_width=0,
		border_color="black"
		)
		my_big_Frame.place(relx=0.5, rely=0.5, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		if path_to_USB_secure == 'Secure USB folder is available':			
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							users_theme = lines[1]
							users_colors = lines[2]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No settings file found.")
			if users_theme == 'Winter':
				pathtobackg = "/home/user1/images/winterbackground.jpg"
			if users_theme == 'Summer':
				pathtobackg = "/home/user1/images/summerbackground.jpg"	
			if users_theme == 'Light':
				pathtobackg = "/home/user1/images/lightbackground.jpg"
			if users_theme == 'Dark':
				pathtobackg = "/home/user1/images/black.png"
			self.set_colors(users_colors)
						
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(s_width, s_height))
		Label_backg = ctk.CTkLabel(my_big_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		Label_backg.focus_set()
		my_big_Frame.focus_set()
		my_big_Frame.focus_force()
		
		use_filter = ' '
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = filepathdestinationfolder + "/secure/layout.csv"
			if not os.path.isfile(completeName):
				layout = ['Standard']
				
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(layout)
			else:
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:
								layout = lines[0]
				except FileNotFoundError:
					messagebox.showinfo("Information", "No layout file found.")
									
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
			if layout == 'Easy':
				self.option_add('*font', 'Helvetica 18')
				my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
				HomeButton = ctk.CTkButton(my_big_Frame, text="Home", text_color="white", border_width=3, border_color="white", fg_color=System_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.create_meny)
				HomeButton.place(relx=0.15, rely=0.1, anchor="center")
				
				GPGButton = ctk.CTkButton(my_big_Frame, text="GPG", text_color="white", border_width=3, border_color="white", fg_color=GPG_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.easy_show_private_keys)
				GPGButton.place(relx=0.3, rely=0.1, anchor="center")
				
				pwdButton = ctk.CTkButton(my_big_Frame, text="Passwords", text_color="white", border_width=3, border_color="white", fg_color=SecUSB_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.easy_create_secusbtextbox)
				pwdButton.place(relx=0.45, rely=0.1, anchor="center")
				
				idButton = ctk.CTkButton(my_big_Frame, text="ID", text_color="white", border_width=3, border_color="white", fg_color=DigitalID_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.easy_show_ID_keys)
				idButton.place(relx=0.6, rely=0.1, anchor="center")
				
				boltcardButton = ctk.CTkButton(my_big_Frame, text="Bitcoin", text_color="white", border_width=3, border_color="white", fg_color=Boltcard_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.easy_show_Bitcoin_wallets)
				boltcardButton.place(relx=0.75, rely=0.1, anchor="center")
				
				settimeButton = ctk.CTkButton(my_big_Frame, text="Settings", text_color="white", border_width=3, border_color="white", fg_color=System_button_color, width=220, height=55, corner_radius=8, font=my_font, command=self.create_getSettimetextbox)
				settimeButton.place(relx=0.92, rely=0.1, anchor="center")

				ExitButton = ctk.CTkButton(my_big_Frame, text="Close and exit", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=240, height=55, corner_radius=8, font=my_font, command=self.pre_encryptanddestroy)
				ExitButton.place(relx=0.5, rely=0.94, anchor="center")
			else:
				self.option_clear()
				HomeButton = ctk.CTkButton(my_big_Frame, text="Home", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.create_meny)
				HomeButton.place(relx=0.1, rely=0.1, anchor="center")
				
				GPGButton = ctk.CTkButton(my_big_Frame, text="GPG", text_color="white", border_width=2, border_color="white", fg_color=GPG_button_color, width=120, height=32, font=my_font, command=self.create_GPGmeny)
				GPGButton.place(relx=0.2, rely=0.1, anchor="center")
				
				YubikeyButton = ctk.CTkButton(my_big_Frame, text="Yubikey", text_color="white", border_width=2, border_color="white", fg_color=Yubikey_button_color, width=120, height=32, font=my_font, command=self.create_Yubikeymeny)
				YubikeyButton.place(relx=0.3, rely=0.1, anchor="center")
				
				secusbButton = ctk.CTkButton(my_big_Frame, text="Secure archive", text_color="white", border_width=2, border_color="white", fg_color=SecUSB_button_color, width=120, height=32, font=my_font, command=self.create_SecUSBmeny)
				secusbButton.place(relx=0.4, rely=0.1, anchor="center")
				
				idButton = ctk.CTkButton(my_big_Frame, text="Digital ID", text_color="white", border_width=2, border_color="white", fg_color=DigitalID_button_color, width=120, height=32, font=my_font, command=self.create_DigitalIDmeny)
				idButton.place(relx=0.5, rely=0.1, anchor="center")
				
				boltcardButton = ctk.CTkButton(my_big_Frame, text="Bitcoin", text_color="white", border_width=2, border_color="white", fg_color=Boltcard_button_color, width=120, height=32, font=my_font, command=self.create_Bitcoinmeny)
				boltcardButton.place(relx=0.6, rely=0.1, anchor="center")
				
				HelpButton = ctk.CTkButton(my_big_Frame, text="Help", text_color="white", border_width=2, border_color="white", fg_color=Help_button_color, width=120, height=32, font=my_font, command=self.create_helpmeny)
				HelpButton.place(relx=0.93, rely=0.05, anchor="center")
				
				settimeButton = ctk.CTkButton(my_big_Frame, text="Settings", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.create_getSettimetextbox)
				settimeButton.place(relx=0.93, rely=0.1, anchor="center")

				ExitButton = ctk.CTkButton(my_big_Frame, text="Close and exit", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.pre_encryptanddestroy)
				ExitButton.place(relx=0.5, rely=0.95, anchor="center")
			
		self.create_Hometextbox()
		 
	def create_helpmeny(self):
		global Help_button_color
		self.create_abouthelptextbox()
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		mainHelpButton = ctk.CTkButton(self, text="Help", text_color="white", border_width=2, border_color="white", fg_color="dark orange",  width=120, height=32, font=my_font, command=self.create_helpmeny)
		mainHelpButton.place(relx=0.93, rely=0.05, anchor="center")
		
		Button1 = ctk.CTkButton(self, text="Getting started", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_abouthelptextbox)
		Button1.place(relx=0.1, rely=0.2, anchor="center")
		
		Button2 = ctk.CTkButton(self, text="GPG", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_gpghelptextbox)
		Button2.place(relx=0.25, rely=0.2, anchor="center")
		
		Button3 = ctk.CTkButton(self, text="Yubikey", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_yubikeyhelptextbox)
		Button3.place(relx=0.4, rely=0.2, anchor="center")
		
		Button4 = ctk.CTkButton(self, text="Secure archive", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_secusbhelptextbox)
		Button4.place(relx=0.55, rely=0.2, anchor="center")
		
		Button5 = ctk.CTkButton(self, text="Digital ID\'s", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_digitalIDhelptextbox)
		Button5.place(relx=0.7, rely=0.2, anchor="center")
		
		Button6 = ctk.CTkButton(self, text="Bitcoin", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_boltcardhelptextbox)
		Button6.place(relx=0.85, rely=0.2, anchor="center")
	
	def create_GPGmeny(self):
		global GPG_button_color
		self.get_GnuPGKeys_compact(['_none__'])
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		CheckGPGButton = ctk.CTkButton(self, text="Check local keys", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.get_GnuPGKeys_compact, ['_none__']))
		CheckGPGButton.place(relx=0.1, rely=0.2, anchor="center")
		
		AddkeyButton = ctk.CTkButton(self, text="Add/remove key", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.newGPGFull_Key, "none"))
		AddkeyButton.place(relx=0.25, rely=0.2, anchor="center")
		
		AddsubkeyButton = ctk.CTkButton(self, text="Add subkeys", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.newGPG_Subkey)
		AddsubkeyButton.place(relx=0.4, rely=0.2, anchor="center")
		
		BackupkeysButton = ctk.CTkButton(self, text="Backup keys", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.backupGPG_Keys)
		BackupkeysButton.place(relx=0.55, rely=0.2, anchor="center")
		
		ImportkeyButton = ctk.CTkButton(self, text="Import/export", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.import_or_export)
		ImportkeyButton.place(relx=0.7, rely=0.2, anchor="center")
		
		SignkeyButton = ctk.CTkButton(self, text="Encrypt/Sign/check", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.select_what_to_sign)
		SignkeyButton.place(relx=0.85, rely=0.2, anchor="center")
	
	def create_SecUSBmeny(self):
		global SecUSB_button_color
		global path_to_USB_secure, use_filter
		
		def go_check_SecUSB():
			global use_filter
			use_filter = ' '
			self.check_SecUSB("none")
			return
			
		use_filter = ' '
		self.create_secusbtextbox()
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Button1 = ctk.CTkButton(self, text="Secure archive", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=go_check_SecUSB)
		Button1.place(relx=0.1, rely=0.2, anchor="center")
		
		Button2 = ctk.CTkButton(self, text="Encrypt/view a text", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.encrypt_message, ['none', 'none', '_none_']))
		Button2.place(relx=0.25, rely=0.2, anchor="center")
		
		Button3 = ctk.CTkButton(self, text="Decrypt a textfile", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_from_SecUSB)
		Button3.place(relx=0.4, rely=0.2, anchor="center")
		
		Button4 = ctk.CTkButton(self, text="Make a backup", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.copy_SecUSB)
		Button4.place(relx=0.55, rely=0.2, anchor="center")
		
		Button5 = ctk.CTkButton(self, text="Clone the system", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.clone_microSD)
		Button5.place(relx=0.7, rely=0.2, anchor="center")
		
		Button6 = ctk.CTkButton(self, text="Restore from USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.restore_SecUSB)
		Button6.place(relx=0.85, rely=0.2, anchor="center")
		
		if path_to_USB_secure == 'Secure USB folder is not available':
			Button8 = ctk.CTkButton(self, text="Log in", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			Button8.place(relx=0.5, rely=0.5, anchor="center")
			Label = ctk.CTkLabel(self, text="Or", text_color="white", font=("Helvetica", 18), fg_color="black")
			Label.place(relx=0.5, rely=0.55, anchor="center")
			Button7 = ctk.CTkButton(self, text="Create new user account", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.new_secureUSB_Pre)
			Button7.place(relx=0.5, rely=0.6, anchor="center")
	
	def create_DigitalIDmeny(self):
		global DigitalID_button_color
		global path_to_USB_secure
		
		self.create_DigitalIDbox()
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Button1 = ctk.CTkButton(self, text="Digital ID", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDmeny)
		Button1.place(relx=0.1, rely=0.2, anchor="center")
		
		Button2 = ctk.CTkButton(self, text="Nostr", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.Nostr_main)
		Button2.place(relx=0.25, rely=0.2, anchor="center")
		
		Button3 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDmeny)
		Button3.place(relx=0.4, rely=0.2, anchor="center")
		
		Button4 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDmeny)
		Button4.place(relx=0.55, rely=0.2, anchor="center")
		
		Button5 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDmeny)
		Button5.place(relx=0.7, rely=0.2, anchor="center")
		
		Button6 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDmeny)
		Button6.place(relx=0.85, rely=0.2, anchor="center")
	
	def create_Bitcoinmeny(self):
		global Boltcard_button_color
		global path_to_USB_secure
		
		self.create_BitcoinWalletmeny()
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Button1 = ctk.CTkButton(self, text="Bitcoin wallets", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
		Button1.place(relx=0.1, rely=0.2, anchor="center")
		
		Button2 = ctk.CTkButton(self, text="BTC single wallets", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.create_Bitcointextbox, 'all'))
		Button2.place(relx=0.25, rely=0.2, anchor="center")
		
		Button3 = ctk.CTkButton(self, text="Bolt cards", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Boltcardmeny)
		Button3.place(relx=0.4, rely=0.2, anchor="center")
		
		pathInheritanceMsg = str(filepathdestinationfolder) + "/secure/inheritanceMessage.txt"
		if os.path.isfile(pathInheritanceMsg):
			Button4 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
			Button4.place(relx=0.55, rely=0.2, anchor="center")
		else:
			Button4 = ctk.CTkButton(self, text="Inheritance", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.inheritance_pre)
			Button4.place(relx=0.55, rely=0.2, anchor="center")
		
		Button5 = ctk.CTkButton(self, text="Create password", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.createPassword, "none"))
		Button5.place(relx=0.7, rely=0.2, anchor="center")
		
		Button6 = ctk.CTkButton(self, text=" ", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
		Button6.place(relx=0.85, rely=0.2, anchor="center")
				
	def create_FIDOmeny(self):
		global FIDO_button_color
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")	
		
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=0, anchor="nw")
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			pathtoIDimage = str(filepathdestinationfolder) + "/images/Yubikey5CBackground.JPG"

			IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDimage), dark_image=Image.open(pathtoIDimage), size=(230, 100))
			completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			counter = 0
			Buttonnew = ctk.CTkButton(right_Frame, text="New Passkey", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=25, font=my_font, command=self.newFIDO)
			Buttonnew.place(relx=0.9, rely=0.05, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)
			
			passLabel = ctk.CTkLabel(right_Frame, text="Add new Passkey:", text_color="white", font=my_font, fg_color="black")
			passLabel.place(relx=0.1, rely=0.15, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			
			infoLabel = ctk.CTkLabel(right_Frame, text="1. Use a hardware key with FIDO2 (Passkey) support (ex. Yubikey 5 or similar).", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.1, rely=0.21, anchor="w")
			infoLabel2 = ctk.CTkLabel(right_Frame, text="   - Reset the key using an offline device (this will remove factory keys and generate new keys).", text_color="white", font=my_font, fg_color="black")
			infoLabel2.place(relx=0.1, rely=0.26, anchor="w")
			infoLabel3 = ctk.CTkLabel(right_Frame, text="2. - Register the Passkey online at all services that the specific key should work with.", text_color="white", font=my_font, fg_color="black")
			infoLabel3.place(relx=0.1, rely=0.32, anchor="w")
			infoLabel4 = ctk.CTkLabel(right_Frame, text="3. Remember to have at minimum two keys registered for each service, as one key could get lost/stolen or break.", text_color="white", font=my_font, fg_color="black")
			infoLabel4.place(relx=0.1, rely=0.41, anchor="w")
			infoLabel5 = ctk.CTkLabel(right_Frame, text="4. Add a new Passkey entry on the offline device (this device) by clicking \"New Passkey\".", text_color="white", font=my_font, fg_color="black")
			infoLabel5.place(relx=0.1, rely=0.46, anchor="w")
			infoLabel6 = ctk.CTkLabel(right_Frame, text="   - Give the Passkey a name. Its good practice to include the keys printed serial number or similar", text_color="white", font=my_font, fg_color="black")
			infoLabel6.place(relx=0.1, rely=0.51, anchor="w")
			infoLabel7 = ctk.CTkLabel(right_Frame, text="   - Give the Passkey a description.", text_color="white", font=my_font, fg_color="black")
			infoLabel7.place(relx=0.1, rely=0.56, anchor="w")
			infoLabel8 = ctk.CTkLabel(right_Frame, text="5. After created a Passkey entry click on it and click \"Edit\" and enter services that it is registered at.", text_color="white", font=my_font, fg_color="black")
			infoLabel8.place(relx=0.1, rely=0.61, anchor="w")
			infoLabel9 = ctk.CTkLabel(right_Frame, text="   - This information is only to help in remembering what key is used for what.", text_color="white", font=my_font, fg_color="black")
			infoLabel9.place(relx=0.1, rely=0.66, anchor="w")
			infoLabel10 = ctk.CTkLabel(right_Frame, text="6. Keep the extra Passkey(s) safe.", text_color="white", font=my_font, fg_color="black")
			infoLabel10.place(relx=0.1, rely=0.71, anchor="w")
			
			proLabel = ctk.CTkLabel(right_Frame, text="(Tip: Passkeys are more secure as there is no password/username sent over the Internet to access an account.)", text_color="white", font=my_font, fg_color="black")
			proLabel.place(relx=0.1, rely=0.85, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)								
			cardLabel = ctk.CTkLabel(left_Frame, text="Passkeys", text_color="white", font=my_font, fg_color="black").pack(padx=10, pady=8, side= TOP, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			Counting = 0
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if Counting == 0:	
								Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showFIDO, lines[0]))
								Button1.pack(padx=10, pady=18, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showFIDO, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							Counting += 1
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Passkeys found.")
		else:
			notOKButton = ctk.CTkButton(right_Frame, text="You are not logged in.", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def showFIDO(self, FIDOname):
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=648,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			pathtoicon = str(filepathdestinationfolder) + "/images/Yubikey5CBackground.JPG"

			iconimage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(230, 100))
			
			completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)								
			cardLabel = ctk.CTkLabel(left_Frame, text="Passkeys", text_color="white", font=my_font, fg_color="black").pack(padx=10, pady=8, side= TOP, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			Counting = 0
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if Counting == 0:	
								Button1 = ctk.CTkButton(left_Frame, text="", image = iconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showFIDO, lines[0]))
								Button1.pack(padx=10, pady=18, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = iconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showFIDO, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							Counting += 1
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Passkeys found.")
			Buttonnew = ctk.CTkButton(right_Frame, text="New Passkey", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=20, font=my_font, command=self.newFIDO)
			Buttonnew.place(relx=0.9, rely=0.05, anchor="center")
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:

						if lines[0] == FIDOname:								
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							nameheadLabel = ctk.CTkLabel(right_Frame, text="Name of Passkey:", text_color="white", font=my_font, fg_color="black")
							nameheadLabel.place(relx=0.05, rely=0.18, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)								
							nameLabel = ctk.CTkLabel(right_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							nameLabel.place(relx=0.05, rely=0.22, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)
							descrheadLabel = ctk.CTkLabel(right_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.05, rely=0.27, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)								
							descrLabel = ctk.CTkLabel(right_Frame, text=lines[1], text_color="white", font=my_font, fg_color="black")
							descrLabel.place(relx=0.05, rely=0.31, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)
							descrheadLabel = ctk.CTkLabel(right_Frame, text="Used for services:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.05, rely=0.36, anchor="w")
							
							my_text = ctk.CTkTextbox(right_Frame, width=500, height=150, corner_radius=1, border_width=0, border_color="brown", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
							my_text.insert('end', lines[2])
							my_text.configure(state="disabled")
							my_text.place(relx=0.05, rely=0.4, anchor="nw")
														
							my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
							Buttonedit = ctk.CTkButton(right_Frame, text="Edit", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.editFIDO, FIDOname))
							Buttonedit.place(relx=0.25, rely=0.85, anchor="center")
							delButton = ctk.CTkButton(right_Frame, text="Delete", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.deleteFIDO, FIDOname))
							delButton.place(relx=0.5, rely=0.85, anchor="center")
							backButton = ctk.CTkButton(right_Frame, text="Back", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_FIDOmeny)
							backButton.place(relx=0.75, rely=0.85, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Passkeys file found.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")

	def editFIDO(self, FIDOname):
		global SecUSB_button_color
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		theinput = ''
		my_text = ctk.CTkTextbox(my_Frame, width=500, height=150, corner_radius=1, border_width=0, border_color="brown", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
							
		def do_edit_FIDO():
			global filepathdestinationfolder
			Updated_name = nameEntry.get()
			Updated_description = descriptionEntry.get()
			theinput = self.textBox.get("1.0",'end-1c')
			
			Updated_FIDO_data = [
								Updated_name,
								Updated_description,
								theinput]
								
			completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"
			updatedcompleteName = str(filepathdestinationfolder) + "/secure/FIDO/updatedFIDOkeys.csv"
			with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
				csvreader = csv.reader(source)
				csvwriter = csv.writer(result)
				for row in csv.reader(source):
					try:
						if row[0] == FIDOname:
							csvwriter.writerow(Updated_FIDO_data)
						else:
							csvwriter.writerow(row)						
					except:
						continue
			shutil.copy(updatedcompleteName, completeName)
			os.remove(updatedcompleteName)	
			self.create_FIDOmeny()
		
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"
		# Read the content of the FIDO key in csv-file
		if path_to_USB_secure == 'Secure USB folder is available':
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == FIDOname:
							my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
							nameheadLabel = ctk.CTkLabel(my_Frame, text="Name of Passkey:", text_color="white", font=my_font, fg_color="black")
							nameheadLabel.place(relx=0.2, rely=0.18, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)								
							
							the_name_var = ctk.StringVar(value=lines[0])
		
							nameEntry = ctk.CTkEntry(my_Frame, placeholder_text=lines[0], textvariable=the_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							nameEntry.place(relx=0.2, rely=0.24, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
							
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.2, rely=0.29, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)								
							
							the_description_var = ctk.StringVar(value=lines[1])
							
							descriptionEntry = ctk.CTkEntry(my_Frame, placeholder_text=lines[1], textvariable=the_description_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							descriptionEntry.place(relx=0.2, rely=0.33, anchor="w")
							
							my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Used for services:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.2, rely=0.38, anchor="w")
							
							color_setting = 'none'
							completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
							my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
						
							try:
								with open(completeName, 'r') as file:
									csvfile = csv.reader(file)
									for lines2 in csvfile:
										if lines:	
											color_setting = lines2[1]
							except FileNotFoundError:
								logged_in_user = '<no settings file found>'
							
							if color_setting == 'Dark':
								self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
								self.textBox.config(insertbackground='white')
							else:
								self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
							
							self.textBox.insert("1.0", lines[2])
							self.textBox.place(relx=0.2, rely=0.42, height=220, width=600, anchor="nw")
							self.textBox.focus_set()
							self.textBox.focus_force()
							theinput = self.textBox.get("1.0",'end-1c')
							my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
								
							backButton = ctk.CTkButton(my_Frame, text="Save", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=do_edit_FIDO)
							backButton.place(relx=0.5, rely=0.85, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Passkeys file found.")
		else:
			my_textbox.insert('end', 'You are not logged in. Cant edit.')
			
	def deleteFIDO(self, FIDOname):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"
		updatedcompleteName = str(filepathdestinationfolder) + "/secure/FIDO/updatedFIDOkeys.csv"
		with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[0] == FIDOname:
						answer = messagebox.askquestion('Important!', 'Are you sure you want to delete the Passkey?')
						if answer == 'yes':
							print("Sure")
						else:
							csvwriter.writerow(row)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updatedcompleteName, completeName)
		os.remove(updatedcompleteName)	
		self.create_FIDOmeny()
		
	def newFIDO(self):
		global filepathdestinationfolder
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%m%d%Y%H%M%S")
		
		# Create a new card. Details and pictures from USB-drive
		USER_INP = simpledialog.askstring(title="Name required!", prompt="Enter name for new Passkey:")
		
		if USER_INP == "" or USER_INP == " ":
			USER_INP = "Passkey" + timeStamp
		
		USER_INP_tr = USER_INP[:100] if len(USER_INP) > 100 else USER_INP
		
		USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Passkey (optional):")
		
		if USER_INP2 == "" or USER_INP2 == " ":
			USER_INP2 = "-"
		
		USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
		
		new_FIDOkey = [USER_INP_tr, USER_INP2_tr, '<Empty>']
		
		completeName = str(filepathdestinationfolder) + "/secure/FIDO/FIDOkeys.csv"	
		
		try:
			f = open(completeName, 'a')
			writer = csv.writer(f)
			writer.writerow(new_FIDOkey)
			f.close()
		except FileNotFoundError:
			messagebox.showinfo("Information", "No Passkeys file found.")
		self.add_history("Added new Passkey: " + USER_INP_tr + " (" + USER_INP2_tr + ")")
		self.create_FIDOmeny()
	
	def new_Alias_real_name(self, fingerprint, the_alias):
		# Check if alias file exists. If not create it and add the alias and trust selected
		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		brand_new_alias = True
		new_Alias = [fingerprint, the_alias]
		if not os.path.isfile(file_):
			f = open(file_, 'w')
			writer = csv.writer(f)
			writer.writerow(new_Alias)
			f.close()
		else:
			# Go through the alias file and check that the new alias is unique
			with open(file_, 'r') as in_:
				csvfile = csv.reader(in_)
				for lines in csvfile:
					if lines[1] == the_alias and lines[0] != fingerprint:
						brand_new_alias = False
			
			if brand_new_alias:	
				# Remove any old alias-line for the fingerprint and append with new
				self.remove_Alias(fingerprint)
				with open(file_, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_Alias)
		
	def new_Alias(self, fingerprint):
		global filepathdestinationfolder
		already_there = False
		
		def try_again():
			messagebox.showinfo("Information", "The alias can be max 42 characters.")
			self.new_Alias(fingerprint)
			
		# Create a new alias.
		USER_INP = simpledialog.askstring(title="Information!", prompt="Enter alias for key:")
		input_size = len(USER_INP)
		if input_size > 42:
			try_again()
		new_Alias = [fingerprint, USER_INP]
		file_ = filepathdestinationfolder + "/secure/Alias.csv"	
			
		# Check if alias file exists. If not create it
		if not os.path.isfile(file_):
			f = open(file_, 'w')
			writer = csv.writer(f)
			writer.writerow(new_Alias)
			f.close()
		else:
			try:
				f = open(file_, 'r')
				for row in csv.reader(f):
					if row[1] == USER_INP:
						already_there = True
						messagebox.showinfo("Information", "Alias already exists!")
				f.close()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Alias file found.")
			if not already_there:
				try:
					f = open(file_, 'a')
					writer = csv.writer(f)
					writer.writerow(new_Alias)
					f.close()
					new_record = [fingerprint, "New alias.", USER_INP]
					self.add_record(new_record)
					self.add_history("Added new alias: " + USER_INP + ", for key " + fingerprint)
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
		self.get_GnuPGKeys_compact(['_none__'])
	
	def lookup_Alias(self, fingerprint):
		global filepathdestinationfolder
		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		if os.path.isfile(file_):
			try:
				f = open(file_, 'r')
				for row in csv.reader(f):
					if row[0] == fingerprint:
						the_Alias = row[1]
						return the_Alias	
				f.close()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Alias file found.")
		return fingerprint
	
	def lookup_Alias_absolut(self, fingerprint):
		global filepathdestinationfolder
		the_Alias = "None"
		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		if os.path.isfile(file_):
			try:
				f = open(file_, 'r')
				for row in csv.reader(f):
					if row[0] == fingerprint:
						the_Alias = row[1]	
				f.close()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Alias file found.")
		return the_Alias
	
	def lookup_fingerprint(self, alias):
		global filepathdestinationfolder
		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		if os.path.isfile(file_):
			try:
				f = open(file_, 'r')
				for row in csv.reader(f):
					if row[1] == alias:
						the_Fingerprint = row[0]
						return the_Fingerprint
				f.close()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Alias file found.")
		return alias
		
	def get_Aliases(self, list_of_fingerprints):
		global filepathdestinationfolder
		List_fingerprints_and_aliases = []

		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		# For each row in the list of fingerprints check if there is an alias. If not add the fingerprint in both locations
		if os.path.isfile(file_):
			for nkey in list_of_fingerprints:
				found_fingerprint = False
				try:
					f = open(file_, 'r')
					for row in csv.reader(f):
						if row[0] == nkey:
							List_fingerprints_and_aliases.append(row[1])
							found_fingerprint = True	
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
				if not found_fingerprint:
					List_fingerprints_and_aliases.append(nkey)
		else:
			return list_of_fingerprints
		return List_fingerprints_and_aliases	
		
	def remove_Alias(self, fingerprint):
		global filepathdestinationfolder
		file_ = filepathdestinationfolder + "/secure/Alias.csv"
		temp_file_ = filepathdestinationfolder + "/secure/temp_Alias.csv"
		if os.path.isfile(file_):
			with open(file_, 'r') as inp, open(temp_file_, 'w') as out:
				writer = csv.writer(out)
				for row in csv.reader(inp):
					if row[0] != fingerprint:
						writer.writerow(row)	
			shutil.copy(temp_file_, file_)
		self.get_GnuPGKeys_compact(['_none__'])
			
	def create_Boltcardmeny(self):
		global Boltcard_button_color
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")	
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=0, anchor="nw")
		pathtobackg = "/home/user1/images/boltcardbackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			counter = 0
			Buttonnew = ctk.CTkButton(right_Frame, text="Add card (USB)", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=150, height=20, font=my_font, command=self.newcard)
			Buttonnew.place(relx=0.88, rely=0.05, anchor="center")
			
			readButton = ctk.CTkButton(right_Frame, text="Add card (QR)", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=150, height=20, font=my_font, command=self.addCard_with_QR) 
			readButton.place(relx=0.88, rely=0.11, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
			
			boltLabel = ctk.CTkLabel(right_Frame, text="Add a Bolt card:", text_color="white", font=my_font, fg_color="black")
			boltLabel.place(relx=0.06, rely=0.1, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			
			infoLabel = ctk.CTkLabel(right_Frame, text="1. Register an account at a LN Hub (ex. lates.lightningok.win or similar).", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.06, rely=0.15, anchor="w")
			infoLabel2 = ctk.CTkLabel(right_Frame, text="   - Create a wallet, activate the extensions \"Bolts card\" and LNURLp.", text_color="white", font=my_font, fg_color="black")
			infoLabel2.place(relx=0.06, rely=0.2, anchor="w")
			infoLabel3 = ctk.CTkLabel(right_Frame, text="2. Use apps \"NFC tools\" and \"Bolt Card NFC Card Creator\" to make a card.", text_color="white", font=my_font, fg_color="black")
			infoLabel3.place(relx=0.06, rely=0.25, anchor="w")
			infoLabel4 = ctk.CTkLabel(right_Frame, text="3. With the data from your LN Hub-account make a text file with eight lines:", text_color="white", font=my_font, fg_color="black")
			infoLabel4.place(relx=0.06, rely=0.3, anchor="w")
			infoLabel5 = ctk.CTkLabel(right_Frame, text="   - LNURL link", text_color="white", font=my_font, fg_color="black")
			infoLabel5.place(relx=0.06, rely=0.35, anchor="w")
			infoLabel6 = ctk.CTkLabel(right_Frame, text="   - Reset code", text_color="white", font=my_font, fg_color="black")
			infoLabel6.place(relx=0.06, rely=0.4, anchor="w")
			infoLabel7 = ctk.CTkLabel(right_Frame, text="   - Program code", text_color="white", font=my_font, fg_color="black")
			infoLabel7.place(relx=0.06, rely=0.45, anchor="w")
			infoLabel8 = ctk.CTkLabel(right_Frame, text="   - Withdrawal limit", text_color="white", font=my_font, fg_color="black")
			infoLabel8.place(relx=0.06, rely=0.50, anchor="w")
			infoLabel9 = ctk.CTkLabel(right_Frame, text="   - Daily withdrawal limit", text_color="white", font=my_font, fg_color="black")
			infoLabel9.place(relx=0.06, rely=0.55, anchor="w")
			infoLabel10 = ctk.CTkLabel(right_Frame, text="   - Link to the Bolt Hub", text_color="white", font=my_font, fg_color="black")
			infoLabel10.place(relx=0.06, rely=0.6, anchor="w")
			infoLabel11 = ctk.CTkLabel(right_Frame, text="   - Bolt Hub user name", text_color="white", font=my_font, fg_color="black")
			infoLabel11.place(relx=0.06, rely=0.65, anchor="w")
			infoLabel12 = ctk.CTkLabel(right_Frame, text="   - Bolt Hub account password", text_color="white", font=my_font, fg_color="black")
			infoLabel12.place(relx=0.06, rely=0.7, anchor="w")
			infoLabel13 = ctk.CTkLabel(right_Frame, text="4. Click \"New card\" and add Bolt card using the a file/QR with above lines in it.", text_color="white", font=my_font, fg_color="black")
			infoLabel13.place(relx=0.06, rely=0.75, anchor="w")
			infoLabel14 = ctk.CTkLabel(right_Frame, text="Alt. You can get an encrypted and signed file with above textlines from the Internet.", text_color="white", font=my_font, fg_color="black")
			infoLabel14.place(relx=0.06, rely=0.8, anchor="w")
			
			proLabel = ctk.CTkLabel(right_Frame, text="Use a unique encryption key for receiving encrypted and signed Boltcard files.", text_color="white", font=my_font, fg_color="black")
			proLabel.place(relx=0.06, rely=0.85, anchor="w")
			proLabel2 = ctk.CTkLabel(right_Frame, text="Use button \"Add card (QR)\" above to add a card using unencrypted text in QR-format.", text_color="white", font=my_font, fg_color="black")
			proLabel2.place(relx=0.06, rely=0.9, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)								
			cardLabel = ctk.CTkLabel(left_Frame, text="Bolt cards", text_color="white", font=my_font, fg_color="black").pack(padx=10, pady=8, side= TOP, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			Counting = 0
			
			pathtodefaulticon = filepathdestinationfolder + "/images/defaultcardIcon.jpg"
			completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"	
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
							b_icon_path = filepathdestinationfolder + "/secure/boltcards/" + lines[2] + ".jpg"
							if os.path.isfile(b_icon_path):
								pathtoWalletIconimage = b_icon_path
								boltcardiconimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(168, 106))
								Button1 = ctk.CTkButton(left_Frame, text="", image = boltcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=168, height=106, font=my_font, command=partial(self.showcard, lines[2]))
							else:
								boltcardiconimage = ctk.CTkImage(light_image=Image.open(pathtodefaulticon), dark_image=Image.open(pathtodefaulticon), size=(168, 106))
								Button1 = ctk.CTkButton(left_Frame, text="", image = boltcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=168, height=106, font=my_font, command=partial(self.showcard, lines[2]))
							if Counting == 0:	
								Button1.pack(padx=0, pady=10, side= TOP, anchor="center")
								Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
								Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							else:
								Button1.pack(padx=0, pady=8, side= TOP, anchor="center")
								Llabel2 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
								Llabel2.pack(padx=1, pady=0, side= TOP, anchor="center")
							Counting += 1
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Bolt cards file found.")
		else:
			notOKButton = ctk.CTkButton(right_Frame, text="You are not logged in.", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def showcard(self, cardidentification):
		global filepathdestinationfolder
		global pathtoloadaddress
		global Name_, Created_, Public_address_, Program_keys, Program_link, Max_withrawal_limit_, Max_daily_withrawal_limit_, httpaddress, username, password
		httpaddress = ''
		username = ''
		Name_ = ''
		password = ''
		found = False
		Name_ = ''
		Description_ = ''
		Created_ = ''
		Public_address_ = ''
		Program_keys = ''
		Program_link = ''
		Max_withrawal_limit_ = ''
		Max_daily_withrawal_limit_ = ''
		httpaddress = ''
		username = ''
		password = ''
								
		def flipCard():
			pathtoicon = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '_back.jpg'
			pathtodefaulticon = filepathdestinationfolder + "/images/defaultcardIcon_back.jpg"
			
			if os.path.isfile(pathtoicon):
				iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(306, 193))
				Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=flipCardBack)
				Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
			
			elif os.path.isfile(pathtodefaulticon):
				iconImage = ctk.CTkImage(light_image=Image.open(pathtodefaulticon), dark_image=Image.open(pathtodefaulticon), size=(306, 193))
				Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=flipCardBack)
				Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
		
		def flipCardBack():
			pathtoicon = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '.jpg'
			pathtodefaulticon = filepathdestinationfolder + "/images/defaultcardIcon.jpg"
			
			if os.path.isfile(pathtoicon):
				iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(306, 193))
				Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=flipCard)
				Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
			
			elif os.path.isfile(pathtodefaulticon):
				iconImage = ctk.CTkImage(light_image=Image.open(pathtodefaulticon), dark_image=Image.open(pathtodefaulticon), size=(306, 193))
				Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=flipCard)
				Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
					
		def show_LNHubdata():
			LNHubdata = 'Login details LN Hub:\n\n' + httpaddress + '\n\nUser name: ' + username + '\n\n  Password: ' + password  
			messagebox.showinfo("LN Hub login", LNHubdata)
			
		def save_load_QR():
			tk.messagebox.showinfo('Information', 'Insert the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select where to save the image with the load- address.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			pathtopic = outputdir + '/Boltcard_load_address.png'
			shutil.copy(pathtoloadaddress, pathtopic)
			
			if os.path.isfile(pathtopic):
				tk.messagebox.showinfo('Information', 'QR image has been saved.')
		
		def exportCard():
			global Name_, Created_, Public_address_, Program_keys, Program_link, Max_withrawal_limit_, Max_daily_withrawal_limit_
			global httpaddress, username, password
			
			pathtofile = filepathdestinationfolder + "/secure/boltcards/" + Name_ + '_' + cardidentification + '.txt'
			answer = messagebox.askquestion('Important!', 'Do you want to save the Boltcard on an external USB-device?')
			if answer == 'yes':
				result = tk.messagebox.askokcancel("Information", "Connect the USB-device and then click \"OK\".")
				if not result:
					self.showcard(cardidentification)
					return
				time.sleep(2)
				result = tk.messagebox.askokcancel('Information', 'Select where to save the Boltcard file.')
				if not result:
					self.showcard(cardidentification)
					return
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
			else:
				tk.messagebox.showinfo('Information', 'Select where to save the Boltcard file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			
			# Reconstruct the file from csv to txt (exactly 8-lines)
			data = Public_address_ + '\n' +	Program_keys + '\n' + Program_link + '\n' + Max_withrawal_limit_ + '\n' + Max_daily_withrawal_limit_ + '\n' + httpaddress + '\n' + username + '\n' + password
				
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			str_USER_INP = ''.join([char for char in USER_INP if char.isalnum() or char.isspace() or char == '_' or char == '-'])
			if str_USER_INP == '':
				str_USER_INP = Name_ + ' ' + Created_[-13:]
				str_USER_INP = ''.join([char for char in str_USER_INP if char.isalnum() or char.isspace() or char == '_' or char == '-'])
				
			c = open(outputdir + '/' + str_USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(data)
			c.close()
			messagebox.showinfo('Information', 'File \"' + str_USER_INP + '.txt\"' + ' has been saved.')
				
		def update_icon():
			tk.messagebox.showinfo('Information', 'Connect the USB-device with the new icon and then click \"OK\".')
			time.sleep(2)
			messagebox.showinfo("Information", "Select the picture for your boltcard icon (\".png\" or \".jpg\" format)")
			time.sleep(2)
			pathtopicture = filedialog.askopenfilename(initialdir='/media/user1')
			
			filename_list = pathtopicture.split(".")
			filename_ending = str(filename_list[-1])
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + ".jpg"
			
			if filename_ending == 'JPG' or filename_ending == 'jpg':
				img_open = Image.open(pathtopicture)
				img_open.save(pathtopicturearchivelocation)
			elif filename_ending == 'PNG' or filename_ending == 'png':
				img_open = Image.open(pathtopicture).convert("RGB")
				img_open.save(pathtopicturearchivelocation)
			else:
				messagebox.showinfo("Information", "The boltcard icon image needs to be \".png\" or \".jpg\" format!")
				
			answer = messagebox.askquestion('Important!', 'Do you have a picture of the Bolt cards backside?')
			if answer == 'yes':
				pathtoicon = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '_back.jpg'
				messagebox.showinfo("Information", "Select the picture for your boltcards backside (\".png\" or \".jpg\" format)")
				pathtopicturebackside = filedialog.askopenfilename(initialdir='/media/user1')
				
				filename_list = pathtopicturebackside.split(".")
				filename_ending = str(filename_list[-1])
				pathtoiconbackside = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '_back.jpg'
				
				if filename_ending == 'JPG' or filename_ending == 'jpg':
					img_open = Image.open(pathtopicturebackside)
					img_open.save(pathtoiconbackside)
				elif filename_ending == 'PNG' or filename_ending == 'png':
					img_open = Image.open(pathtopicturebackside).convert("RGB")
					img_open.save(pathtoiconbackside)
				else:
					messagebox.showinfo("Information", "The image needs to be \".png\" or \".jpg\" format!")
			else:
				pathtoiconbackside = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '_back.jpg'
				if os.path.isfile(pathtoiconbackside):
					os.remove(pathtoiconbackside)
			self.showcard(cardidentification)
		
		def create_boltcardtextbox():
			try:
				f = open("/home/user1/help/boltcardtextbox.txt", "r")
				file_content = f.read()
				f.close()
				my_text = ctk.CTkTextboxCTkTextbox(right_Frame, width=896, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 22), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', file_content)
			except OSError:
				my_text = ctk.CTkTextbox(right_Frame, width=896, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 22), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
			my_text.configure(state="disabled")
			my_text.place(relx=0.5, rely=0.5, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
			backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=partial(self.showcard, cardidentification))
			backButton.place(relx=0.93, rely=0.96, anchor="center")
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/boltcardbackground.JPG"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if lines[2] == cardidentification:
								Name_ = lines[0]
								Description_ = lines[1]
								Created_ = lines[2]
								Public_address_ = lines[3]
								Program_keys = lines[4]
								Program_link = lines[5]
								Max_withrawal_limit_ = lines[6]
								Max_daily_withrawal_limit_ = lines[7]
								httpaddress = lines[8]
								username = lines[9]
								password = lines[10]
								found = True
				file.close()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No Bolt cards file found.")
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
			if found:
				# Generate QR-codes for Public address and display on screen
				load_address = qrcode.make(Public_address_, version=1)
				
				resize_load_address = load_address.resize((280, 280))
				pathtoloadaddress = str(filepathdestinationfolder) + "/secure/boltcards/load.png"
				
				resize_load_address.save(pathtoloadaddress)
				
				loadimg = ctk.CTkImage(light_image=Image.open(pathtoloadaddress), dark_image=Image.open(pathtoloadaddress), size=(230, 230))
				
				pathtoicon = filepathdestinationfolder + "/secure/boltcards/" + cardidentification + '.jpg'
				pathtodefaulticon = filepathdestinationfolder + "/images/defaultcardIcon.jpg"
				
				# The picture of a card
				pathtoboltcardicon = str(filepathdestinationfolder) + "/images/boltcardicon.JPG"
				
				# Show icon or default icon in left frame
				if os.path.isfile(pathtoicon):
					boltcardiconimage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(168, 106))
					Button1 = ctk.CTkButton(left_Frame, text="", image = boltcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=168, height=106, font=my_font, command=partial(self.showcard, cardidentification))
					Button1.pack(padx=0, pady=8, side= TOP, anchor="center")
					Llabel1 = ctk.CTkLabel(left_Frame, text=Name_, text_color="white", font=my_font, fg_color="black")
					Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
				else:
					boltcardiconimage = ctk.CTkImage(light_image=Image.open(pathtodefaulticon), dark_image=Image.open(pathtodefaulticon), size=(168, 106))
					Button1 = ctk.CTkButton(left_Frame, text="", image = boltcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=168, height=106, font=my_font, command=partial(self.showcard, cardidentification))
					Button1.pack(padx=0, pady=8, side= TOP, anchor="center")
					Llabel1 = ctk.CTkLabel(left_Frame, text=Name_, text_color="white", font=my_font, fg_color="black")
					Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
								
				# Show Boltcard picture or default Boltcard picture in right frame
				if os.path.isfile(pathtoicon):
					boltcardDefaulticonimage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(306, 193))
					Buttonicon = ctk.CTkButton(right_Frame, text='', image = boltcardDefaulticonimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=306, height=193, font=my_font, command=flipCard)
					Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
				else:	
					boltcardDefaulticonimage = ctk.CTkImage(light_image=Image.open(pathtodefaulticon), dark_image=Image.open(pathtodefaulticon), size=(306, 193))
					Buttonicon = ctk.CTkButton(right_Frame, text='', image = boltcardDefaulticonimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=306, height=193, font=my_font, command=flipCard)
					Buttonicon.place(relx=0.56, rely=0.3, anchor="e")
						
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)

				pubLabel = ctk.CTkLabel(right_Frame, text="Load (via Lightning network):", text_color="white", font=my_font, fg_color="black")
				pubLabel.place(relx=0.06, rely=0.52, anchor="w")
				Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = loadimg)
				Labelpublicimg.place(relx=0.2, rely=0.74, anchor="center")
				
				my_font = ctk.CTkFont(family="Arial", size=28, weight='bold', slant="roman", underline=False, overstrike=False)								
				nameLabel = ctk.CTkLabel(right_Frame, text=Name_, text_color="white", font=my_font, fg_color="black")
				nameLabel.place(relx=0.5, rely=0.07, anchor="center")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
				
				descrheadLabel = ctk.CTkLabel(right_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
				descrheadLabel.place(relx=0.59, rely=0.14, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)								
				descrLabel = ctk.CTkLabel(right_Frame, text=Description_, text_color="white", font=my_font, fg_color="black")
				descrLabel.place(relx=0.59, rely=0.18, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
				maxLabel = ctk.CTkLabel(right_Frame, text="Max withrawal limit:", text_color="white", font=my_font, fg_color="black")
				maxLabel.place(relx=0.59, rely=0.24, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)								
				maxLabel2 = ctk.CTkLabel(right_Frame, text=Max_withrawal_limit_, text_color="white", font=my_font, fg_color="black")
				maxLabel2.place(relx=0.59, rely=0.28, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
				maxDailyLabel = ctk.CTkLabel(right_Frame, text="Max daily withrawal limit:", text_color="white", font=my_font, fg_color="black")
				maxDailyLabel.place(relx=0.59, rely=0.34, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)								
				maxDailyLabel2 = ctk.CTkLabel(right_Frame, text=Max_daily_withrawal_limit_, text_color="white", font=my_font, fg_color="black")
				maxDailyLabel2.place(relx=0.59, rely=0.38, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
				dateheadLabel = ctk.CTkLabel(right_Frame, text="Created", text_color="white", font=my_font, fg_color="black")
				dateheadLabel.place(relx=0.59, rely=0.44, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
				dateLabel = ctk.CTkLabel(right_Frame, text=Created_, text_color="white", font=my_font, fg_color="black")
				dateLabel.place(relx=0.59, rely=0.48, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				saveQRButton = ctk.CTkButton(right_Frame, text="Save paylink to USB", text_color="white", fg_color="brown", border_width=2, border_color="white", width=200, height=30, font=my_font, command=save_load_QR)
				saveQRButton.place(relx=0.08, rely=0.96, anchor="w")

				LNHubButton = ctk.CTkButton(right_Frame, text="Show LN Hub login", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=show_LNHubdata)
				LNHubButton.place(relx=0.65, rely=0.6, anchor="e")
				resetButton = ctk.CTkButton(right_Frame, text="Update card icon", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=update_icon)
				resetButton.place(relx=0.65, rely=0.66, anchor="e")
				programButton2 = ctk.CTkButton(right_Frame, text="Update card details", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.updatecard, cardidentification))
				programButton2.place(relx=0.65, rely=0.72, anchor="e")

				
				resetButton = ctk.CTkButton(right_Frame, text="Reset card", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.resetcard, cardidentification))
				resetButton.place(relx=0.66, rely=0.6, anchor="w")
				delButton = ctk.CTkButton(right_Frame, text="Delete card", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.deletecard, cardidentification))
				delButton.place(relx=0.66, rely=0.66, anchor="w")
				exportButton = ctk.CTkButton(right_Frame, text="Export card data to file", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=exportCard)
				exportButton.place(relx=0.66, rely=0.72, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", weight="bold", underline=False, overstrike=False)
				
				Buttonmoreinfo = ctk.CTkButton(right_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=create_boltcardtextbox)
				Buttonmoreinfo.place(relx=0.93, rely=0.96, anchor="center")
				 
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", weight="bold", underline=False, overstrike=False)
				
				backButton = ctk.CTkButton(right_Frame, text="Back", text_color="white", fg_color="brown", border_width=2, border_color="white", width=120, height=32, font=my_font, command=self.create_Boltcardmeny)
				backButton.place(relx=0.66, rely=0.92, anchor="center")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def inheritance_pre(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = str(filepathdestinationfolder) + '/images/Inheritance_background.JPG'
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=30, weight="bold", slant="roman", underline=True, overstrike=False)

		Label1 = ctk.CTkLabel(my_Frame, text="Make an inheritance package", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.14, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="The inheritance package consists of three parts. The key file, the encrypted archive and the signature file.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.24, anchor="center")
		
		Label22 = ctk.CTkLabel(my_Frame, text="Give these three files to several trusted persons/companies. Give the password for the encryption key to the beneficiary.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.5, rely=0.32, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		Label33 = ctk.CTkLabel(my_Frame, text="There is an option to send a bitcoin (timestamp) transaction to an address calculated by the signature and archive files.", text_color="white", fg_color="black", font=my_font)
		Label33.place(relx=0.5, rely=0.38, anchor="center")
		Label3 = ctk.CTkLabel(my_Frame, text="(This gives the beneficiary the possibility to check WHEN you signed it using the Bitcoin blockchain)", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.46, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", weight='bold', underline=False, overstrike=False)
		
		disclaimerLabel = ctk.CTkLabel(my_Frame, text="DISCLAIMER! EXPERIMENTAL SOFTWARE. PROCEED WITH CAUTION!", text_color="white", fg_color="black", font=my_font)
		disclaimerLabel.place(relx=0.5, rely=0.56, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		theButton = ctk.CTkButton(my_Frame, text="Start!", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.inheritance, "none"))
		theButton.place(relx=0.5, rely=0.7, anchor="center")
			
	def inheritance(self, combinedValueBase58):
		global filepathdestinationfolder
		global diceFunction
		global encryption_fingerprint
		global decoded_signing_fingerprint
		global timeDateString
		
		logged_in_user = 'Bob Smith'
		timeDateString = ''
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		now = datetime.now() # current date and time
		
		def tPassphrase():
			if Secret_passphrase.cget('show') == '':
				Secret_passphrase.configure(show='*')
			else:
				Secret_passphrase.configure(show='')
				
		def date():
			global timeDateString
			weekday = now.strftime("%A")
			dayofmonth = now.strftime("%d")
			month = now.strftime("%B")
			year = now.strftime("%Y")
			
			hour = now.strftime("%H")
			minute = now.strftime("%M")
			timeDateString = weekday + " the " + dayofmonth + " of " + month + ' ' + year + ' at ' + hour + ':' + minute
			dateLabel.config(text=timeDateString)
			
		def loadMessageFromFile():
			messagebox.showinfo("Information", "Connect the USB-device and then click \"OK\".")
			time.sleep(2)
			messagebox.showinfo("Information", "Select the file to load text from.")
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			try:
				f = open(filepathSourcefile, 'r', encoding='utf-8')
				file_content = f.read()
				f.close()
				self.textBox.delete('1.0', END)
				color_setting = 'none'
				completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:	
								color_setting = lines[1]
				except FileNotFoundError:
					logged_in_user = '<no settings file found>'
					
				if color_setting == 'Dark':
					self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
					self.textBox.config(insertbackground='white')
				else:
					self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
				self.textBox.place(relx=0.05, rely=0.43, height=170, width=860, anchor="nw")
				self.textBox.tag_config("center", justify="center")
				self.textBox.insert("1.0", file_content, "center")
				self.textBox.focus_set()
				self.textBox.focus_force()
			except OSError:
				messagebox.showinfo('Information', 'There was a problem reading the file.')
				
		def do_newInheritance():
			global filepathdestinationfolder
			global decoded_signing_fingerprint
			global encryption_fingerprint
			
			if last_will_checkbox.get() == "on":
				clicked_privateKey_to_Sign_with = clicked.get()
				decoded_signing_fingerprint = self.lookup_fingerprint(clicked_privateKey_to_Sign_with)
				
				# Construct a temp archive based on selections
				src = str(filepathdestinationfolder) + "/secure"
				dest = str(filepathdestinationfolder) + "/secure/temparchiveforinheritance0"
				
				if os.path.exists(dest) and os.path.isdir(dest):
					shutil.rmtree(dest)
					
				destination = shutil.copytree(src, dest)
				
				Passwordspath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/passwords.txt'
				Walletspath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/wallets/wallets.txt'
				ODWalletspath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/wallets/bitconwallets.csv' # Patch 0.4.1b
				SingleWalletspath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/wallets/paperwallets/paperwallets.csv' # Patch 0.4.1b
				Boltpath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/boltcards/boltcards.csv'
				Nostrpath = filepathdestinationfolder + '/secure/temparchiveforinheritance0/ID/Nostr_Primary_Nsec_Key.txt'
				Nostrpath2 = filepathdestinationfolder + '/secure/temparchiveforinheritance0/ID/Nostr_Primary_Npub_Key.txt'
				Nostrpath3 = filepathdestinationfolder + '/secure/temparchiveforinheritance0/ID/Nostr_Secondary_Nsec_Key.txt'
				Nostrpath4 = filepathdestinationfolder + '/secure/temparchiveforinheritance0/ID/Nostr_Secondary_Npub_Key.txt'
				
				if checkboxPasswords.get() == 'off' and os.path.exists(Passwordspath):
					c = open(Passwordspath, 'w')
					c.write(str("Passwords and accounts\n___________________________________\n\n   User/account: \n\n   Password: \n\n   Comment: \n\n___________________________________\n"))
					c.close()
					
				if checkboxWallets.get() == 'off' and os.path.exists(Walletspath):  # Patch 0.4.1b
					c = open(Walletspath, 'w')
					c.write(str("Wallets\n___________________________________\n\nName: \n\n   Seed words/key: \n\n   Comment: \n\n___________________________________\n"))
					c.close()
					
				if checkboxODWallets.get() == 'off' and os.path.exists(ODWalletspath):  # Patch 0.4.1b
					with open(ODWalletspath, 'w', newline='') as file:
						writer = csv.writer(file)
						
				if checkboxSingleWallets.get() == 'off' and os.path.exists(SingleWalletspath):  # Patch 0.4.1b
					with open(SingleWalletspath, 'w', newline='') as file:
						writer = csv.writer(file)					
				
				if checkboxBolt.get() == 'off' and os.path.exists(Boltpath):  # Patch 0.4.1b
					with open(Boltpath, 'w', newline='') as file:
						writer = csv.writer(file)
						
				if checkboxNostr.get() == 'off':
					if os.path.exists(Nostrpath):
						os.remove(Nostrpath)
					if os.path.exists(Nostrpath2):
						 os.remove(Nostrpath2)
					if os.path.exists(Nostrpath3):
						 os.remove(Nostrpath3)
					if os.path.exists(Nostrpath4):
						 os.remove(Nostrpath4)
						
				# Write the inheritance message to file to the temp secure archive
				pathInheritanceMsg = str(filepathdestinationfolder) + "/secure/temparchiveforinheritance0/inheritanceMessage.txt"
				inp = self.textBox.get('1.0', 'end')
				if inp == '':
					inp = '<No message>'
				f = open(pathInheritanceMsg, 'w')
				f.write(inp)
				f.close()
				
				pathtobackg = "/home/user1/images/black.png"
		
				backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
				Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
				Label_backg.place(x=2, y=2, anchor="nw")
				
				my_font = ctk.CTkFont(family="Helvetica", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
				LLabel3 = ctk.CTkLabel(my_Frame, text="Creating inheritance package. Please wait......... ", text_color="white", fg_color="black", font=my_font)
				LLabel3.place(relx=0.5, rely=0.5, anchor="center")
				self.update()
				time.sleep(1)
		
				# Encrypt the temp archive and write to USB (also write the key used for encryption to USB)
				do_encrypt_inheritance_archive()
				
				clicked_privateKey_to_Sign_with = clicked.get()
				decoded_signing_fingerprint = self.lookup_fingerprint(clicked_privateKey_to_Sign_with)
			
				completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
				f2 = open(completeName, 'a')
				
				f2.write("\nInheritance package: " + Real_name.get() + "\n\n   Signed with: " + decoded_signing_fingerprint + "\n\n   Password: " + Secret_passphrase.get() + "\n\n   Comment: \n___________________________________\n")
				
				f2.close()	
				os.system("sync")
				self.add_history("Created inheritance package for key: " + encryption_fingerprint + ", and signed it with key: " + decoded_signing_fingerprint + ".")
			else:
				tk.messagebox.showinfo('Information', 'You have to check the tick-box \"this is my last will and testamony\" to declare that you want to create a inheritance package.')
				self.create_Bitcoinmeny()
				
		def limitSizeName_text(*args):
			value = Real_name.get()
			if len(value) > 42: Real_name.set(value[:42])
		
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
		
		def do_new_Bitcoinwallet(TimestampAddress, totalHash, outputfilesname, filename):
		
			path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
			
			now = datetime.now()
			dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
			dt_string_short = now.strftime("%Y-%m-%d")
					
			new_paperwallet = [
								"Timestamp",
								dt_string_short,
								TimestampAddress,
								totalHash,
								filename,
								outputfilesname,
								"Not payed"]

			with open(path_to_wallets, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_paperwallet)
								
		def do_encrypt_inheritance_archive():
			global filepathdestinationfolder
			global encryption_fingerprint
			#global decoded_signing_fingerprint

			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			clicked_privateKey_to_Sign_with = clicked.get()
			decoded_signing_fingerprint = self.lookup_fingerprint(clicked_privateKey_to_Sign_with)
				
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the encrypted inheritance package.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			# Create a new key just for this inheritance package
			input_data = gpg.gen_key_input(key_type='rsa', name_real=Real_name.get(), expire_date='0', key_length='4096', name_email='Inheritance', passphrase=Secret_passphrase.get())
			key = gpg.gen_key(input_data)
			encryption_fingerprint = key.fingerprint
			Alias_name = Real_name.get()
			
			if Alias_name == '':
				Alias_name = logged_in_user
				
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for inheritance file (the file types will be added automatically):")
			if USER_INP == '':
				USER_INP = 'H_' + encryption_fingerprint
				
			# Add a inheritance icon as avatar
			pathtopicture = filepathdestinationfolder + "/images/Rose_ICON.jpg"
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/temparchiveforinheritance0/" + encryption_fingerprint + '.png'
			shutil.copy(pathtopicture, pathtopicturearchivelocation)
			
			# Add an Alias name in the temp directory
			file_ = filepathdestinationfolder + "/secure/temparchiveforinheritance0/externalAliases_localcopy.csv"	
			new_Alias = [encryption_fingerprint, Alias_name, encryption_fingerprint + '.png']
			if os.path.isfile(file_):
				f = open(file_, 'a')
				writer = csv.writer(f)
				writer.writerow(new_Alias)
				f.close()
							
			full_path = str(filepathdestinationfolder) + "/secure/temparchiveforinheritance0/"
			
			# Make a tar file
			compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
			
			# Encrypt the tarfile 
			encrypted_data = gpg.encrypt_file(compressed_file, encryption_fingerprint, always_trust=True) 
			
			full_path = filepathdestinationfolder + "/secure/temparchiveforinheritance0"
		
			# Remove the tar-file
			cmd = 'shred -zu -n7 ' + compressed_file
			os.system(cmd)
			
			# Write the encrypted file to USB
			out_archive = outputdir + "/" + USER_INP + '_securefolder.tar.gz.gpg'
			compressedoutfile = open(out_archive, 'w')
			compressedoutfile.write(str(encrypted_data))
			compressedoutfile.close()
			os.system("sync")
			
			# Sign the secure folder file
			sigfilepath = out_archive + '.sig'
			
			with open(out_archive, 'rb') as f: 
				try:
					data_ = gpg.sign_file(f, keyid=decoded_signing_fingerprint, detach=True)
					f2 = open(sigfilepath, 'w')
					f2.write(str(data_))
					f2.close()
				except ValueError as ve:
					tk.messagebox.showinfo('Information', 'Something went wrong in signing!')
					
			# Write the encryption key used to USB
			privatekeypath = outputdir + "/" + USER_INP + '_privateKey' + ".gpg"
			ascii_armored_private_key = gpg.export_keys(encryption_fingerprint, True, expect_passphrase=False)
			f2 = open(privatekeypath, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			
			if os.stat(privatekeypath).st_size < 100:
				tk.messagebox.showinfo('Information', "That didn't work. Exporting the private key to the USB failed\nWithout this key the inheritance archive can never be opened.\nPlease try again!")
				self.create_Bitcoinmeny()
			else:
				full_path = filepathdestinationfolder + "/secure/temparchiveforinheritance0"
			
				# Remove the temp directory (to keep the size of the actual secure archive small in size)
				cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
				os.system(cmd)
				cmd = 'rm -r ' +  full_path
				os.system(cmd)
				
				if os.stat(out_archive).st_size < 1000:
					tk.messagebox.showinfo('Information', "That didn't work. Encryption failed.")
					self.create_Bitcoinmeny()
				
				if encrypted_data.ok:
					messagebox.showinfo('Information', 'Inheritance files has been encrypted and stored at '+ outputdir)
				else:
					messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")
				timestamp_sig_and_archive(sigfilepath, out_archive)	
			# Remove the newly created key (that was just for this inheritance package)
			try:
				key = gpg.delete_keys(encryption_fingerprint, True, expect_passphrase=False) 
			except ValueError as ve:
				messagebox.showinfo('Information', 'Something went wrong with deleting the inheritance key from local keychain.')
			
		def create_helptext():
			try:
				f = open("/home/user1/help/inheritanceHelp.txt", "r")
				file_content = f.read()
				f.close()
				my_text = ctk.CTkTextbox(my_Frame, width=1196, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 22), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', file_content)
			except OSError:
				my_text = ctk.CTkTextbox(my_Frame, width=1196, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 24), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
			my_text.configure(state="disabled")
			my_text.place(relx=0.5, rely=0.5, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=100, height=26, font=my_font, command=partial(self.inheritance, "none"))
			backButton.place(relx=0.93, rely=0.96, anchor="center")	
		
		def timestamp_sig_and_archive(sigfilepath, out_archive):
			# Create a timestamp Bitcoin address by hashing a combining of hashes from both signature file and document file
			# After sending sats to this new address it is prof that BOTH the signature and the signed data existed at the time the transaction was included in a block on the Bitcoin blockchain 
			
			# Make hash for document
			hashForDocument = sha256Hex(out_archive)
			
			# Make hash for signature
			hashForSignature = sha256Hex(sigfilepath)
			
			# Make combined hash for combination of document and signature hashes
			totalHash = hashForSignature + hashForDocument
			
			# Hash a Bitcoin address from the combined hash
			addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
			
			signatureAddress = addr.address
			
			# Generate a Bitcoin transaction including amount of 1100 sats to the newly hashed address
			transaction_payload = "bitcoin:" + signatureAddress + '?amount=0.00001100'
			
			# Clear screen and re-fill
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
			Label2 = ctk.CTkLabel(my_Frame, text="The signature and inheritance files has together created below Bitcoin QR-address.", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.16, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
			Label3 = ctk.CTkLabel(my_Frame, text="Scan the QR-code and transfer Bitcoin to it, thereby making a time proof on the Bitcoin blockchain.", text_color="white", fg_color="black", font=my_font)
			Label3.place(relx=0.5, rely=0.25, anchor="center")
			
			# Create a QR-code for the transaction
			pathtosignature = qrcode.make(transaction_payload)
			resize_pathtosignature = pathtosignature.resize((280, 280))
			pathtotransactionsignature = str(filepathdestinationfolder) + "/secure/transactionsignature.png"
			resize_pathtosignature.save(pathtotransactionsignature)
			loadimg = ctk.CTkImage(light_image=Image.open(pathtotransactionsignature), dark_image=Image.open(pathtotransactionsignature), size=(280, 280))
			Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
			Labelpublicimg.place(relx=0.72, rely=0.56, anchor="center")
			
			# Add the signatures transaction in the paper wallets CSV-file
			filename_list = out_archive.split("/")
			filename_ = str(filename_list[-1])
			sigfilename = filename_ + '.sig'
			
			do_new_Bitcoinwallet(signatureAddress, totalHash, sigfilename, filename_)
			
			my_font = ctk.CTkFont(family="Arial", size=36, weight="bold", slant="roman", underline=False, overstrike=False)
			pubLabel = ctk.CTkLabel(my_Frame, text="Success!", text_color="light green", font=my_font, fg_color="black")
			pubLabel.place(relx=0.35, rely=0.46, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=34, weight="bold", slant="roman", underline=False, overstrike=False)
			pubLabel = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
			pubLabel.place(relx=0.35, rely=0.55, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
			outLabel = ctk.CTkLabel(my_Frame, text="Output file:", text_color="white", font=my_font, fg_color="black")
			outLabel.place(relx=0.35, rely=0.64, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			pubLabel = ctk.CTkLabel(my_Frame, text=sigfilename, text_color="white", font=my_font, fg_color="black")
			pubLabel.place(relx=0.35, rely=0.7, anchor="center")
			scanLabel = ctk.CTkLabel(my_Frame, text="Pay address *:", text_color="white", fg_color="black", font=my_font)
			scanLabel.place(relx=0.72, rely=0.31, anchor="center")
			
			detailsButton = ctk.CTkButton(my_Frame, text="Details", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.do_edit_Bitcoinwallets, signatureAddress))
			detailsButton.place(relx=0.72, rely=0.82, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
			Label11 = ctk.CTkLabel(my_Frame, text="* Sending bitcoin to the stated address records the event (hashed proof) on the Bitcoin Blockchain.", text_color="white", fg_color="black", font=my_font)
			Label11.place(relx=0.05, rely=0.88, anchor="w")
			backButton = ctk.CTkButton(my_Frame, text="Done", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
			backButton.place(relx=0.5, rely=0.94, anchor="center")
								
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
			
		Label1 = ctk.CTkLabel(my_Frame, text="Inheritance", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.03, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="italic", underline=False, overstrike=False)
		
		last_will_var = ctk.StringVar(value="off")
		last_will_checkbox = ctk.CTkCheckBox(my_Frame, text="I hereby declare that this is my last will and testamony.", font=my_font, variable=last_will_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		last_will_checkbox.place(relx=0.05, rely=0.1, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Creation date:", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.22, rely=0.16, anchor="e")
		
		dateLabel = tk.Label(my_Frame, text="", font=("Helvetica", 16), fg="white", bg="black")
		
		date()
		
		dateLabel.place(relx=0.23, rely=0.16, anchor="w")
		
		completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						logged_in_user = lines[0]
		except FileNotFoundError:
			messagebox.showinfo("Information", "No settings file found.")
		
		users_name_var = ctk.StringVar(value=logged_in_user)
		users_name_var.trace('w', limitSizeName_text)
				
		Label22 = ctk.CTkLabel(my_Frame, text="Full name *:", font=my_font, text_color="white", fg_color="black")
		Label22.place(relx=0.22, rely=0.21, anchor="e")
		Real_name = ctk.CTkEntry(my_Frame, placeholder_text=logged_in_user, textvariable=users_name_var,font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		Real_name.place(relx=0.23, rely=0.21, anchor="w")
		iiLabel = ctk.CTkLabel(my_Frame, text="* Dont use special characters.", font=my_font, text_color="white", fg_color="black")
		iiLabel.place(relx=0.52, rely=0.21, anchor="w")
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		private_keys = gpg.list_keys(True)
		
		List_fingerprints = []
		private_fingerprints_and_aliases = []
		
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
							
		List_Sex = ['Male', 'Female']
		
		clicked = StringVar()
		clicked2 = StringVar()
		
		private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
		clicked.set(private_fingerprints_and_aliases[0])
		clicked2.set(private_fingerprints_and_aliases[0])
		
		privatekeysavailable = True
		
		if privatekeysavailable == True:
			Label3 = ctk.CTkLabel(my_Frame, text="Select key to sign with:", font=my_font, text_color="white", fg_color="black")
			Label3.place(relx=0.22, rely=0.27, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.23, rely=0.27, anchor="w")
			Label6 = ctk.CTkLabel(my_Frame, text="Beneficiary password**:", font=my_font, text_color="white", fg_color="black")
			Label6.place(relx=0.22, rely=0.33, anchor="e")
			if combinedValueBase58 != "none":
				strong_password_var = ctk.StringVar(value=combinedValueBase58)
				Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text=combinedValueBase58, textvariable=strong_password_var, show='', font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
				Secret_passphrase.place(relx=0.23, rely=0.33, anchor="w")
			else:
				Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text="*********************", show='*', font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
				Secret_passphrase.place(relx=0.23, rely=0.33, anchor="w")
			tButton = ctk.CTkButton(my_Frame, text="Show/hide", font=my_font, text_color="black", fg_color="pink", border_width=2, border_color="white", command=tPassphrase)
			tButton.place(relx=0.57, rely=0.33, anchor="center")
			diceFunction = "Inheritance"
			doButton = ctk.CTkButton(my_Frame, text="Create a strong password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.dicePassword, "1"))
			doButton.place(relx=0.64, rely=0.33, anchor="w")
			iiiLabel = ctk.CTkLabel(my_Frame, text="** Use a unique password, and not your regular one..", font=my_font, text_color="white", fg_color="black")
			iiiLabel.place(relx=0.05, rely=0.96, anchor="w")
			Label5 = ctk.CTkLabel(my_Frame, text="Message for beneficiary (will be visible on on main page after decryption):", font=my_font, text_color="white", fg_color="black")
			Label5.place(relx=0.05, rely=0.39, anchor="w")
			loadButton11 = ctk.CTkButton(my_Frame, text="Load from textfile", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=loadMessageFromFile)
			loadButton11.place(relx=0.69, rely=0.72, anchor="center")
			
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
			
			if color_setting == 'Dark':					
				self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
				self.textBox.config(insertbackground='white')
			else:
				self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
			
			self.textBox.place(relx=0.05, rely=0.43, height=170, width=860, anchor="nw")
			self.textBox.tag_config("center", justify="center")
			self.textBox.insert("1.0", "Written on " + timeDateString + "\nThis is my last will and testamony:\n", "center")
				
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="italic", underline=False, overstrike=False)
			Label6 = ctk.CTkLabel(my_Frame, text="Include the following in the inheritance package:", font=my_font, text_color="white", fg_color="black")
			Label6.place(relx=0.05, rely=0.73, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			checkboxPasswords_var = ctk.StringVar(value="off")
			checkboxPasswords = ctk.CTkCheckBox(my_Frame, text="Passwords file", font=my_font, variable=checkboxPasswords_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxPasswords.place(relx=0.05, rely=0.79, anchor="w")
			
			checkboxWallets_var = ctk.StringVar(value="off")
			checkboxWallets = ctk.CTkCheckBox(my_Frame, text="Wallets file", font=my_font, variable=checkboxWallets_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxWallets.place(relx=0.23, rely=0.79, anchor="w")
			
			checkboxODWallets_var = ctk.StringVar(value="off")
			checkboxODWallets = ctk.CTkCheckBox(my_Frame, text="My Bitcoin wallets", font=my_font, variable=checkboxODWallets_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxODWallets.place(relx=0.4, rely=0.79, anchor="w")
			
			completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
			Counting = 0
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						Counting += 1
						walletname = lines[0]
					if Counting == 1:
						Label7 = ctk.CTkLabel(my_Frame, text="(" + str(Counting) + "  Bitcoin wallet available)", font=my_font, text_color="white", fg_color="black")
						Label7.place(relx=0.58, rely=0.79, anchor="w")
					else:
						Label8 = ctk.CTkLabel(my_Frame, text="(" +str(Counting) + "  Bitcoin wallets available)", font=my_font, text_color="white", fg_color="black")
						Label8.place(relx=0.58, rely=0.79, anchor="w")
			except FileNotFoundError:
				Label9 = ctk.CTkLabel(my_Frame, text="(No Bitcoin wallet available)", font=my_font, text_color="white", fg_color="black")
				Label9.place(relx=0.58, rely=0.79, anchor="w")
			
			checkboxSingleWallets_var = ctk.StringVar(value="off")
			checkboxSingleWallets = ctk.CTkCheckBox(my_Frame, text="Single Address BTC wallets", font=my_font, variable=checkboxSingleWallets_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxSingleWallets.place(relx=0.05, rely=0.85, anchor="w")
			
			checkboxBolt_var = ctk.StringVar(value="off")
			checkboxBolt = ctk.CTkCheckBox(my_Frame, text="Bolt card data", font=my_font, variable=checkboxBolt_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxBolt.place(relx=0.32, rely=0.85, anchor="w")
			
			checkboxNostr_var = ctk.StringVar(value="off")
			checkboxNostr = ctk.CTkCheckBox(my_Frame, text="Nostr keys", font=my_font, variable=checkboxNostr_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkboxNostr.place(relx=0.48, rely=0.85, anchor="w")
			
			Label10 = ctk.CTkLabel(my_Frame, text="Note that all private files/folders will also be included.", font=my_font, text_color="white", fg_color="black")
			Label10.place(relx=0.05, rely=0.91, anchor="w")
			
			doButton = ctk.CTkButton(my_Frame, text="Create inheritance package", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=do_newInheritance)
			doButton.place(relx=0.61, rely=0.94, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=22, font=my_font, command=create_helptext)
			Buttonmoreinfo.place(relx=0.93, rely=0.96, anchor="center")
	
	def createPassword(self, combinedValueBase58):
		global filepathdestinationfolder
		global diceFunction
		global timeDateString
		
		password_name = 'TBD'
		timeDateString = ''
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		now = datetime.now() # current date and time
		
		def date():
			global timeDateString
			dayofmonth = now.strftime("%d")
			month = now.strftime("%B")
			year = now.strftime("%Y")
			
			hour = now.strftime("%H")
			minute = now.strftime("%M")
			timeDateString = dayofmonth + " of " + month + ' ' + year + ' at ' + hour + ':' + minute
			return timeDateString
			
		passwordDate = date()
		
		def tPassphrase():
			if Secret_passphrase.cget('show') == '':
				Secret_passphrase.configure(show='*')
			else:
				Secret_passphrase.configure(show='')
				
		def do_newPassword():
			global filepathdestinationfolder
				
			completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
			f2 = open(completeName, 'a')
			
			f2.write("\nStrong password: " + Real_name.get() + "\n\n   Date created: " + passwordDate + "\n\n   Password: " + Secret_passphrase.get() + "\n\n   Comment: " + comment_entry.get() + "\n___________________________________\n")
			
			f2.close()	
			self.add_history("Created strong password: " + Real_name.get() + ".")
			self.create_Bitcoinmeny()
				
		def limitSizeName_text(*args):
			value = Real_name.get()
			if len(value) > 42: Real_name.set(value[:42])
								
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
			
		Label1 = ctk.CTkLabel(my_Frame, text="Strong password", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.05, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="italic", underline=False, overstrike=False)
		Label22 = ctk.CTkLabel(my_Frame, text="Create a strong password with your own entropy/random data. Or, a mix of random characters and words.", font=my_font, text_color="white", fg_color="black")
		Label22.place(relx=0.05, rely=0.11, anchor="w")
		completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
		
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						password_name = lines[0]
		except FileNotFoundError:
			messagebox.showinfo("Information", "No settings file found.")
		
		password_name_var = ctk.StringVar(value=password_name)
		password_name_var.trace('w', limitSizeName_text)
		
		diceFunction = "strongPassword"
		
		doButton = ctk.CTkButton(my_Frame, text="CLICK HERE! To Start creating a password!", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.dicePassword, "1"))
		doButton.place(relx=0.5, rely=0.21, anchor="center")
		
		Label22 = ctk.CTkLabel(my_Frame, text="Description:", font=my_font, text_color="white", fg_color="black")
		Label22.place(relx=0.37, rely=0.33, anchor="e")
		Real_name = ctk.CTkEntry(my_Frame, placeholder_text=password_name, textvariable=password_name_var,font=my_font, width=410, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		Real_name.place(relx=0.38, rely=0.33, anchor="w")
		
		Label6 = ctk.CTkLabel(my_Frame, text="View and edit password:", font=my_font, text_color="white", fg_color="black")
		Label6.place(relx=0.37, rely=0.39, anchor="e")
		if combinedValueBase58 != "none":
			strong_password_var = ctk.StringVar(value=combinedValueBase58)
			Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text=combinedValueBase58, textvariable=strong_password_var, show='', font=my_font, width=410, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
			Secret_passphrase.place(relx=0.4, rely=0.39, anchor="w")
		else:
			Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text="*********************", show='*', font=my_font, width=410, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
			Secret_passphrase.place(relx=0.38, rely=0.39, anchor="w")
		tButton = ctk.CTkButton(my_Frame, text="Show/hide", font=my_font, text_color="black", fg_color="pink", border_width=2, border_color="white", command=tPassphrase)
		tButton.place(relx=0.79, rely=0.39, anchor="center")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Comment:", font=my_font, text_color="white", fg_color="black")
		Label4.place(relx=0.37, rely=0.53, anchor="e")
		comment_entry = ctk.CTkEntry(my_Frame, placeholder_text='', font=my_font, width=410, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		comment_entry.place(relx=0.38, rely=0.53, anchor="w")
		
		copy_button = ctk.CTkButton(my_Frame, text="Copy password to clipboard", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, Secret_passphrase.get()))
		copy_button.place(relx=0.5, rely=0.6, anchor="center")
							
		doButton = ctk.CTkButton(my_Frame, text="Save the password in the Secure archive", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=do_newPassword)
		doButton.place(relx=0.5, rely=0.72, anchor="center")
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
		backButton.place(relx=0.5, rely=0.96, anchor="center")
							
	def addCard_with_QR(self):
		global filepathdestinationfolder
		global msg, timeDateString
		
		now = datetime.now() # current date and time
		msg = ''
		timeDateString = ''
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		def date():
			global timeDateString
			dayofmonth = now.strftime("%d")
			month = now.strftime("%B")
			year = now.strftime("%Y")
			
			hour = now.strftime("%H")
			minute = now.strftime("%M")
			second = now.strftime("%S")
			timeDateString = dayofmonth + '-' + month + '-' + year + ' ' + hour + ':' + minute + ':' + second

		
		def do_addCard_with_QR():
			global bolt_uid, timeDateString
			msg = ' '
			bolt = False
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			completeNameQRfile = "/home/user1/secure/QRmessagefile.txt"
			
			if os.path.isfile(completeNameQRfile):
				os.remove(completeNameQRfile)
				
			subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRmessage.py'], shell=True)
		
			try:
				f = open(completeNameQRfile, "r")
				msg = f.read()
				f.close()
				#msg = msg.replace('\n', '')
			except OSError:
				tk.messagebox.showinfo('Information', 'There was a problem reading the Boltcard data from QR-code.')
			
			# Check that QR-was Boltcard data
			if msg != ' ':
				try:
					lines = msg.splitlines()
				except IOError:
					messagebox.showinfo("Information", "There was a problem with the text file!")
				
				if len(lines) == 8:
					bolt = True
					# Get card details from QR. 
					USER_INP = simpledialog.askstring(title="Name required.", prompt="Name for the new Bolt card (max 28 charachters):")
					
					if USER_INP == "" or USER_INP == " ":
						USER_INP = timeDateString
					
					USER_INP_tr = USER_INP[:28] if len(USER_INP) > 28 else USER_INP
					
					USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bolt card:")
					
					if USER_INP2 == "" or USER_INP2 == " ":
						USER_INP2 = "-"
						
					USER_INP2_tr = USER_INP2[:42] if len(USER_INP2) > 42 else USER_INP2
					
					completeName = filepathdestinationfolder + "/secure/boltcards/boltcards.csv"
					new_boltcard = [USER_INP_tr, USER_INP2_tr, timeDateString, lines[0],lines[1],lines[2],lines[3], lines[4], lines[5],lines[6],lines[7]]
					
					f = open(completeName, 'a')
					writer = csv.writer(f)
					writer.writerow(new_boltcard)
					f.close()
					
					self.add_history("Added Boltcard: " + USER_INP_tr + " (" + USER_INP2_tr + ")")
				else:
					messagebox.showinfo("Information", "There was a problem reading the data! \nMake sure there is exactly eight lines with the required data in the file?")
					
				if bolt:
					my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
					uuidLabel = ctk.CTkLabel(my_Frame, text='Boltcard has been added:', text_color="white", font=my_font, fg_color="black")
					uuidLabel.place(relx=0.5, rely=0.18, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=30, slant="roman", weight="bold", underline=False, overstrike=False)
					uuidLabel2 = ctk.CTkLabel(my_Frame, text=USER_INP_tr, text_color="white", font=my_font, fg_color="black")
					uuidLabel2.place(relx=0.5, rely=0.28, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
					backButton = ctk.CTkButton(my_Frame, text="Done", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Boltcardmeny)
					backButton.place(relx=0.5, rely=0.59, anchor="center")
			self.create_Boltcardmeny()
			
		date()	
		# Instructions to read URI from Bolt card with Smartcard reader
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)

		Label = ctk.CTkLabel(my_Frame, text="Add a Boltcard using a QR-code containing all the card data", text_color="white", font=my_font, fg_color="black")
		Label.place(relx=0.5, rely=0.2, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)

		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		Label3 = ctk.CTkLabel(my_Frame, text='After clicking the \"Start camera\"- button, hold the QR-code infront of the camera.', text_color="white", font=my_font, fg_color="black")
		Label3.place(relx=0.5, rely=0.34, anchor="center")
		Label4 = ctk.CTkLabel(my_Frame, text='Camera can take several seconds to start, be patient....', text_color="white", font=my_font, fg_color="black")
		Label4.place(relx=0.5, rely=0.4, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		startButton = ctk.CTkButton(my_Frame, text="Start camera", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=do_addCard_with_QR)
		startButton.place(relx=0.5, rely=0.6, anchor="center")
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Boltcardmeny)
		backButton.place(relx=0.5, rely=0.9, anchor="center")
	
	def encrypt_and_sign_UID(self, UID):
		global clicked_publicKey
		global clicked_privateKey
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_encrypt_and_sign_UID():
			global clicked_publicKey
			global clicked_privateKey
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			decoded_publicfingerprint = self.lookup_fingerprint(clicked_publicKey)
			
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			encsigfilename = 'Boltcard_UID.asc'
			completeName = outputdir  + '/' +  encsigfilename
			# Encrypt the file
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			encrypted_data = gpg.encrypt(UID, clicked_publicKey, sign=clicked_privateKey, always_trust=True) 
			
			# Write the encrypted file if encryption and signing went OK
			if encrypted_data.ok:
				try:
					with open(completeName, 'w') as f:
						f.write(str(encrypted_data))
						new_record = [clicked_privateKey, "Encrypted and signed Boltcard UID.", "File:" + encsigfilename]
						self.add_record(new_record)
						messagebox.showinfo('Information', 'File with Boltcard UID has been signed, encrypted and stored as:\n\n'+ encsigfilename)
				except FileNotFoundError:
					messagebox.showinfo("Warning!", "Could not write to file!")
					return False
			else:
				messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

			self.create_Boltcardmeny()
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Encrypt and sign a UID (serial number) from a Boltcard.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.07, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Encrypt with a recipients public key and sign with a selected private key.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.14, anchor="w")
		Label3 = ctk.CTkLabel(my_Frame, text="You need to have the LN Hub operators public key imported to your local keychain before proceeding.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.22, anchor="w")
		Label4 = ctk.CTkLabel(my_Frame, text="The LN Hub operator has has to have your public key so they verify and send back an encrypt Boltcard file.", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.05, rely=0.28, anchor="w")
				
		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
	
		List_fingerprints = []
		List_publicfingerprints = []
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False
		publickeysavailable = False
		
		# Dont display the private key that is only intended for Offline device encryption/decryption
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
					
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i2['fingerprint'])
			
		if List_publicfingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		
		if not List_fingerprints:	
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.5, anchor="center")
		else:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign message with (FROM):", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.45, rely=0.4, anchor="e")

			drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop1.config(width=45)
			drop1.place(relx=0.46, rely=0.4, anchor="w")
						
		if publickeysavailable == True:
			Label11 = ctk.CTkLabel(my_Frame, text="Select a public key to encrypt the file with (TO):", font=my_font, text_color="white", fg_color="black")
			Label11.place(relx=0.45, rely=0.46, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.46, rely=0.46, anchor="w")

			Button2 = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_UID)
			Button2.place(relx=0.83, rely=0.54, anchor="e")
		else:
			Button3 = ctk.CTkButton(my_Frame, text="There are no public keys on the keychain. Create one now?", font=my_font, text_color="white", fg_color="green", border_width=2, border_color="white", command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.55, anchor="center")
	
	def resetcard(self, cardidentification):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
		updatedcompleteName = str(filepathdestinationfolder) + "/secure/boltcards/updatedboltcards.csv"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if lines[2] == cardidentification:
							# Generate QR-codes for Public address and WIF-address and read them to display on screen
							reset_key = qrcode.make(lines[4], version=1)
							
							resize_reset_key = reset_key.resize((300, 300))
							pathtoresetkey = str(filepathdestinationfolder) + "/secure/boltcards/reset.png"
							
							resize_reset_key.save(pathtoresetkey)
							
							resetimg = ctk.CTkImage(light_image=Image.open(pathtoresetkey), dark_image=Image.open(pathtoresetkey), size=(320, 320))

							my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
		
							pubLabel = ctk.CTkLabel(my_Frame, text="Reset card using smartphone app *", text_color="white", font=my_font, fg_color="black")
							pubLabel.place(relx=0.5, rely=0.07, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
							pubLabel2 = ctk.CTkLabel(my_Frame, text="(* Bolt Card NFC Card Creator- app from App/Play-store)", text_color="white", font=my_font, fg_color="black")
							pubLabel2.place(relx=0.5, rely=0.12, anchor="center")
							Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = resetimg)
							Labelpublicimg.place(relx=0.5, rely=0.45, anchor="center")							
		except FileNotFoundError:
			messagebox.showinfo("Information", "No Bolt cards file found.")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="brown", border_width=2, border_color="white", width=120, height=32, font=my_font, command=partial(self.showcard, cardidentification))
		backButton.place(relx=0.5, rely=0.8, anchor="center")
	
	def updatecard_Strong(self, strongPassword):
		global filepathdestinationfolder, diceFunction
		global created, program_keys, program_link
		global LNURL, program_keys, program_link, url_link, account_name
		global g_Updated_name, g_Updated_description, g_cardidentification, g_LNURL
		global g_maxLimit, g_maxDailyLimit, g_account_name
		
		def updatecard_strong_pre():
			global g_Updated_name, g_Updated_description, g_cardidentification, g_LNURL
			global g_maxLimit, g_maxDailyLimit, g_account_name
			g_Updated_name = nameEntry.get()
			g_Updated_description = descriptionEntry.get()
			g_cardidentification = cardidentification
			g_LNURL = LNURLEntry.get()
			g_maxLimit = int(maxLimitEntry.get())
			g_maxDailyLimit = int(maxDailyLimitEntry.get())
			g_account_name = account_name
			self.dicePassword("1")
			
		def limitSizeName(*args):
			value = boltcard_name_var.get()
			if len(value) > 28: boltcard_name_var.set(value[:28])
		
		def limitSizeDescription(*args):
			value = boltcard_description_var.get()
			if len(value) > 42: boltcard_description_var.set(value[:42])
		
		def limitSizePassword(*args):
			value = boltcard_password_var.get()
			if len(value) > 42: boltcard_password_var.set(value[:42])
		
		def limitSizeLNURL(*args):
			value = boltcard_LNURL_var.get()
			if len(value) > 200: boltcard_LNURL_var.set(value[:200])
						
		def do_updatecard():
			global filepathdestinationfolder, LNURL, program_keys, program_link, url_link, account_name
			Updated_name = nameEntry.get()
			Updated_description = descriptionEntry.get()
			Updated_LNURL = LNURLEntry.get()
			maxLimit = int(maxLimitEntry.get())
			maxDailyLimit = int(maxDailyLimitEntry.get())
			Updated_password = passwordEntry.get()
			
			Updated_Boltcard_data = [
								Updated_name,
								Updated_description,
								cardidentification,
								Updated_LNURL,
								program_keys,
								program_link,
								maxLimit,
								maxDailyLimit,
								url_link,
								account_name,
								Updated_password]
								
			completeName = filepathdestinationfolder + "/secure/boltcards/boltcards.csv"
			updatedcompleteName = str(filepathdestinationfolder) + "/secure/boltcards/updatedBoltcards.csv"
			with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
				csvreader = csv.reader(source)
				csvwriter = csv.writer(result)
				for row in csv.reader(source):
					try:
						if row[2] == cardidentification:
							csvwriter.writerow(Updated_Boltcard_data)
						else:
							csvwriter.writerow(row)						
					except:
						continue
			shutil.copy(updatedcompleteName, completeName)
			os.remove(updatedcompleteName)	
			self.showcard(cardidentification)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		diceFunction = "updateBoltcard"
		cardidentification = g_cardidentification
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
		completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if lines[2] == cardidentification:
							Updated_name = g_Updated_name
							Updated_description = g_Updated_description
							Updated_LNURL = g_LNURL
							program_keys = lines[4]
							program_link = lines[5]
							maxLimit = g_maxLimit
							maxDailyLimit = g_maxDailyLimit
							url_link = lines[8]
							account_name = g_account_name
							
							pubLabel = ctk.CTkLabel(my_Frame, text="Update Boltcard details:", text_color="white", font=my_font, fg_color="black")
							pubLabel.place(relx=0.5, rely=0.09, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							nameheadLabel = ctk.CTkLabel(my_Frame, text="Name:", text_color="white", font=my_font, fg_color="black")
							nameheadLabel.place(relx=0.34, rely=0.18, anchor="e")
							
							boltcard_name_var = ctk.StringVar(value=Updated_name)
							boltcard_name_var.trace('w', limitSizeName)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)				
							nameEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_name, textvariable=boltcard_name_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							nameEntry.place(relx=0.35, rely=0.18, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.26, anchor="e")
							
							boltcard_description_var = ctk.StringVar(value=Updated_description)
							boltcard_description_var.trace('w', limitSizeDescription)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
							descriptionEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_description, textvariable=boltcard_description_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							descriptionEntry.place(relx=0.35, rely=0.26, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="LNURL:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.34, anchor="e")
							
							boltcard_LNURL_var = ctk.StringVar(value=Updated_LNURL)
							boltcard_LNURL_var.trace('w', limitSizeLNURL)
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)	
							LNURLEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_LNURL, textvariable=boltcard_LNURL_var, width=700, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							LNURLEntry.place(relx=0.35, rely=0.34, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							maxLimitLabel = ctk.CTkLabel(my_Frame, text="Max limit:", text_color="white", font=my_font, fg_color="black")
							maxLimitLabel.place(relx=0.34, rely=0.42, anchor="e")
							
							maxLimit_var = ctk.IntVar(value=maxLimit)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)					
							maxLimitEntry = ctk.CTkEntry(my_Frame, placeholder_text=maxLimit, textvariable=maxLimit_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							maxLimitEntry.place(relx=0.35, rely=0.42, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							maxDailyLimitLabel = ctk.CTkLabel(my_Frame, text="Max daily limit:", text_color="white", font=my_font, fg_color="black")
							maxDailyLimitLabel.place(relx=0.34, rely=0.5, anchor="e")
							
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)								
							
							maxDailyLimit_var = ctk.IntVar(value=maxDailyLimit)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)				
							maxDailyLimitEntry = ctk.CTkEntry(my_Frame, placeholder_text=maxDailyLimit, textvariable=maxDailyLimit_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							maxDailyLimitEntry.place(relx=0.35, rely=0.5, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Password:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.58, anchor="e")
							
							boltcard_password_var = ctk.StringVar(value=strongPassword)
							boltcard_password_var.trace('w', limitSizePassword)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
							passwordEntry = ctk.CTkEntry(my_Frame, placeholder_text=strongPassword, textvariable=boltcard_password_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							passwordEntry.place(relx=0.35, rely=0.58, anchor="w")
							doButton = ctk.CTkButton(my_Frame, text="Create a strong password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.dicePassword, "1"))
							doButton.place(relx=0.69, rely=0.58, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
							#-------------------------------------------------------------------	
							backButton = ctk.CTkButton(my_Frame, text="Save", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=do_updatecard)
							backButton.place(relx=0.61, rely=0.66, anchor="center")
												
		except FileNotFoundError:
			messagebox.showinfo("Information", "No Bolt cards file found.")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=120, height=32, font=my_font, command=partial(self.showcard, cardidentification))
		backButton.place(relx=0.5, rely=0.9, anchor="center")
				
	def updatecard(self, cardidentification):
		global filepathdestinationfolder, diceFunction
		global created, program_keys, program_link
		global LNURL, program_keys, program_link, url_link, account_name
		global g_Updated_name, g_Updated_description, g_cardidentification, g_LNURL
		global g_maxLimit, g_maxDailyLimit, g_account_name
		
		def updatecard_strong_pre():
			global g_Updated_name, g_Updated_description, g_cardidentification, g_LNURL
			global g_maxLimit, g_maxDailyLimit, g_account_name
			g_Updated_name = nameEntry.get()
			g_Updated_description = descriptionEntry.get()
			g_cardidentification = cardidentification
			g_LNURL = LNURLEntry.get()
			g_maxLimit = int(maxLimitEntry.get())
			g_maxDailyLimit = int(maxDailyLimitEntry.get())
			g_account_name = account_name
			self.dicePassword("1")
			
		def limitSizeName(*args):
			value = boltcard_name_var.get()
			if len(value) > 28: boltcard_name_var.set(value[:28])
		
		def limitSizeDescription(*args):
			value = boltcard_description_var.get()
			if len(value) > 42: boltcard_description_var.set(value[:42])
		
		def limitSizePassword(*args):
			value = boltcard_password_var.get()
			if len(value) > 42: boltcard_password_var.set(value[:42])
		
		def limitSizeLNURL(*args):
			value = boltcard_LNURL_var.get()
			if len(value) > 200: boltcard_LNURL_var.set(value[:200])
						
		def do_updatecard():
			global filepathdestinationfolder, LNURL, program_keys, program_link, url_link, account_name
			Updated_name = nameEntry.get()
			Updated_description = descriptionEntry.get()
			Updated_LNURL = LNURLEntry.get()
			maxLimit = int(maxLimitEntry.get())
			maxDailyLimit = int(maxDailyLimitEntry.get())
			Updated_password = passwordEntry.get()
			
			Updated_Boltcard_data = [
								Updated_name,
								Updated_description,
								cardidentification,
								Updated_LNURL,
								program_keys,
								program_link,
								maxLimit,
								maxDailyLimit,
								url_link,
								account_name,
								Updated_password]
								
			completeName = filepathdestinationfolder + "/secure/boltcards/boltcards.csv"
			updatedcompleteName = str(filepathdestinationfolder) + "/secure/boltcards/updatedBoltcards.csv"
			with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
				csvreader = csv.reader(source)
				csvwriter = csv.writer(result)
				for row in csv.reader(source):
					try:
						if row[2] == cardidentification:
							csvwriter.writerow(Updated_Boltcard_data)
						else:
							csvwriter.writerow(row)						
					except:
						continue
			shutil.copy(updatedcompleteName, completeName)
			os.remove(updatedcompleteName)	
			self.showcard(cardidentification)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		diceFunction = "updateBoltcard"
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
		completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if lines[2] == cardidentification:
							Updated_name = lines[0]
							Updated_description = lines[1]
							# lines[2] is the created date/time
							Updated_LNURL = lines[3]
							program_keys = lines[4]
							program_link = lines[5]
							maxLimit = lines[6]
							maxDailyLimit = lines[7]
							url_link = lines[8]
							account_name = lines[9]
							Updated_password = lines[10]
							
							pubLabel = ctk.CTkLabel(my_Frame, text="Update Boltcard details:", text_color="white", font=my_font, fg_color="black")
							pubLabel.place(relx=0.5, rely=0.09, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							nameheadLabel = ctk.CTkLabel(my_Frame, text="Name:", text_color="white", font=my_font, fg_color="black")
							nameheadLabel.place(relx=0.34, rely=0.18, anchor="e")
							
							boltcard_name_var = ctk.StringVar(value=Updated_name)
							boltcard_name_var.trace('w', limitSizeName)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)				
							nameEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_name, textvariable=boltcard_name_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							nameEntry.place(relx=0.35, rely=0.18, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.26, anchor="e")
							
							boltcard_description_var = ctk.StringVar(value=Updated_description)
							boltcard_description_var.trace('w', limitSizeDescription)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
							descriptionEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_description, textvariable=boltcard_description_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							descriptionEntry.place(relx=0.35, rely=0.26, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="LNURL:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.34, anchor="e")
							
							boltcard_LNURL_var = ctk.StringVar(value=Updated_LNURL)
							boltcard_LNURL_var.trace('w', limitSizeLNURL)
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)	
							LNURLEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_LNURL, textvariable=boltcard_LNURL_var, width=700, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							LNURLEntry.place(relx=0.35, rely=0.34, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							maxLimitLabel = ctk.CTkLabel(my_Frame, text="Max limit:", text_color="white", font=my_font, fg_color="black")
							maxLimitLabel.place(relx=0.34, rely=0.42, anchor="e")
							
							maxLimit_var = ctk.IntVar(value=maxLimit)
							#the_maxLimit_var.trace('w', limitSizeName)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)					
							maxLimitEntry = ctk.CTkEntry(my_Frame, placeholder_text=maxLimit, textvariable=maxLimit_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							maxLimitEntry.place(relx=0.35, rely=0.42, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							maxDailyLimitLabel = ctk.CTkLabel(my_Frame, text="Max daily limit:", text_color="white", font=my_font, fg_color="black")
							maxDailyLimitLabel.place(relx=0.34, rely=0.5, anchor="e")
							
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)								
							
							maxDailyLimit_var = ctk.IntVar(value=maxDailyLimit)
							#the_maxLimit_var.trace('w', limitSizeName)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)				
							maxDailyLimitEntry = ctk.CTkEntry(my_Frame, placeholder_text=maxDailyLimit, textvariable=maxDailyLimit_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							maxDailyLimitEntry.place(relx=0.35, rely=0.5, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
							#-------------------------------------------------------------------
							descrheadLabel = ctk.CTkLabel(my_Frame, text="Password:", text_color="white", font=my_font, fg_color="black")
							descrheadLabel.place(relx=0.34, rely=0.58, anchor="e")
							
							boltcard_password_var = ctk.StringVar(value=Updated_password)
							boltcard_password_var.trace('w', limitSizePassword)
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
							passwordEntry = ctk.CTkEntry(my_Frame, placeholder_text=Updated_password, textvariable=boltcard_password_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
							passwordEntry.place(relx=0.35, rely=0.58, anchor="w")
							doButton = ctk.CTkButton(my_Frame, text="Create a strong password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=updatecard_strong_pre)
							doButton.place(relx=0.69, rely=0.58, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
							#-------------------------------------------------------------------	
							backButton = ctk.CTkButton(my_Frame, text="Save", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=do_updatecard)
							backButton.place(relx=0.61, rely=0.66, anchor="center")
												
		except FileNotFoundError:
			messagebox.showinfo("Information", "No Bolt cards file found.")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=120, height=32, font=my_font, command=partial(self.showcard, cardidentification))
		backButton.place(relx=0.5, rely=0.9, anchor="center")
		
	def deletecard(self, cardidentification):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
		updatedcompleteName = str(filepathdestinationfolder) + "/secure/boltcards/updatedboltcards.csv"
		with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == cardidentification:
						answer = messagebox.askquestion('Important!', 'Are you sure you want to delete the Bolt card?')
						if answer == 'yes':
							self.add_history("Deleted Bolt card: " + row[0])
						else:
							csvwriter.writerow(row)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updatedcompleteName, completeName)
		os.remove(updatedcompleteName)	
		self.create_Boltcardmeny()
		
	def newcard(self):
		global filepathdestinationfolder
		global timeDateString
		
		timeDateString = ''
		now = datetime.now() # current date and time
		
		def date():
			global timeDateString
			dayofmonth = now.strftime("%d")
			month = now.strftime("%B")
			year = now.strftime("%Y")
			
			hour = now.strftime("%H")
			minute = now.strftime("%M")
			second = now.strftime("%S")
			timeDateString = dayofmonth + '-' + month + '-' + year + ' ' + hour + ':' + minute + ':' + second
			
		# Create a new card. Details and pictures from USB-drive
		USER_INP = simpledialog.askstring(title="Name required.", prompt="Name for the new Bolt card (max 28 charachters):")
		
		if USER_INP == "" or USER_INP == " ":
			date()
			USER_INP = timeDateString
		
		USER_INP_tr = USER_INP[:28] if len(USER_INP) > 28 else USER_INP
		
		USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bolt card:")
		
		if USER_INP2 == "" or USER_INP2 == " ":
			USER_INP2 = "-"
			
		USER_INP2_tr = USER_INP2[:28] if len(USER_INP2) > 28 else USER_INP2
		
		answer = messagebox.askquestion('Information!', 'Is the file containing the Bolt card data without encryption?')
			
		if answer == 'no':
			try:
				result = tk.messagebox.askokcancel("Information", "Connect the USB-device and select the encrypted file with the Bolt card data.")
				if not result:
					self.create_Boltcardmeny()
					return
				time.sleep(3)
				filepathdatafile = filedialog.askopenfilename(initialdir='/media/user1')
				completeTempName = filepathdestinationfolder + '/secure/boltcards/boltcardtemp.txt'
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				# Decrypt the file and output it to a temporary file
				data_ = gpg.decrypt_file(filepathdatafile, output=completeTempName)
				# Check if data was OK
				if data_.ok:
					if data_.trust_level is not None and data_.trust_level >= 1:
						# If the trust for the signature key is OK then read the temporary file and split into lines
						try:
							lines = open(completeTempName).read().splitlines()
						except IOError:
							messagebox.showinfo("Information", "There was a problem reading the file!")
						
						if len(lines) == 8:
							completeName = filepathdestinationfolder + "/secure/boltcards/boltcards.csv"
							
							date()
							new_boltcard = [USER_INP_tr, USER_INP2_tr, timeDateString, lines[0], lines[1], lines[2], lines[3], lines[4], lines[5], lines[6], lines[7]]
							
							f = open(completeName, 'a')
							writer = csv.writer(f)
							writer.writerow(new_boltcard)
							f.close()
							if self.lookup_Alias_absolut(data_.fingerprint) != "None":
								the_alias = self.lookup_Alias_absolut(data_.fingerprint)
								messagebox.showinfo("Information", "Success!\n\nSignature from " + the_alias + " is GOOD.\n\nNew Bolt card added!")
							else:
								messagebox.showinfo("Information", "Success!\n\nSignature is good (Key ID: " + data_.key_id + ").\n\nNew Bolt card added!")
								
							pathtofile = filepathdestinationfolder + "/secure/boltcards/" + USER_INP_tr + '_' + timeDateString + '.txt'
							
							shutil.copy(filepathdatafile, pathtofile)
							self.add_history("Added Boltcard: " + USER_INP_tr + " (" + USER_INP2_tr + ")")
							self.create_Boltcardmeny()
						else:
							messagebox.showinfo("Information", "There was a problem reading the decrypted content! \nMake sure that it contains exactly eight lines of data.")
					else:
						messagebox.showinfo("Alert!", "Signature could not be verified!")
						self.create_Boltcardmeny()
				else:
					messagebox.showinfo('Information', data_.status)
					self.create_Boltcardmeny()
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
		else:
			result = tk.messagebox.askokcancel("Bolt card data required", "Connect the USB-device and select the file with the Bolt card data.")
			if not result:
				self.create_Boltcardmeny()
				return
			time.sleep(3)
			filepathdatafile = filedialog.askopenfilename(initialdir='/media/user1')
			
			try:
				lines = open(filepathdatafile).read().splitlines()
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
			if len(lines) == 8:
				completeName = filepathdestinationfolder + "/secure/boltcards/boltcards.csv"
				date()
				new_boltcard = [USER_INP_tr, USER_INP2_tr, timeDateString, lines[0],lines[1],lines[2],lines[3], lines[4], lines[5],lines[6],lines[7]]
				
				f = open(completeName, 'a')
				writer = csv.writer(f)
				writer.writerow(new_boltcard)
				f.close()
				pathtofile = filepathdestinationfolder + "/secure/boltcards/" + USER_INP_tr + '_' + timeDateString + '.txt'
							
				shutil.copy(filepathdatafile, pathtofile)
				self.add_history("Added Boltcard: " + USER_INP_tr + " (" + USER_INP2_tr + ")")
			else:
				messagebox.showinfo("Information", "There was a problem reading the file! \nMake sure there is exactly eight lines with the required data in the file?")
			
		self.create_Boltcardmeny()
	
	def create_BitcoinWalletmeny(self):
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")	
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		def create_bitcointextbox():
			try:
				f = open("/home/user1/help/boltcardHelp.txt", "r")
				file_content = f.read()
				f.close()
				my_text = ctk.CTkTextbox(right_Frame, width=896, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', file_content)
			except OSError:
				my_text = ctk.CTkTextbox(right_Frame, width=896, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
				my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
			my_text.configure(state="disabled")
			my_text.place(relx=0.5, rely=0.5, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
			backButton = ctk.CTkButton(right_Frame, text="Back", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=100, height=26, font=my_font, command=self.create_BitcoinWalletmeny)
			backButton.place(relx=0.93, rely=0.96, anchor="center")
								
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		if path_to_USB_secure == 'Secure USB folder is available':
			if not os.path.isfile(completeName):
				my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			
				infoLabel = ctk.CTkLabel(right_Frame, text="You have no Bitcoin wallets yet!", text_color="white", font=my_font, fg_color="black")
				infoLabel.place(relx=0.03, rely=0.07, anchor="w")
			else:
				my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=True, overstrike=False)
				infoLabel = ctk.CTkLabel(right_Frame, text="Bitcoin wallets with Air-gapped signing", text_color="white", font=my_font, fg_color="black")
				infoLabel.place(relx=0.03, rely=0.07, anchor="w")
				
			pathtoWalletimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"

			completeName = str(filepathdestinationfolder) + "/secure/wallets/bitconwallets.csv"
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			counter = 0
			
			Buttonadd = ctk.CTkButton(right_Frame, text="Add an existing Bitcoin Wallet", text_color="black", fg_color="orange", border_width=2, border_color="white", width=300, height=25, font=my_font, command=self.addnewBitcoinwallet)
			Buttonadd.place(relx=0.98, rely=0.04, anchor="e")
			Buttoncreate = ctk.CTkButton(right_Frame, text="Create new wallet with password", text_color="black", fg_color="orange", border_width=2, border_color="white", width=300, height=25, font=my_font, command=self.createnewBitcoinwallet_PRE)
			Buttoncreate.place(relx=0.98, rely=0.10, anchor="e")
			Buttoncreate2 = ctk.CTkButton(right_Frame, text="Create new wallet with 24 words", text_color="black", fg_color="orange", border_width=2, border_color="white", width=300, height=25, font=my_font, command=self.diceWallet_PRE)
			Buttoncreate2.place(relx=0.98, rely=0.16, anchor="e")
			
			Buttonmoreinfo = ctk.CTkButton(right_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=create_bitcointextbox)
			Buttonmoreinfo.place(relx=0.92, rely=0.96, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)
			infoLabel = ctk.CTkLabel(right_Frame, text="There are 3 options for air-gapped Bitcoin wallets:", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.03, rely=0.15, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
			infoLabel = ctk.CTkLabel(right_Frame, text="1. Add a seed that's created by a hardware wallet *:", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.03, rely=0.2, anchor="w")
			infoLabel2 = ctk.CTkLabel(right_Frame, text="  - You could use a Blockstream Jade that can generate a wallet offline.", text_color="white", font=my_font, fg_color="black")
			infoLabel2.place(relx=0.03, rely=0.26, anchor="w")
			infoLabel3 = ctk.CTkLabel(right_Frame, text="  - Use it for air-gapped signing and it will be included when a backup is made.", text_color="white", font=my_font, fg_color="black")
			infoLabel3.place(relx=0.03, rely=0.32, anchor="w")
			infoLabel4 = ctk.CTkLabel(right_Frame, text="  - The seed is encrypted when powered down or logged out.", text_color="white", font=my_font, fg_color="black")
			infoLabel4.place(relx=0.03, rely=0.38, anchor="w")
			
			infoLabel10 = ctk.CTkLabel(right_Frame, text="2. Create a new wallet seed with a BIP38 password using the Offline device *:", text_color="white", font=my_font, fg_color="black")
			infoLabel10.place(relx=0.03, rely=0.46, anchor="w")
			infoLabel11 = ctk.CTkLabel(right_Frame, text="  - Avoid having less randomness and be less secure by using a strong password!", text_color="white", font=my_font, fg_color="black")
			infoLabel11.place(relx=0.03, rely=0.52, anchor="w")
			infoLabel12 = ctk.CTkLabel(right_Frame, text="  - The seed and the password is encrypted when powered down or logged out.", text_color="white", font=my_font, fg_color="black")
			infoLabel12.place(relx=0.03, rely=0.58, anchor="w")
			
			infoLabel13 = ctk.CTkLabel(right_Frame, text="3. Create a new seed on the Offline device by throwing dices (to create randomness) *.", text_color="white", font=my_font, fg_color="black")
			infoLabel13.place(relx=0.03, rely=0.66, anchor="w")
			infoLabel14 = ctk.CTkLabel(right_Frame, text="Wallet Xpub are moved to an Online device for generating and broacasting the transactions **.", text_color="white", font=my_font, fg_color="black")
			infoLabel14.place(relx=0.03, rely=0.75, anchor="w")
			
			proLabel = ctk.CTkLabel(right_Frame, text="* Transaction signing for Native Segwit and derivation path m/84'/0'/0'.", text_color="white", font=my_font, fg_color="black")
			proLabel.place(relx=0.03, rely=0.84, anchor="w")

			proLabel3 = ctk.CTkLabel(right_Frame, text="** Only the transaction signing is done offline (using Offline device or Blockstream Jade etc)", text_color="white", font=my_font, fg_color="black")
			proLabel3.place(relx=0.03, rely=0.90, anchor="w")
			
			Counting = 0
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)								
					cardLabel = ctk.CTkLabel(left_Frame, text="Bitcoin wallets", text_color="white", font=my_font, fg_color="black").pack(padx=10, pady=8, side= TOP, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
					
					for lines in csvfile:
						if lines:
							w_icon_path = filepathdestinationfolder + "/secure/wallets/" + lines[0] + ".jpg"
							if os.path.isfile(w_icon_path):
								pathtoWalletIconimage = w_icon_path
								walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
							else:
								walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletimage), dark_image=Image.open(pathtoWalletimage), size=(230, 100))
								
							my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
							if Counting == 0:
								if os.path.isfile(w_icon_path):
									Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
									Button1.pack(padx=80, pady=10, side= TOP, anchor="w")
								else:
									Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
									Button1.pack(padx=10, pady=10, side= TOP, anchor="w")
								Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
								Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							else:
								if os.path.isfile(w_icon_path):
									Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
									Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
								else:
									Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
									Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
								Llabel2 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
								Llabel2.pack(padx=1, pady=0, side= TOP, anchor="center")
							Counting += 1
			except FileNotFoundError:
				print("No Bitcoin wallets yet.")
		else:
			notOKButton = ctk.CTkButton(right_Frame, text="You are not logged in.", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def diceWallet_PRE(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=32, slant="roman", weight="bold", underline=False, overstrike=False)
		
		disclaimerLabel = ctk.CTkLabel(my_Frame, text="DISCLAIMER!", text_color="white", fg_color="black", font=my_font)
		disclaimerLabel.place(relx=0.5, rely=0.26, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", weight="normal", underline=False, overstrike=False)
		
		disclaimerLabel2 = ctk.CTkLabel(my_Frame, text="THIS IS EXPERIMENTAL SOFTWARE. PROCEED WITH CAUTION!", text_color="white", fg_color="black", font=my_font)
		disclaimerLabel2.place(relx=0.5, rely=0.34, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
		calcButton = ctk.CTkButton(my_Frame, text="GOT IT. Let's go!", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=140, height=36, font=my_font, command=partial(self.diceWallet, "1"))
		calcButton.place(relx=0.5, rely=0.58, anchor="center")
			
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
		backButton.place(relx=0.5, rely=0.96, anchor="center")
		
	def diceWallet(self, diceroll):
		global filepathdestinationfolder
		global diceWordsList
		global nextdiceroll
		
		def addWord():
			global diceWordsList
			global nextdiceroll
			# Get seed word from BIP39 list
			dec_list = []
			seed_word_list = []
			if int(diceroll) <= 23:
				dec_list.append(opt1.get())
				dec_list.append(opt2.get())
				dec_list.append(opt3.get())
				dec_list.append(opt4.get())
				dec_list.append(opt5.get())
				dec_list.append(opt6.get())
				dec_list.append(opt7.get())
				dec_list.append(opt8.get())
				dec_list.append(opt9.get())
				dec_list.append(opt10.get())
				dec_list.append(opt11.get())
				
				binString = ''
			
				for conv in dec_list:
					if conv == '1' or conv == '2' or conv == '3':
						binString = ''.join((binString,'0'))
					else:
						binString = ''.join((binString,'1'))
				
				pathBIP39list = filepathdestinationfolder + '/Documents/english.txt'
				f=open(pathBIP39list)
				lines=f.readlines()
				index = int(binString, 2)
				Seed_word = lines[index]
				Seed_word_stripped = Seed_word.rstrip('\n')
				
				seed_word_list = [Seed_word_stripped,binString]
			
				diceWordsList.append(seed_word_list)
			
			else:
				dec_list.append(opt9.get())
				dec_list.append(opt10.get())
				dec_list.append(opt11.get())
				
				binString = ''
				
				# Get the last three binary values
				for conv in dec_list:
					if conv == '1' or conv == '2' or conv == '3':
						binString = ''.join((binString,'0'))
					else:
						binString = ''.join((binString,'1'))
				
				# Add the bin string to list and a temp word in list position 23 (not calculated yet)
				seed_word_list = ["temp",binString]
			
				diceWordsList.append(seed_word_list)
				
				# Now the dice wordlists BINARY data is complete for hashing
				binStringTotal = ''
				for binword in diceWordsList:
					binStringTotal = ''.join((binStringTotal,binword[1]))
				cmd = 'echo ' + binStringTotal + ' | shasum -a 256 -0'
				result = subprocess.run(cmd, shell=True, encoding='utf-8', stdout=subprocess.PIPE) 
				answer_STDOUT = result.stdout
				hex_value_str = answer_STDOUT[0] + answer_STDOUT[1]
				
				scale = 16
				num_of_bits = 8
				b = bin(int(hex_value_str, scale))[2:].zfill(num_of_bits)
				
				# Add the 8 remaining bin values to the existing three
				binStringtot = ''.join((binString,b))
				
				# Get the last word from file
				pathBIP39list = filepathdestinationfolder + '/Documents/english.txt'
				f=open(pathBIP39list)
				lines=f.readlines()
				index = int(binStringtot, 2)
				
				Seed_word = lines[index]
				Seed_word_stripped = Seed_word.rstrip('\n')
				seed_word_list = [Seed_word_stripped,binStringtot]
				diceWordsList[23] = seed_word_list
				
			self.diceWallet(str(nextdiceroll))
		
		def sha256Hex(data):
			
			sha256 = hashlib.sha256()
			sha256.update(data.encode("utf-8"))
					
			return sha256.hexdigest()
		
		def createWallet():
			global diceWordsList
			
			seed_words = diceWordsList[0][0] + ' ' + diceWordsList[1][0] + ' ' + diceWordsList[2][0] + ' ' + diceWordsList[3][0] + ' ' + diceWordsList[4][0] + ' ' + diceWordsList[5][0] + ' ' + diceWordsList[6][0] + ' ' + diceWordsList[7][0] + ' ' + diceWordsList[8][0] + ' ' + diceWordsList[9][0] + ' ' + diceWordsList[10][0] + ' ' + diceWordsList[11][0] + ' ' + diceWordsList[12][0] + ' ' + diceWordsList[13][0] + ' ' + diceWordsList[14][0] + ' ' + diceWordsList[15][0] + ' ' + diceWordsList[16][0] + ' ' + diceWordsList[17][0] + ' ' + diceWordsList[18][0] + ' ' + diceWordsList[19][0] + ' ' + diceWordsList[20][0] + ' ' + diceWordsList[21][0] + ' ' + diceWordsList[22][0] + ' ' + diceWordsList[23][0]
		
			mnemo = Mnemonic("english")
			isValid = mnemo.check(seed_words) # returns a boolean
			
			completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
			thedate = str(date.today())
		
			if isValid:
				now = datetime.now() # current date and time
				timeStamp = now.strftime("%m%d%Y%H%M%S")
				
				USER_INP = simpledialog.askstring(title="Name required.", prompt="Name for wallet (max 30 character):")
				
				if USER_INP == "" or USER_INP == " ":
					USER_INP = "Wallet" + timeStamp
				
				USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
				
				USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bitcoin wallet (optional):")
				
				if USER_INP2 == "" or USER_INP2 == " ":
					USER_INP2 = "-"
				
				USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
				
				password_bool = False
				seed_size = '24'
				password = 'none'
				
				new_bitcoinwallet = [USER_INP_tr, USER_INP2_tr, thedate, seed_words, seed_size, password_bool, password]
			
				if not os.path.isfile(completeName):
					f = open(completeName, 'w')
					writer = csv.writer(f)
					writer.writerow(new_bitcoinwallet)
					f.close()
				else:
					f = open(completeName, 'a')
					writer = csv.writer(f)
					writer.writerow(new_bitcoinwallet)
					f.close()
				
				completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
				f2 = open(completeName, 'a')
				
				if password_bool:
					f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Password: " + password + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
				else:
					f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
				
				f2.close()
				pathtoDiceWalletIcon = str(filepathdestinationfolder) + "/images/Dices_gold_icon.jpg"
				w_icon_path = filepathdestinationfolder + "/secure/wallets/" + USER_INP_tr + ".jpg"
				shutil.copy(pathtoDiceWalletIcon, w_icon_path)
				self.add_history("Added a new Bitcoin wallet created by rolling of the dice: " + USER_INP_tr + " (" + USER_INP2_tr + ")")
			else:
				messagebox.showinfo("Information", "There was a problem with the words.\n\nIt is not a valid Bitcoin wallet seed.\n\n        Please try again.")
			self.create_BitcoinWalletmeny()
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", weight="bold", underline=True, overstrike=False)
		infoLabel = ctk.CTkLabel(my_Frame, text="Create a 24 words seed phrase for a Bitcoin wallet by rolling the dice!", text_color="dark orange", font=my_font, fg_color="black")
		infoLabel.place(relx=0.03, rely=0.06, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		infoLabel2 = ctk.CTkLabel(my_Frame, text="Roll 11 dice's (or one dice for 11 times) to make up each random seed word. Last word is calculated based", text_color="white", font=my_font, fg_color="black")
		infoLabel2.place(relx=0.03, rely=0.12, anchor="w")
		infoLabel3 = ctk.CTkLabel(my_Frame, text="on three dice rolls and the sum of the previous words. All words are as defined in Bitcoin standard BIP39.", text_color="white", font=my_font, fg_color="black")
		infoLabel3.place(relx=0.03, rely=0.17, anchor="w")
		infoLabel4 = ctk.CTkLabel(my_Frame, text="Roll the dices and fill in the values in each of the drop-down menus below and then click \"Create word\".", text_color="white", font=my_font, fg_color="black")
		infoLabel4.place(relx=0.03, rely=0.24, anchor="w")
		
		pathtodiceicon = str(filepathdestinationfolder) + "/images/dice_icon.jpg"
		diceimage = ctk.CTkImage(light_image=Image.open(pathtodiceicon), dark_image=Image.open(pathtodiceicon), size=(100, 120))
		diceLabel = ctk.CTkLabel(my_Frame, image=diceimage, text = "")
		diceLabel.place(relx=0.99, rely=0.01, anchor="ne")
		
		linesList = ['1','2','3','4','5','6']
		
		pre1 = randrange(1, 7)
		pre2 = randrange(1, 7)
		pre3 = randrange(1, 7)
		pre4 = randrange(1, 7)
		pre5 = randrange(1, 7)
		pre6 = randrange(1, 7)
		pre7 = randrange(1, 7)
		pre8 = randrange(1, 7)
		pre9 = randrange(1, 7)
		pre10 = randrange(1, 7)
		pre11 = randrange(1, 7)
		
		opt1 = StringVar(value=str(pre1))
		opt2 = StringVar(value=str(pre2))
		opt3 = StringVar(value=str(pre3))
		opt4 = StringVar(value=str(pre4))
		opt5 = StringVar(value=str(pre5))
		opt6 = StringVar(value=str(pre6))
		opt7 = StringVar(value=str(pre7))
		opt8 = StringVar(value=str(pre8))
		opt9 = StringVar(value=str(pre9))
		opt10 = StringVar(value=str(pre10))
		opt11 = StringVar(value=str(pre11))
		
		if int(diceroll) <= 23:
			drop1 = OptionMenu(my_Frame, opt1, *linesList)
			drop1.config(width=2)
			drop1.place(relx=0.06, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop1.menuname)
			drop1.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop2 = OptionMenu(my_Frame, opt2, *linesList)
			drop2.config(width=2)
			drop2.place(relx=0.12, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop2.menuname)
			drop2.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop3 = OptionMenu(my_Frame, opt3, *linesList)
			drop3.config(width=2)
			drop3.place(relx=0.18, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop3.menuname)
			drop3.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop4 = OptionMenu(my_Frame, opt4, *linesList)
			drop4.config(width=2)
			drop4.place(relx=0.24, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop4.menuname)
			drop4.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop5 = OptionMenu(my_Frame, opt5, *linesList)
			drop5.config(width=2)
			drop5.place(relx=0.32, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop5.menuname)
			drop5.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop6 = OptionMenu(my_Frame, opt6, *linesList)
			drop6.config(width=2)
			drop6.place(relx=0.38, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop6.menuname)
			drop6.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop7 = OptionMenu(my_Frame, opt7, *linesList)
			drop7.config(width=2)
			drop7.place(relx=0.44, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop7.menuname)
			drop7.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop8 = OptionMenu(my_Frame, opt8, *linesList)
			drop8.config(width=2)
			drop8.place(relx=0.5, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop8.menuname)
			drop8.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop9 = OptionMenu(my_Frame, opt9, *linesList)
			drop9.config(width=2)
			drop9.place(relx=0.58, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop9.menuname)
			drop9.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop10 = OptionMenu(my_Frame, opt10, *linesList)
			drop10.config(width=2)
			drop10.place(relx=0.64, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop10.menuname)
			drop10.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop11 = OptionMenu(my_Frame, opt11, *linesList)
			drop11.config(width=2)
			drop11.place(relx=0.7, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop11.menuname)
			drop11.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			nextdiceroll = int(diceroll) + 1
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman",  weight="bold", underline=False, overstrike=False)
			nextButton = ctk.CTkButton(my_Frame, text="Create word", text_color="black", fg_color="orange", border_width=2, border_color="white", width=180, height=36, font=my_font, command=addWord)
			nextButton.place(relx=0.94, rely=0.33, anchor="e")
		elif int(diceroll) == 24:
			drop9 = OptionMenu(my_Frame, opt9, *linesList)
			drop9.config(width=2)
			drop9.place(relx=0.58, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop9.menuname)
			drop9.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop10 = OptionMenu(my_Frame, opt10, *linesList)
			drop10.config(width=2)
			drop10.place(relx=0.64, rely=0.33, anchor="center")	
			
			menu=self.nametowidget(drop10.menuname)
			drop10.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			drop11 = OptionMenu(my_Frame, opt11, *linesList)
			drop11.config(width=2)
			drop11.place(relx=0.7, rely=0.33, anchor="center")
			
			menu=self.nametowidget(drop11.menuname)
			drop11.config(font=['Arial',20])
			menu.config(font=['Arial',22])
			
			nextdiceroll = int(diceroll) + 1
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman",  weight="bold", underline=False, overstrike=False)
			nextButton = ctk.CTkButton(my_Frame, text="Create word", text_color="black", fg_color="orange", border_width=2, border_color="white", width=180, height=36, font=my_font, command=addWord)
			nextButton.place(relx=0.94, rely=0.33, anchor="e")
		else:
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman",  weight="bold", underline=False, overstrike=False)
			calcButton = ctk.CTkButton(my_Frame, text="Create wallet made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=200, height=36, font=my_font, command=createWallet)
			calcButton.place(relx=0.5, rely=0.84, anchor="center")
				
		if int(diceroll) == 1:
			diceWordsList = []
		else:
			# Print the seed words
			x_value = 0.06
			padx = 0.14
			pady = 0.08
			y_value = 0.46
			count = 1
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
			
			for word in diceWordsList:
				if count == 7 or count == 13 or count == 19:
					x_value = 0.06
					y_value = y_value + pady
				wordLabel = ctk.CTkLabel(my_Frame, text=str(count) + '. ' + word[0], text_color="dark orange", font=my_font, fg_color="black")
				wordLabel.place(relx=x_value, rely=y_value, anchor="w")
				x_value += padx
				count += 1
				
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
		backButton.place(relx=0.5, rely=0.96, anchor="center")
	
	def dicePassword(self, diceroll):
		global filepathdestinationfolder
		global combinedValueStr
		global combinedValueBase58
		global diceFunction
		global nextdiceroll
		
		def addEntropy():
			global combinedValueStr
			global combinedValueBase58
			global nextdiceroll
			
			dec_list = []
			dec_list2 = []
			dec_list3 = []
			dec_list4 = []
			dec_list.append(opt1.get())
			dec_list.append(opt2.get())
			dec_list.append(opt3.get())
			dec_list.append(opt4.get())
			dec_list2.append(opt5.get())
			dec_list2.append(opt6.get())
			dec_list2.append(opt7.get())
			dec_list2.append(opt8.get())
			
			dec_list3.append(opt9.get())
			dec_list3.append(opt10.get())
			dec_list3.append(opt11.get())
			dec_list3.append(opt12.get())
			dec_list4.append(opt13.get())
			dec_list4.append(opt14.get())
			dec_list4.append(opt15.get())
			dec_list4.append(opt16.get())
				
			binString1 = ''
			binString2 = ''
			binString3 = ''
			binString4 = ''
			
			for conv in dec_list:
				if conv == '1' or conv == '2' or conv == '3':
					binString1 = ''.join((binString1,'0'))
				else:
					binString1 = ''.join((binString1,'1'))
			
			for conv in dec_list2:
				if conv == '1' or conv == '2' or conv == '3':
					binString2 = ''.join((binString2,'0'))
				else:
					binString2 = ''.join((binString2,'1'))
			
			for conv in dec_list3:
				if conv == '1' or conv == '2' or conv == '3':
					binString3 = ''.join((binString3,'0'))
				else:
					binString3 = ''.join((binString3,'1'))
			
			for conv in dec_list4:
				if conv == '1' or conv == '2' or conv == '3':
					binString4 = ''.join((binString4,'0'))
				else:
					binString4 = ''.join((binString4,'1'))
			
			newValue1 = hex(int(binString1, 2)).split("x")[-1]
			newValue2 = hex(int(binString2, 2)).split("x")[-1]
			newValue3 = hex(int(binString3, 2)).split("x")[-1]
			newValue4 = hex(int(binString4, 2)).split("x")[-1]
			
			combinedValueStr = combinedValueStr + str(newValue1) + str(newValue2) + str(newValue3) + str(newValue4)
			combinedValueBase58 = base58.b58encode(bytes.fromhex(combinedValueStr))
				
			self.dicePassword(str(nextdiceroll))
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", weight="bold", underline=True, overstrike=False)
		infoLabel = ctk.CTkLabel(my_Frame, text="Create a strong password by rolling dices or use Offline device random numbers!", text_color="dark orange", font=my_font, fg_color="black")
		infoLabel.place(relx=0.03, rely=0.06, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		infoLabel2 = ctk.CTkLabel(my_Frame, text="Roll 8 dice's for a min 16 times to make a random password. Or use pre-set built-in random numbers.", text_color="white", font=my_font, fg_color="black")
		infoLabel2.place(relx=0.03, rely=0.12, anchor="w")
		
		pathtodiceicon = str(filepathdestinationfolder) + "/images/dice_icon.jpg"
		diceimage = ctk.CTkImage(light_image=Image.open(pathtodiceicon), dark_image=Image.open(pathtodiceicon), size=(100, 120))
		diceLabel = ctk.CTkLabel(my_Frame, image=diceimage, text = "")
		diceLabel.place(relx=0.99, rely=0.01, anchor="ne")
		
		linesList = ['1','2','3','4','5','6']
		
		pre1 = randrange(1, 7)
		pre2 = randrange(1, 7)
		pre3 = randrange(1, 7)
		pre4 = randrange(1, 7)
		pre5 = randrange(1, 7)
		pre6 = randrange(1, 7)
		pre7 = randrange(1, 7)
		pre8 = randrange(1, 7)
		
		pre9 = randrange(1, 7)
		pre10 = randrange(1, 7)
		pre11 = randrange(1, 7)
		pre12 = randrange(1, 7)
		pre13 = randrange(1, 7)
		pre14 = randrange(1, 7)
		pre15 = randrange(1, 7)
		pre16 = randrange(1, 7)
		
		opt1 = StringVar(value=str(pre1))
		opt2 = StringVar(value=str(pre2))
		opt3 = StringVar(value=str(pre3))
		opt4 = StringVar(value=str(pre4))
		opt5 = StringVar(value=str(pre5))
		opt6 = StringVar(value=str(pre6))
		opt7 = StringVar(value=str(pre7))
		opt8 = StringVar(value=str(pre8))
		
		opt9 = StringVar(value=str(pre9))
		opt10 = StringVar(value=str(pre10))
		opt11 = StringVar(value=str(pre11))
		opt12 = StringVar(value=str(pre12))
		opt13 = StringVar(value=str(pre13))
		opt14 = StringVar(value=str(pre14))
		opt15 = StringVar(value=str(pre15))
		opt16 = StringVar(value=str(pre16))
		
		drop1 = OptionMenu(my_Frame, opt1, *linesList)
		drop1.config(width=2)
		drop1.place(relx=0.12, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop1.menuname)
		drop1.config(font=['Arial',20])
		menu.config(font=['Arial',22])
			
		drop2 = OptionMenu(my_Frame, opt2, *linesList)
		drop2.config(width=2)
		drop2.place(relx=0.19, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop2.menuname)
		drop2.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop3 = OptionMenu(my_Frame, opt3, *linesList)
		drop3.config(width=2)
		drop3.place(relx=0.26, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop3.menuname)
		drop3.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop4 = OptionMenu(my_Frame, opt4, *linesList)
		drop4.config(width=2)
		drop4.place(relx=0.33, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop4.menuname)
		drop4.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop5 = OptionMenu(my_Frame, opt5, *linesList)
		drop5.config(width=2)
		drop5.place(relx=0.45, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop5.menuname)
		drop5.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop6 = OptionMenu(my_Frame, opt6, *linesList)
		drop6.config(width=2)
		drop6.place(relx=0.52, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop6.menuname)
		drop6.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop7 = OptionMenu(my_Frame, opt7, *linesList)
		drop7.config(width=2)
		drop7.place(relx=0.59, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop7.menuname)
		drop7.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop8 = OptionMenu(my_Frame, opt8, *linesList)
		drop8.config(width=2)
		drop8.place(relx=0.66, rely=0.29, anchor="center")
		
		menu=self.nametowidget(drop8.menuname)
		drop8.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop9 = OptionMenu(my_Frame, opt9, *linesList)
		drop9.config(width=2)
		drop9.place(relx=0.12, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop9.menuname)
		drop9.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop10 = OptionMenu(my_Frame, opt10, *linesList)
		drop10.config(width=2)
		drop10.place(relx=0.19, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop10.menuname)
		drop10.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop11 = OptionMenu(my_Frame, opt11, *linesList)
		drop11.config(width=2)
		drop11.place(relx=0.26, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop11.menuname)
		drop11.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop12 = OptionMenu(my_Frame, opt12, *linesList)
		drop12.config(width=2)
		drop12.place(relx=0.33, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop12.menuname)
		drop12.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop13 = OptionMenu(my_Frame, opt13, *linesList)
		drop13.config(width=2)
		drop13.place(relx=0.45, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop13.menuname)
		drop13.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop14 = OptionMenu(my_Frame, opt14, *linesList)
		drop14.config(width=2)
		drop14.place(relx=0.52, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop14.menuname)
		drop14.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop15 = OptionMenu(my_Frame, opt15, *linesList)
		drop15.config(width=2)
		drop15.place(relx=0.59, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop15.menuname)
		drop15.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		drop16 = OptionMenu(my_Frame, opt16, *linesList)
		drop16.config(width=2)
		drop16.place(relx=0.66, rely=0.38, anchor="center")
		
		menu=self.nametowidget(drop16.menuname)
		drop16.config(font=['Arial',20])
		menu.config(font=['Arial',22])
		
		nextdiceroll = int(diceroll) + 1
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
		nextButton = ctk.CTkButton(my_Frame, text="Add set " + str(diceroll), text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=addEntropy)
		nextButton.place(relx=0.84, rely=0.34, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		if diceFunction == "Inheritance":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.inheritance, "none"))
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		if diceFunction == "newAccount":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.new_secureUSB, "none"))
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		elif diceFunction == "newGPG":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.newGPGFull_Key, "none"))
			backButton.place(relx=0.5, rely=0.96, anchor="center")	
		elif diceFunction == "strongPassword":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.createPassword, "none"))
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		elif diceFunction == "createWallet":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		elif diceFunction == "updateBoltcard":
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Boltcardmeny)
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		else:
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
			backButton.place(relx=0.5, rely=0.96, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=36, slant="roman", weight="bold", underline=False, overstrike=False)
				
		if int(diceroll) == 1:
			combinedValueStr = ''
			combinedValueBase58 = ''
		else:
			wordLabel = ctk.CTkLabel(my_Frame, text=combinedValueBase58, text_color="white", font=my_font, fg_color="black")
			wordLabel.place(relx=0.5, rely=0.55, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)		
			if int(diceroll) < 5:
				weekLabel = ctk.CTkLabel(my_Frame, text="(Week)", text_color="red", font=my_font, fg_color="black")
				weekLabel.place(relx=0.5, rely=0.63, anchor="center")
			elif int(diceroll) > 4 and int(diceroll) < 8:
				medLabel = ctk.CTkLabel(my_Frame, text="(Medium)", text_color="white", font=my_font, fg_color="black")
				medLabel.place(relx=0.5, rely=0.63, anchor="center")
			else:
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
				if diceFunction == "Inheritance":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.inheritance, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")		
				elif diceFunction == "newAccount":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.new_secureUSB, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")	
				elif diceFunction == "newGPG":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.newGPGFull_Key, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")	
				elif diceFunction == "strongPassword":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.createPassword, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")
				elif diceFunction == "createWallet":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.createnewBitcoinwallet_Strong, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")
				elif diceFunction == "updateBoltcard":
					calcButton = ctk.CTkButton(my_Frame, text="Use password made from dice throws", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.updatecard_Strong, combinedValueBase58))
					calcButton.place(relx=0.5, rely=0.8, anchor="center")			
				if int(diceroll) > 12:
					my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)	
					strongLabel = ctk.CTkLabel(my_Frame, text="(Extra strong password!)", text_color="light green", font=my_font, fg_color="black")
					strongLabel.place(relx=0.5, rely=0.63, anchor="center")
				else:
					my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)	
					strongLabel = ctk.CTkLabel(my_Frame, text="(Strong password!)", text_color="light green", font=my_font, fg_color="black")
					strongLabel.place(relx=0.5, rely=0.63, anchor="center")
			
	def addnewBitcoinwallet(self):
		global filepathdestinationfolder
        
		seed_size = "12"
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%m%d%Y%H%M%S")
		
		USER_INP = simpledialog.askstring(title="Name required.", prompt="Name for wallet (max 30 character):")
		
		if USER_INP == "" or USER_INP == " ":
			USER_INP = "Wallet" + timeStamp
		
		USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
		
		USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bitcoin wallet (optional):")
		
		if USER_INP2 == "" or USER_INP2 == " ":
			USER_INP2 = "-"
		
		USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
		
		answer = messagebox.askquestion('Question!', 'Is the new wallet with a 12 word seed phrase (answer \"No\" will ask you to insert 24 words).')
		
		if answer == 'yes':
			USER_INP_WORD1 = simpledialog.askstring(title="Seed word 1!", prompt="Enter seed word number 1 (use only small letters):")
			USER_INP_WORD2 = simpledialog.askstring(title="Seed word 2!", prompt="Enter seed word number 2:")
			USER_INP_WORD3 = simpledialog.askstring(title="Seed word 3!", prompt="Enter seed word number 3:")
			USER_INP_WORD4 = simpledialog.askstring(title="Seed word 4!", prompt="Enter seed word number 4:")
			USER_INP_WORD5 = simpledialog.askstring(title="Seed word 5!", prompt="Enter seed word number 5:")
			USER_INP_WORD6 = simpledialog.askstring(title="Seed word 6!", prompt="Enter seed word number 6:")
			USER_INP_WORD7 = simpledialog.askstring(title="Seed word 7!", prompt="Enter seed word number 7:")
			USER_INP_WORD8 = simpledialog.askstring(title="Seed word 8!", prompt="Enter seed word number 8:")
			USER_INP_WORD9 = simpledialog.askstring(title="Seed word 9!", prompt="Enter seed word number 9:")
			USER_INP_WORD10 = simpledialog.askstring(title="Seed word 10!", prompt="Enter seed word number 10:")
			USER_INP_WORD11 = simpledialog.askstring(title="Seed word 11!", prompt="Enter seed word number 11:")
			USER_INP_WORD12 = simpledialog.askstring(title="Seed word 12!", prompt="Enter seed word number 12:")
		else:
			seed_size = "24"
			USER_INP_WORD1 = simpledialog.askstring(title="Seed word 1!", prompt="Enter seed word number 1 (use only small letters):")
			USER_INP_WORD2 = simpledialog.askstring(title="Seed word 2!", prompt="Enter seed word number 2:")
			USER_INP_WORD3 = simpledialog.askstring(title="Seed word 3!", prompt="Enter seed word number 3:")
			USER_INP_WORD4 = simpledialog.askstring(title="Seed word 4!", prompt="Enter seed word number 4:")
			USER_INP_WORD5 = simpledialog.askstring(title="Seed word 5!", prompt="Enter seed word number 5:")
			USER_INP_WORD6 = simpledialog.askstring(title="Seed word 6!", prompt="Enter seed word number 6:")
			USER_INP_WORD7 = simpledialog.askstring(title="Seed word 7!", prompt="Enter seed word number 7:")
			USER_INP_WORD8 = simpledialog.askstring(title="Seed word 8!", prompt="Enter seed word number 8:")
			USER_INP_WORD9 = simpledialog.askstring(title="Seed word 9!", prompt="Enter seed word number 9:")
			USER_INP_WORD10 = simpledialog.askstring(title="Seed word 10!", prompt="Enter seed word number 10:")
			USER_INP_WORD11 = simpledialog.askstring(title="Seed word 11!", prompt="Enter seed word number 11:")
			USER_INP_WORD12 = simpledialog.askstring(title="Seed word 12!", prompt="Enter seed word number 12:")
			USER_INP_WORD13 = simpledialog.askstring(title="Seed word 13!", prompt="Enter seed word number 13:")
			USER_INP_WORD14 = simpledialog.askstring(title="Seed word 14!", prompt="Enter seed word number 14:")
			USER_INP_WORD15 = simpledialog.askstring(title="Seed word 15!", prompt="Enter seed word number 15:")
			USER_INP_WORD16 = simpledialog.askstring(title="Seed word 16!", prompt="Enter seed word number 16:")
			USER_INP_WORD17 = simpledialog.askstring(title="Seed word 17!", prompt="Enter seed word number 17:")
			USER_INP_WORD18 = simpledialog.askstring(title="Seed word 18!", prompt="Enter seed word number 18:")
			USER_INP_WORD19 = simpledialog.askstring(title="Seed word 19!", prompt="Enter seed word number 19:")
			USER_INP_WORD20 = simpledialog.askstring(title="Seed word 20!", prompt="Enter seed word number 20:")
			USER_INP_WORD21 = simpledialog.askstring(title="Seed word 21!", prompt="Enter seed word number 21:")
			USER_INP_WORD22 = simpledialog.askstring(title="Seed word 22!", prompt="Enter seed word number 22:")
			USER_INP_WORD23 = simpledialog.askstring(title="Seed word 23!", prompt="Enter seed word number 23:")
			USER_INP_WORD24 = simpledialog.askstring(title="Seed word 24!", prompt="Enter seed word number 24:")
		
		if seed_size == "12":
			seed_words = USER_INP_WORD1 + ' ' + USER_INP_WORD2 + ' ' + USER_INP_WORD3 + ' ' + USER_INP_WORD4 + ' ' + USER_INP_WORD5 + ' ' + USER_INP_WORD6 + ' ' + USER_INP_WORD7 + ' ' + USER_INP_WORD8 + ' ' + USER_INP_WORD9 + ' ' + USER_INP_WORD10 + ' ' + USER_INP_WORD11 + ' ' + USER_INP_WORD12
		else:
			seed_words = USER_INP_WORD1 + ' ' + USER_INP_WORD2 + ' ' + USER_INP_WORD3 + ' ' + USER_INP_WORD4 + ' ' + USER_INP_WORD5 + ' ' + USER_INP_WORD6 + ' ' + USER_INP_WORD7 + ' ' + USER_INP_WORD8 + ' ' + USER_INP_WORD9 + ' ' + USER_INP_WORD10 + ' ' + USER_INP_WORD11 + ' ' + USER_INP_WORD12 + ' ' + USER_INP_WORD13 + ' ' + USER_INP_WORD14 + ' ' + USER_INP_WORD15 + ' ' + USER_INP_WORD16 + ' ' + USER_INP_WORD17 + ' ' + USER_INP_WORD18 + ' ' + USER_INP_WORD19 + ' ' + USER_INP_WORD20 + ' ' + USER_INP_WORD21 + ' ' + USER_INP_WORD22 + ' ' + USER_INP_WORD23 + ' ' + USER_INP_WORD24
		
		mnemo = Mnemonic("english")
		isValid = mnemo.check(seed_words) # returns a boolean
		password_bool = False
		password = "none"
		answer2 = messagebox.askquestion('Question!', 'Is the wallet without a password?')
		if answer2 == 'no':
			password = simpledialog.askstring(title="Password", prompt="Enter password:")
			password_bool = True
					
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		thedate = str(date.today())
		
		if isValid:
			new_bitcoinwallet = [USER_INP_tr, USER_INP2_tr, thedate, seed_words, seed_size, password_bool, password]
			
			if not os.path.isfile(completeName):
				f = open(completeName, 'w')
				writer = csv.writer(f)
				writer.writerow(new_bitcoinwallet)
				f.close()
			else:
				f = open(completeName, 'a')
				writer = csv.writer(f)
				writer.writerow(new_bitcoinwallet)
				f.close()
			
			completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
			f2 = open(completeName, 'a')
			
			if password_bool:
				f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Password: " + password + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
			else:
				f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
			
			f2.close()
			self.add_history("Added a new Bitcoin wallet " + USER_INP_tr + " (" + USER_INP2_tr + ")")
		else:
			messagebox.showinfo("Information", "There was a problem with the words.\n\nIt is not a valid Bitcoin wallet seed.\n\n        Please try again.")
		self.create_BitcoinWalletmeny()
	
	def createnewBitcoinwallet_PRE(self):
		global filepathdestinationfolder
		global diceFunction
		
		diceFunction = "createWallet"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
								
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="italic", underline=True, overstrike=False)
			
		Label1 = ctk.CTkLabel(my_Frame, text="Create a new Bitcoin wallet", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.08, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="italic", underline=False, overstrike=False)
		
		doStrongButton = ctk.CTkButton(my_Frame, text="Create a new Bitcoin wallet with a strong password (recommended)", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=partial(self.dicePassword, "1"))
		doStrongButton.place(relx=0.5, rely=0.32, anchor="center")
		
		doButton = ctk.CTkButton(my_Frame, text="Create a new Bitcoin wallet without password or with user defined password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=self.createnewBitcoinwallet)
		doButton.place(relx=0.5, rely=0.5, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="italic", underline=False, overstrike=False)
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Bitcoinmeny)
		backButton.place(relx=0.5, rely=0.94, anchor="center")
		
	def createnewBitcoinwallet_Strong(self, combinedValueBase58):
		global filepathdestinationfolder
		
		def add_icon(walletname):
			pathtopicture = "/home/user1/images/defaultWalletIcon.jpg"
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
			if os.path.isfile(pathtopicture):
				img_open = Image.open(pathtopicture)
				img_open.save(pathtopicturearchivelocation)
			return True
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
			
		password_bool = True
		seed_size = "12"
		password = "none"
		USER_INP = " "
		USER_INP2 = "-"
		
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%m%d%Y%H%M%S")
		USER_INP = simpledialog.askstring(title="Name required!", prompt="Name for wallet (max 30 characters:")
			
		if USER_INP == "" or USER_INP == " ":
			USER_INP = "Wallet" + timeStamp
		
		USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
		
		USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bitcoin wallet (optional):")
		
		if USER_INP2 == "" or USER_INP2 == " ":
			USER_INP2 = "-"
		
		USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
		
		password = combinedValueBase58
		
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		# Generate mnemonic from bitconlib.mnemonic module 
		mnemgenerator = bitcoinlibMnemonic()
		seed_words = bitcoinlibMnemonic().generate()
			
		thedate = str(date.today())
		
		new_bitcoinwallet = [USER_INP_tr, USER_INP2_tr, thedate, seed_words, seed_size, password_bool, password]
		
		if not os.path.isfile(completeName):
			f = open(completeName, 'w')
			writer = csv.writer(f)
			writer.writerow(new_bitcoinwallet)
			f.close()
		else:
			f = open(completeName, 'a')
			writer = csv.writer(f)
			writer.writerow(new_bitcoinwallet)
			f.close()
		
		completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
		f2 = open(completeName, 'a')
		
		if password_bool:
			f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Password: " + password + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
		else:
			f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
		
		f2.close()
		add_icon(USER_INP_tr)
			
		self.add_history("Created new Bitcoin wallet " + USER_INP_tr + " (" + USER_INP2_tr + ")")
		self.create_BitcoinWalletmeny()
		
	def createnewBitcoinwallet(self):
		global filepathdestinationfolder
		
		def add_icon(walletname):
			pathtopicture = "/home/user1/images/defaultWalletIcon.jpg"
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
			if os.path.isfile(pathtopicture):
				img_open = Image.open(pathtopicture)
				img_open.save(pathtopicturearchivelocation)
			return True
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
			
		password_bool = False
		seed_size = "12"
		password = "none"
		USER_INP = " "
		USER_INP2 = "-"
		cic = 1
		
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%m%d%Y%H%M%S")
		USER_INP = simpledialog.askstring(title="Name required!", prompt="Name for wallet (max 30 characters:")
			
		if USER_INP == "" or USER_INP == " ":
			USER_INP = "Wallet" + timeStamp
		
		USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
		
		USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bitcoin wallet (optional):")
		
		if USER_INP2 == "" or USER_INP2 == " ":
			USER_INP2 = "-"
		
		USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
		
		answer2 = messagebox.askquestion('Question!', 'Should wallet be without a password?')
		if answer2 == 'no':
			password = simpledialog.askstring(title="Password", prompt="Enter password:")
			password_bool = True
						
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		# Generate mnemonic from bitconlib.mnemonic module 
		mnemgenerator = bitcoinlibMnemonic()
		seed_words = bitcoinlibMnemonic().generate()
			
		thedate = str(date.today())
		
		new_bitcoinwallet = [USER_INP_tr, USER_INP2_tr, thedate, seed_words, seed_size, password_bool, password]
		
		if not os.path.isfile(completeName):
			f = open(completeName, 'w')
			writer = csv.writer(f)
			writer.writerow(new_bitcoinwallet)
			f.close()
		else:
			f = open(completeName, 'a')
			writer = csv.writer(f)
			writer.writerow(new_bitcoinwallet)
			f.close()
		
		completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
		f2 = open(completeName, 'a')
		
		if password_bool:
			f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Password: " + password + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
		else:
			f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + seed_words + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
		
		f2.close()
		add_icon(USER_INP_tr)
		self.add_history("Created new Bitcoin wallet " + USER_INP_tr + " (" + USER_INP2_tr + ")")
		self.create_BitcoinWalletmeny()
		
	def deleteBitcoinwallet(self, cardname):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/wallets/bitconwallets.csv"
		updatedcompleteName = str(filepathdestinationfolder) + "/secure/wallets/updatedbitconwallets.csv"
		with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[0] == cardname:
						answer = messagebox.askquestion('Important!', 'Are you sure you want to delete this Bitcoin wallet?')
						if answer == 'yes':
							self.add_history("Deleted Bitcoin wallet " + cardname)
						else:
							csvwriter.writerow(row)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updatedcompleteName, completeName)
		os.remove(updatedcompleteName)	
		self.create_BitcoinWalletmeny()
	
	def Save_xPub_to_USB(self, walletname):
		global filepathdestinationfolder
		
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines[0] == walletname:	
						mnemo = Mnemonic("english")
						if lines[5] == "False":
							seed = mnemo.to_seed(lines[3], passphrase="")
						else:
							seed = mnemo.to_seed(lines[3], passphrase=lines[6])
						
						bip32key = BIP32.from_seed(seed)
						xpub_from_path = bip32key.get_xpub_from_path("m/84'/0'/0'")
						root_xprv = bip32key.get_fingerprint().hex()
						full_Xpub = "[" + str(root_xprv) + "/" + "84'/0'/0']" + xpub_from_path
						
						result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
						if not result:
							self.showBitcoinwallet(walletname)
							return
						time.sleep(2)
						tk.messagebox.askokcancel('Information', 'Select the directory for the file.')
						if not result:
							self.showBitcoinwallet(walletname)
							return
						time.sleep(2)
						outputdir = filedialog.askdirectory(initialdir='/media/user1')
						USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
						
						c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
						c.write(full_Xpub)
						c.close()
						messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the USB-device')						
		except FileNotFoundError:
			messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		self.showBitcoinwallet(walletname)
	
	def readQRfromCamera(self, walletname):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown",
		fg_color="black"
		)
		right_Frame.place(x=300, y=2, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(right_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
			
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/wallets/transactiondatafile.psbt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQR.py'], shell=True)
		
		self.decodeQRfromCamera(walletname)
		
	def easy_readQRfromCamera(self, walletname):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")

		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1192, 642))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=4, y=4)
		
		my_font = ctk.CTkFont(family="Helvetica", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
			
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/wallets/transactiondatafile.psbt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQR.py'], shell=True)
		
		self.easy_decodeQRfromCamera(walletname)
	
	def readQRfromCameraToSign(self, fingerprint):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
		self.signQRfromCamera(fingerprint)
		
	def decodeQRfromCamera(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		file_content = ''
		comment_text = ''
		spend_amount = ''
		fee_amount = ''
		destination_addresses = ''
								
		transactionfileOK = True
		transactiondatoavailable = False
		
		def limitSizeComment_text(*args):
			value = comment_text_var.get()
			if len(value) > 30: comment_text_var.set(value[:30])
			
		def do_sign_():
			# Get the date and time for the record
			now = datetime.now() # current date and time
			timeStamp = now.strftime("%Y-%m-%d-%H:%M")
			
			# Get the comment field
			the_comment = comment_text_Entry.get()
			
			# If wallet statement file don't exist create it
			completeName = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
			
			new_wallet_transaction = [
									timeStamp,
									destination_addresses,
									the_comment,
									fee_amount,
									spend_amount]
											
			if not os.path.isfile(completeName):
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			else:
				# If wallet statement file exist add a line to it
				with open(completeName, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			
			self.decodeQRfromCamera_step2(walletname)
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown",
		fg_color="black"
		)
		right_Frame.place(x=300, y=2, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)

		QR_Frame = ctk.CTkFrame(right_Frame, 
		width=400, 
		height=400,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		QR_Frame.place(x=450, y=300, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:	
							if os.path.isfile(w_icon_path):
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								mnemonic = lines[3].split()
								passphrase = ""
								ss = Seed(mnemonic=mnemonic, passphrase=passphrase)
							else:
								mnemonic = lines[3].split()
								passphrase = str(lines[6])
								ss = Seed(mnemonic=mnemonic, passphrase=passphrase)
							
							link_to_signature_data = "/home/user1/secure/wallets/transactiondatafile.psbt"
							try:
								f = open(link_to_signature_data, "r")
								file_content = f.read()
								f.close()
								transactiondatoavailable = True
							except OSError:
								print("No file")
							
							if transactiondatoavailable and file_content != "Empty":
								transactionfileOK = True
								
								d = DecodeQR()
								d.add_data(file_content)
								tx = d.get_psbt()
								pp = PSBTParser(p=tx, seed=ss, network="main")
								
								spend_amount = -abs(pp.spend_amount)
								fee_amount = pp.fee_amount
								destination_addresses = pp.destination_addresses[0]
								
								my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=True, overstrike=False)
								mainLabel = ctk.CTkLabel(right_Frame, text="Transaction details:", text_color="orange", font=my_font, fg_color="black")
								mainLabel.place(relx=0.5, rely=0.12, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)
								amountLabel = ctk.CTkLabel(right_Frame, text="Total amount:", text_color="white", font=my_font, fg_color="black")
								amountLabel.place(relx=0.36, rely=0.22, anchor="e")
								amountvLabel = ctk.CTkLabel(right_Frame, text=spend_amount, text_color="white", font=my_font, fg_color="black")
								amountvLabel.place(relx=0.7, rely=0.22, anchor="e")
								satsLabel = ctk.CTkLabel(right_Frame, text="sats", text_color="white", font=my_font, fg_color="black")
								satsLabel.place(relx=0.71, rely=0.22, anchor="w")
								feeLabel = ctk.CTkLabel(right_Frame, text="Fee:", text_color="white", font=my_font, fg_color="black")
								feeLabel.place(relx=0.36, rely=0.28, anchor="e")
								feevLabel = ctk.CTkLabel(right_Frame, text=pp.fee_amount, text_color="white", font=my_font, fg_color="black")
								feevLabel.place(relx=0.7, rely=0.28, anchor="e")
								sats2Label = ctk.CTkLabel(right_Frame, text="sats", text_color="white", font=my_font, fg_color="black")
								sats2Label.place(relx=0.71, rely=0.28, anchor="w")
								my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
								addrLabel = ctk.CTkLabel(right_Frame, text="Receiving address:", text_color="white", font=my_font, fg_color="black")
								addrLabel.place(relx=0.36, rely=0.36, anchor="e")
								my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
								addrvLabel = ctk.CTkLabel(right_Frame, text=pp.destination_addresses[0], text_color="white", font=my_font, fg_color="black")
								addrvLabel.place(relx=0.76, rely=0.44, anchor="e")
								
								commentLabel = ctk.CTkLabel(my_Frame, text="Comment:", text_color="white", fg_color="black", font=my_font)
								commentLabel.place(relx=0.36, rely=0.54, anchor="e")
																
								comment_text_var = ctk.StringVar(value=comment_text)
								comment_text_var.trace('w', limitSizeComment_text)				
								comment_text_Entry = ctk.CTkEntry(right_Frame, placeholder_text=comment_text, textvariable=comment_text_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
								comment_text_Entry.place(relx=0.38, rely=0.54, anchor="w")
		
								my_font = ctk.CTkFont(family="Arial Black", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
								signQRButton = ctk.CTkButton(right_Frame, text="SIGN", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=200, height=34, font=my_font, command=do_sign_) 
								signQRButton.place(relx=0.5, rely=0.65, anchor="center")
							else:
								my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
								pubLabel = ctk.CTkLabel(right_Frame, text="Could not read QR-code", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.46, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
							backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
							backButton.place(relx=0.5, rely=0.96, anchor="center")
							if lines[5] == "True":
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.97, anchor="e")
							else:
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel5 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel5.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel6 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel6.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel7 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel7.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel8 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel8.place(relx=0.95, rely=0.97, anchor="e")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def easy_decodeQRfromCamera(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		file_content = ''
		comment_text = ''
		spend_amount = ''
		fee_amount = ''
		destination_addresses = ''
								
		transactionfileOK = True
		transactiondatoavailable = False
		
		def limitSizeComment_text(*args):
			value = comment_text_var.get()
			if len(value) > 30: comment_text_var.set(value[:30])
			
		def do_sign_():
			# Get the date and time for the record
			now = datetime.now() # current date and time
			timeStamp = now.strftime("%Y-%m-%d-%H:%M")
			
			# Get the comment field
			the_comment = comment_text_Entry.get()
			
			# If wallet statement file don't exist create it
			completeName = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
			
			new_wallet_transaction = [
									timeStamp,
									destination_addresses,
									the_comment,
									fee_amount,
									spend_amount]
											
			if not os.path.isfile(completeName):
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			else:
				# If wallet statement file exist add a line to it
				with open(completeName, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			
			self.easy_decodeQRfromCamera_step2(walletname)
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")

		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1192, 642))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=4, y=4)

		QR_Frame = ctk.CTkFrame(my_Frame, 
		width=400, 
		height=400,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		QR_Frame.place(x=600, y=300, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:								
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								mnemonic = lines[3].split()
								passphrase = ""
								ss = Seed(mnemonic=mnemonic, passphrase=passphrase)
							else:
								mnemonic = lines[3].split()
								passphrase = str(lines[6])
								ss = Seed(mnemonic=mnemonic, passphrase=passphrase)
							
							link_to_signature_data = "/home/user1/secure/wallets/transactiondatafile.psbt"
							try:
								f = open(link_to_signature_data, "r")
								file_content = f.read()
								f.close()
								transactiondatoavailable = True
							except OSError:
								print("No file")
							
							if transactiondatoavailable and file_content != "Empty":
								transactionfileOK = True
								
								d = DecodeQR()
								d.add_data(file_content)
								tx = d.get_psbt()
								pp = PSBTParser(p=tx, seed=ss, network="main")
								
								spend_amount = -abs(pp.spend_amount)
								fee_amount = pp.fee_amount
								destination_addresses = pp.destination_addresses[0]
								
								my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=True, overstrike=False)
								mainLabel = ctk.CTkLabel(my_Frame, text="Transaction details:", text_color="orange", font=my_font, fg_color="black")
								mainLabel.place(relx=0.5, rely=0.12, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)
								amountLabel = ctk.CTkLabel(my_Frame, text="Total amount:", text_color="white", font=my_font, fg_color="black")
								amountLabel.place(relx=0.36, rely=0.22, anchor="e")
								amountvLabel = ctk.CTkLabel(my_Frame, text=spend_amount, text_color="white", font=my_font, fg_color="black")
								amountvLabel.place(relx=0.7, rely=0.22, anchor="e")
								satsLabel = ctk.CTkLabel(my_Frame, text="sats", text_color="white", font=my_font, fg_color="black")
								satsLabel.place(relx=0.71, rely=0.22, anchor="w")
								feeLabel = ctk.CTkLabel(my_Frame, text="Fee:", text_color="white", font=my_font, fg_color="black")
								feeLabel.place(relx=0.36, rely=0.28, anchor="e")
								feevLabel = ctk.CTkLabel(my_Frame, text=pp.fee_amount, text_color="white", font=my_font, fg_color="black")
								feevLabel.place(relx=0.7, rely=0.28, anchor="e")
								sats2Label = ctk.CTkLabel(my_Frame, text="sats", text_color="white", font=my_font, fg_color="black")
								sats2Label.place(relx=0.71, rely=0.28, anchor="w")
								my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
								addrLabel = ctk.CTkLabel(my_Frame, text="Receiving address:", text_color="white", font=my_font, fg_color="black")
								addrLabel.place(relx=0.36, rely=0.36, anchor="e")
								my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
								addrvLabel = ctk.CTkLabel(my_Frame, text=pp.destination_addresses[0], text_color="white", font=my_font, fg_color="black")
								addrvLabel.place(relx=0.76, rely=0.44, anchor="e")
								
								commentLabel = ctk.CTkLabel(my_Frame, text="Comment:", text_color="white", fg_color="black", font=my_font)
								commentLabel.place(relx=0.36, rely=0.54, anchor="e")
																
								comment_text_var = ctk.StringVar(value=comment_text)
								comment_text_var.trace('w', limitSizeComment_text)				
								comment_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=comment_text, textvariable=comment_text_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
								comment_text_Entry.place(relx=0.38, rely=0.54, anchor="w")
		
								my_font = ctk.CTkFont(family="Arial Black", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
								signQRButton = ctk.CTkButton(my_Frame, text="SIGN", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=200, height=34, font=my_font, command=do_sign_) 
								signQRButton.place(relx=0.5, rely=0.65, anchor="center")
							else:
								my_font = ctk.CTkFont(family="Arial", size=32, slant="roman", underline=False, overstrike=False)
								pubLabel = ctk.CTkLabel(my_Frame, text="Could not read QR-code", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.46, anchor="center")	
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
			
	def decodeQRfromCamera_step2(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		global cnt
		file_content = ''
		transactionfileOK = True
		transactiondatoavailable = False
		
		def save_signature_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the signature file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (file type \".psbt\" will be added automatically):")
				
			c = open(outputdir + '/' + USER_INP + '.psbt', 'w', encoding='utf-8')
			c.write(file_content)
			c.close()
			messagebox.showinfo('Information', 'Signature file \"' +USER_INP + '.psbt\"' + ' has been saved.')
			self.showBitcoinwallet(walletname)
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown",
		fg_color="black"
		)
		right_Frame.place(x=300, y=2, anchor="nw")

		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)

		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:	
							if os.path.isfile(w_icon_path):
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								mnemonic = lines[3]
								password = ""
							else:
								mnemonic = lines[3]
								password = str(lines[6])
							
							link_to_signature_data = "/home/user1/secure/wallets/transactiondatafile.psbt"
							try:
								f = open(link_to_signature_data, "r")
								file_content = f.read()
								f.close()
								transactiondatoavailable = True
							except OSError:
								print("No file")
							
							onemoreButton = ctk.CTkButton(right_Frame, text="Sign another", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.readQRfromCamera, walletname))
							onemoreButton.place(relx=0.5, rely=0.89, anchor="center")
							backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
							backButton.place(relx=0.5, rely=0.96, anchor="center")
							if lines[5] == "True":
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.97, anchor="e")
							else:
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel5 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel5.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel6 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel6.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel7 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel7.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel8 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel8.place(relx=0.95, rely=0.97, anchor="e")
								
							if transactiondatoavailable and file_content != "Empty":
								transactionfileOK = True
								
								d = DecodeQR()
								
								d.add_data(file_content)
								tx_str = str(d.get_psbt())
								
								seed = bip39.mnemonic_to_seed(mnemonic, password=password)
								root = bip32.HDKey.from_seed(seed, version=NETWORKS["main"]["xprv"])
								
								raw = a2b_base64(tx_str)
								tx2 = psbt.PSBT.parse(raw)
								
								tx2.sign_with(root)
								raw = tx2.serialize()
								
								b64_psbt = b2a_base64(raw)
								
								if b64_psbt[-1:] == b"\n":
									b64_psbt = b64_psbt[:-1]
								
								signed_psbt = b64_psbt.decode("utf-8")
								
								tx_e = psbt.PSBT.parse(a2b_base64(signed_psbt))
								
								e = UrPsbtQrEncoder(psbt=tx_e, qr_density=SettingsConstants.DENSITY__HIGH)
								
								ar_signed_psbt = a2b_base64(signed_psbt)
								ur = make_message_ur(380, ar_signed_psbt)
								encoded_ur = UREncoder.encode(ur)
								
								my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=True, overstrike=False)
								pubLabel = ctk.CTkLabel(right_Frame, text="Signature:", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.06, anchor="center")
									
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
								saveQRButton = ctk.CTkButton(right_Frame, text="Save signature to USB", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=save_signature_to_USB)
								saveQRButton.place(relx=0.5, rely=0.8, anchor="center")
				
								cnt = 0
								# Now to QR encode it for animated QR display
								self.QR_slides(right_Frame, e, walletname)
	
							else:
								my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
								pubLabel = ctk.CTkLabel(right_Frame, text="Could not read QR-code", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.46, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def easy_decodeQRfromCamera_step2(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		global cnt, Boltcard_button_color
		file_content = ''
		transactionfileOK = True
		transactiondatoavailable = False
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")

		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1192, 642))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=4, y=4)

		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:
							
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								mnemonic = lines[3]
								password = ""
							else:
								mnemonic = lines[3]
								password = str(lines[6])
							
							link_to_signature_data = "/home/user1/secure/wallets/transactiondatafile.psbt"
							try:
								f = open(link_to_signature_data, "r")
								file_content = f.read()
								f.close()
								transactiondatoavailable = True
							except OSError:
								print("No file")
							
							if transactiondatoavailable and file_content != "Empty":
								transactionfileOK = True
								
								d = DecodeQR()
								
								d.add_data(file_content)
								tx_str = str(d.get_psbt())
								
								seed = bip39.mnemonic_to_seed(mnemonic, password=password)
								root = bip32.HDKey.from_seed(seed, version=NETWORKS["main"]["xprv"])
								
								raw = a2b_base64(tx_str)
								tx2 = psbt.PSBT.parse(raw)
								
								tx2.sign_with(root)
								raw = tx2.serialize()
								
								b64_psbt = b2a_base64(raw)
								
								if b64_psbt[-1:] == b"\n":
									b64_psbt = b64_psbt[:-1]
								
								signed_psbt = b64_psbt.decode("utf-8")
								
								tx_e = psbt.PSBT.parse(a2b_base64(signed_psbt))
								
								e = UrPsbtQrEncoder(psbt=tx_e, qr_density=SettingsConstants.DENSITY__HIGH)
								
								ar_signed_psbt = a2b_base64(signed_psbt)
								ur = make_message_ur(380, ar_signed_psbt)
								encoded_ur = UREncoder.encode(ur)
								
								my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=True, overstrike=False)
								pubLabel = ctk.CTkLabel(my_Frame, text="Signature:", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.06, anchor="center")
									
								cnt = 0
								# Now to QR encode it for animated QR display
								self.easy_QR_slides(my_Frame, e, walletname)
	
							else:
								my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
								pubLabel = ctk.CTkLabel(my_Frame, text="Could not read QR-code", text_color="white", font=my_font, fg_color="black")
								pubLabel.place(relx=0.5, rely=0.46, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)
							backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=250, height=55, font=my_font, command=partial(self.showBitcoinwallet, walletname))
							backButton.place(relx=0.5, rely=0.82, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
			
	def QR_slides(self, right_Frame, e, walletname):
		global cnt
		
		QR_Frame = ctk.CTkFrame(right_Frame, 
		width=400, 
		height=400,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
										
		if cnt <= 30:
			QR_Frame.place(x=450, y=300, anchor="center")
			
			fragment = e.next_part()
			
			pathtosignature = qrcode.make(fragment)
			resize_pathtosignature = pathtosignature.resize((396, 396))
			link_pathtosignature = str(filepathdestinationfolder) + "/secure/wallets/signature.png"
			
			resize_pathtosignature.save(link_pathtosignature)
			
			loadimg = ctk.CTkImage(light_image=Image.open(link_pathtosignature), dark_image=Image.open(link_pathtosignature), size=(396, 396))
			Labelpublicimg = ctk.CTkLabel(QR_Frame,  text = "", image = loadimg)
			Labelpublicimg.place(relx=0.5, rely=0.49, anchor="center")
			
			cnt += 1
			
			self.update_idletasks()
			time.sleep(0.4)
			self.after(30, self.QR_slides(right_Frame, e, walletname))
		else:
			QR_Frame.place(x=450, y=300, anchor="center")
			
			backButton = ctk.CTkButton(QR_Frame, text="Try Again", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.decodeQRfromCamera_step2, walletname))
			backButton.place(relx=0.5, rely=0.48, anchor="center")
	
	def easy_QR_slides(self, my_Frame, e, walletname):
		global cnt
		global Boltcard_button_color
		
		QR_Frame = ctk.CTkFrame(my_Frame, 
		width=400, 
		height=400,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
										
		if cnt <= 30:
			QR_Frame.place(x=600, y=300, anchor="center")
			
			fragment = e.next_part()
			
			pathtosignature = qrcode.make(fragment)
			resize_pathtosignature = pathtosignature.resize((396, 396))
			link_pathtosignature = str(filepathdestinationfolder) + "/secure/wallets/signature.png"
			
			resize_pathtosignature.save(link_pathtosignature)
			
			loadimg = ctk.CTkImage(light_image=Image.open(link_pathtosignature), dark_image=Image.open(link_pathtosignature), size=(396, 396))
			Labelpublicimg = ctk.CTkLabel(QR_Frame,  text = "", image = loadimg)
			Labelpublicimg.place(relx=0.5, rely=0.49, anchor="center")
			
			cnt += 1
			
			self.update_idletasks()
			time.sleep(0.4)
			self.after(30, self.easy_QR_slides(my_Frame, e, walletname))
		else:
			QR_Frame.place(x=600, y=300, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)
		
			backButton = ctk.CTkButton(QR_Frame, text="Try Again", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=250, height=55, font=my_font, command=partial(self.easy_decodeQRfromCamera_step2, walletname))
			backButton.place(relx=0.5, rely=0.48, anchor="center")
									
	def showXpub(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
						
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown",
		fg_color="black"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:
							if os.path.isfile(w_icon_path):	
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=230, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								seed = mnemo.to_seed(lines[3], passphrase="")
							else:
								seed = mnemo.to_seed(lines[3], passphrase=lines[6])
							
							bip32key = BIP32.from_seed(seed)
							xpub_from_path = bip32key.get_xpub_from_path("m/84'/0'/0'")
							root_xprv = bip32key.get_fingerprint().hex()
							full_Xpub = "[" + str(root_xprv) + "/" + "84'/0'/0']" + xpub_from_path
							load_address = qrcode.make(full_Xpub)
							
							resize_load_address = load_address.resize((300, 300))
							pathtoloadaddress = str(filepathdestinationfolder) + "/secure/wallets/walletseed.png"
							
							resize_load_address.save(pathtoloadaddress)
							
							loadimg = ctk.CTkImage(light_image=Image.open(pathtoloadaddress), dark_image=Image.open(pathtoloadaddress), size=(300, 300))
									
							my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
							nameLabel = ctk.CTkLabel(right_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							nameLabel.place(relx=0.5, rely=0.08, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
							pubLabel = ctk.CTkLabel(right_Frame, text="Xpub:", text_color="white", font=my_font, fg_color="black")
							pubLabel.place(relx=0.5, rely=0.14, anchor="center")
							Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = loadimg)
							Labelpublicimg.place(relx=0.5, rely=0.45, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=12, slant="roman", underline=False, overstrike=False)								
							descrLabel = ctk.CTkLabel(right_Frame, text=xpub_from_path, text_color="white", font=my_font, fg_color="black")
							descrLabel.place(relx=0.5, rely=0.75, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
							derivationLabel = ctk.CTkLabel(right_Frame, text="Derivation path: m/84'/0'/0' (native segwit/singlesig)", text_color="white", font=my_font, fg_color="black")
							derivationLabel.place(relx=0.5, rely=0.8, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
							saveQRButton = ctk.CTkButton(right_Frame, text="Save Xpub to USB", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.Save_xPub_to_USB, walletname))
							saveQRButton.place(relx=0.49, rely=0.86, anchor="e")
							copy_button = ctk.CTkButton(right_Frame, text="Copy to clipboard", text_color="black", fg_color="orange", border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, xpub_from_path))
							copy_button.place(relx=0.51, rely=0.86, anchor="w")
							backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
							backButton.place(relx=0.5, rely=0.94, anchor="center")
							
							if lines[5] == "True":
								my_font = ctk.CTkFont(family="Arial", size=14, weight="bold", slant="roman", underline=True, overstrike=False)
								passwordLabel3 = ctk.CTkLabel(right_Frame, text="External Seed signers need option to ask for passphrase activated!", text_color="orange", font=my_font, fg_color="black")
								passwordLabel3.place(relx=0.5, rely=0.02, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.97, anchor="e")
							else:
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel5 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel5.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel6 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel6.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel7 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel7.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel8 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel8.place(relx=0.95, rely=0.97, anchor="e")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def showWalletSeed(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		
		passw = ''
		messagedata = []			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:	
							my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
							nameLabel = ctk.CTkLabel(right_Frame, text="Seed for: " + lines[0], text_color="white", font=my_font, fg_color="black")
							nameLabel.place(relx=0.5, rely=0.05, anchor="center")
							
							if lines[5] != "False":
								messagedata = ['wallet', lines[3], lines[6]] 
								my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
								passwordLabel = ctk.CTkLabel(right_Frame, text="Passphrase: " + lines[6], text_color="white", font=my_font, fg_color="black")
								passwordLabel.place(relx=0.5, rely=0.1, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.97, anchor="e")
								
								secret_words = lines[3] + ' ' + lines[6]
								mnemonic_list = secret_words.split()
							else:
								messagedata = ['wallet', lines[3], '_none_'] 
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.05, rely=0.97, anchor="w")
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.95, rely=0.03, anchor="e")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.97, anchor="e")
								mnemonic_list = lines[3].split()
							
							if os.path.isfile(w_icon_path):	
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=230, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							# Print out the seed words
							my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)
							if lines[4] == "12":
								seed1 = ctk.CTkLabel(right_Frame, text=mnemonic_list[0], text_color="white", font=my_font, fg_color="black")
								seed1.place(relx=0.36, rely=0.26, anchor="center")
								seed2 = ctk.CTkLabel(right_Frame, text=mnemonic_list[1], text_color="white", font=my_font, fg_color="black")
								seed2.place(relx=0.36, rely=0.34, anchor="center")
								seed3 = ctk.CTkLabel(right_Frame, text=mnemonic_list[2], text_color="white", font=my_font, fg_color="black")
								seed3.place(relx=0.36, rely=0.42, anchor="center")
								seed4 = ctk.CTkLabel(right_Frame, text=mnemonic_list[3], text_color="white", font=my_font, fg_color="black")
								seed4.place(relx=0.36, rely=0.5, anchor="center")
								seed5 = ctk.CTkLabel(right_Frame, text=mnemonic_list[4], text_color="white", font=my_font, fg_color="black")
								seed5.place(relx=0.36, rely=0.58, anchor="center")
								seed6 = ctk.CTkLabel(right_Frame, text=mnemonic_list[5], text_color="white", font=my_font, fg_color="black")
								seed6.place(relx=0.36, rely=0.66, anchor="center")
								seed7 = ctk.CTkLabel(right_Frame, text=mnemonic_list[6], text_color="white", font=my_font, fg_color="black")
								seed7.place(relx=0.64, rely=0.26, anchor="center")
								seed8 = ctk.CTkLabel(right_Frame, text=mnemonic_list[7], text_color="white", font=my_font, fg_color="black")
								seed8.place(relx=0.64, rely=0.34, anchor="center")
								seed9 = ctk.CTkLabel(right_Frame, text=mnemonic_list[8], text_color="white", font=my_font, fg_color="black")
								seed9.place(relx=0.64, rely=0.42, anchor="center")
								seed10 = ctk.CTkLabel(right_Frame, text=mnemonic_list[9], text_color="white", font=my_font, fg_color="black")
								seed10.place(relx=0.64, rely=0.5, anchor="center")
								seed11 = ctk.CTkLabel(right_Frame, text=mnemonic_list[10], text_color="white", font=my_font, fg_color="black")
								seed11.place(relx=0.64, rely=0.58, anchor="center")
								seed12 = ctk.CTkLabel(right_Frame, text=mnemonic_list[11], text_color="white", font=my_font, fg_color="black")
								seed12.place(relx=0.64, rely=0.66, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
								seedQRButton = ctk.CTkButton(right_Frame, text="Show SeedQR", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showWalletSeedQR, lines[0]))
								seedQRButton.place(relx=0.5, rely=0.8, anchor="center")
								exportSeedButton = ctk.CTkButton(right_Frame, text="Export Seed", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.encrypt_message, messagedata))
								exportSeedButton.place(relx=0.7, rely=0.8, anchor="center")
								backButton = ctk.CTkButton(right_Frame, text="Close", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								backButton.place(relx=0.5, rely=0.86, anchor="center")
							else:
								seed1 = ctk.CTkLabel(right_Frame, text=mnemonic_list[0], text_color="white", font=my_font, fg_color="black")
								seed1.place(relx=0.36, rely=0.16, anchor="center")
								seed2 = ctk.CTkLabel(right_Frame, text=mnemonic_list[1], text_color="white", font=my_font, fg_color="black")
								seed2.place(relx=0.36, rely=0.22, anchor="center")
								seed3 = ctk.CTkLabel(right_Frame, text=mnemonic_list[2], text_color="white", font=my_font, fg_color="black")
								seed3.place(relx=0.36, rely=0.28, anchor="center")
								seed4 = ctk.CTkLabel(right_Frame, text=mnemonic_list[3], text_color="white", font=my_font, fg_color="black")
								seed4.place(relx=0.36, rely=0.34, anchor="center")
								seed5 = ctk.CTkLabel(right_Frame, text=mnemonic_list[4], text_color="white", font=my_font, fg_color="black")
								seed5.place(relx=0.36, rely=0.4, anchor="center")
								seed6 = ctk.CTkLabel(right_Frame, text=mnemonic_list[5], text_color="white", font=my_font, fg_color="black")
								seed6.place(relx=0.36, rely=0.46, anchor="center")
								seed7 = ctk.CTkLabel(right_Frame, text=mnemonic_list[6], text_color="white", font=my_font, fg_color="black")
								seed7.place(relx=0.36, rely=0.52, anchor="center")
								seed8 = ctk.CTkLabel(right_Frame, text=mnemonic_list[7], text_color="white", font=my_font, fg_color="black")
								seed8.place(relx=0.36, rely=0.58, anchor="center")
								seed9 = ctk.CTkLabel(right_Frame, text=mnemonic_list[8], text_color="white", font=my_font, fg_color="black")
								seed9.place(relx=0.36, rely=0.64, anchor="center")
								seed10 = ctk.CTkLabel(right_Frame, text=mnemonic_list[9], text_color="white", font=my_font, fg_color="black")
								seed10.place(relx=0.36, rely=0.7, anchor="center")
								seed11 = ctk.CTkLabel(right_Frame, text=mnemonic_list[10], text_color="white", font=my_font, fg_color="black")
								seed11.place(relx=0.36, rely=0.76, anchor="center")
								seed12 = ctk.CTkLabel(right_Frame, text=mnemonic_list[11], text_color="white", font=my_font, fg_color="black")
								seed12.place(relx=0.36, rely=0.82, anchor="center")
								seed13 = ctk.CTkLabel(right_Frame, text=mnemonic_list[12], text_color="white", font=my_font, fg_color="black")
								seed13.place(relx=0.64, rely=0.16, anchor="center")
								seed14 = ctk.CTkLabel(right_Frame, text=mnemonic_list[13], text_color="white", font=my_font, fg_color="black")
								seed14.place(relx=0.64, rely=0.22, anchor="center")
								seed15 = ctk.CTkLabel(right_Frame, text=mnemonic_list[14], text_color="white", font=my_font, fg_color="black")
								seed15.place(relx=0.64, rely=0.28, anchor="center")
								seed16 = ctk.CTkLabel(right_Frame, text=mnemonic_list[15], text_color="white", font=my_font, fg_color="black")
								seed16.place(relx=0.64, rely=0.34, anchor="center")
								seed17 = ctk.CTkLabel(right_Frame, text=mnemonic_list[16], text_color="white", font=my_font, fg_color="black")
								seed17.place(relx=0.64, rely=0.4, anchor="center")
								seed18 = ctk.CTkLabel(right_Frame, text=mnemonic_list[17], text_color="white", font=my_font, fg_color="black")
								seed18.place(relx=0.64, rely=0.46, anchor="center")
								seed19 = ctk.CTkLabel(right_Frame, text=mnemonic_list[18], text_color="white", font=my_font, fg_color="black")
								seed19.place(relx=0.64, rely=0.52, anchor="center")
								seed20 = ctk.CTkLabel(right_Frame, text=mnemonic_list[19], text_color="white", font=my_font, fg_color="black")
								seed20.place(relx=0.64, rely=0.58, anchor="center")
								seed21 = ctk.CTkLabel(right_Frame, text=mnemonic_list[20], text_color="white", font=my_font, fg_color="black")
								seed21.place(relx=0.64, rely=0.64, anchor="center")
								seed22 = ctk.CTkLabel(right_Frame, text=mnemonic_list[21], text_color="white", font=my_font, fg_color="black")
								seed22.place(relx=0.64, rely=0.7, anchor="center")
								seed23 = ctk.CTkLabel(right_Frame, text=mnemonic_list[22], text_color="white", font=my_font, fg_color="black")
								seed23.place(relx=0.64, rely=0.76, anchor="center")
								seed24 = ctk.CTkLabel(right_Frame, text=mnemonic_list[23], text_color="white", font=my_font, fg_color="black")
								seed24.place(relx=0.64, rely=0.82, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
								seedQRButton = ctk.CTkButton(right_Frame, text="Show SeedQR", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showWalletSeedQR, lines[0]))
								seedQRButton.place(relx=0.5, rely=0.9, anchor="center")
								
								exportSeedButton = ctk.CTkButton(right_Frame, text="Export Seed", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.encrypt_message, messagedata))
								exportSeedButton.place(relx=0.7, rely=0.9, anchor="center")
								
								backButton = ctk.CTkButton(right_Frame, text="Close", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								backButton.place(relx=0.5, rely=0.96, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def showWalletSeedQR(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		
		def mnemonic_seed_to_binary(seedphrase):
			index = decode_phrase(seedphrase)
			return index
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:	
							# Print out the seedQR
							load_address = qrcode.make(mnemonic_seed_to_binary(lines[3]))
								
							resize_load_address = load_address.resize((270, 270))
							pathtoloadaddress = str(filepathdestinationfolder) + "/secure/wallets/walletseed.png"
							
							resize_load_address.save(pathtoloadaddress)
							
							loadimg = ctk.CTkImage(light_image=Image.open(pathtoloadaddress), dark_image=Image.open(pathtoloadaddress), size=(270, 270))
							
							my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
							nameLabel = ctk.CTkLabel(right_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							nameLabel.place(relx=0.5, rely=0.08, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
							pubLabel = ctk.CTkLabel(right_Frame, text="SeedQR:", text_color="white", font=my_font, fg_color="black")
							pubLabel.place(relx=0.5, rely=0.21, anchor="center")
							Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = loadimg)
							Labelpublicimg.place(relx=0.5, rely=0.47, anchor="center")
							my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
							
							my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
							warningLabel1 = ctk.CTkLabel(right_Frame, text="!!! ONLY SCAN", text_color="white", font=my_font, fg_color="black")
							warningLabel1.place(relx=0.2, rely=0.40, anchor="center")
							warningLabel2 = ctk.CTkLabel(right_Frame, text="WITH AIR-GAPPED", text_color="white", font=my_font, fg_color="black")
							warningLabel2.place(relx=0.2, rely=0.45, anchor="center")
							warningLabel3 = ctk.CTkLabel(right_Frame, text="SIGNING DEVICE !!!", text_color="white", font=my_font, fg_color="black")
							warningLabel3.place(relx=0.2, rely=0.50, anchor="center")
							warningLabel4 = ctk.CTkLabel(right_Frame, text="!!! ONLY SCAN", text_color="white", font=my_font, fg_color="black")
							warningLabel4.place(relx=0.8, rely=0.40, anchor="center")
							warningLabel5 = ctk.CTkLabel(right_Frame, text="WITH AIR-GAPPED", text_color="white", font=my_font, fg_color="black")
							warningLabel5.place(relx=0.8, rely=0.45, anchor="center")
							warningLabel6 = ctk.CTkLabel(right_Frame, text="SIGNING DEVICE !!!", text_color="white", font=my_font, fg_color="black")
							warningLabel6.place(relx=0.8, rely=0.50, anchor="center")
							
							if lines[5] != "False":
								my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
								passwordLabel = ctk.CTkLabel(right_Frame, text="Passphrase: " + lines[6], text_color="white", font=my_font, fg_color="black")
								passwordLabel.place(relx=0.5, rely=0.13, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								passwordLabel3 = ctk.CTkLabel(right_Frame, text="External Seed signers need option to ask for passphrase activated!", text_color="orange", font=my_font, fg_color="black")
								passwordLabel3.place(relx=0.5, rely=0.02, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel2.place(relx=0.95, rely=0.03, anchor="e")
								secret_words = lines[3] + ' ' + lines[6]
								mnemonic_list = secret_words.split()
							else:
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
								bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel3.place(relx=0.05, rely=0.03, anchor="w")
								bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
								bitcoinLabel4.place(relx=0.95, rely=0.03, anchor="e")
								mnemonic_list = lines[3].split()
								
							if os.path.isfile(w_icon_path):
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
							backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showWalletSeed, lines[0]))
							backButton.place(relx=0.5, rely=0.94, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
			
	def showBitcoinwallet(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		global walletDescription
		global owners_name
		global walletReference
		global ownerAddr1
		global ownerAddr2
		
		layout = "Standard"
		
		def mnemonic_seed_to_binary(seedphrase):
			index = decode_phrase(seedphrase)
			return index
		
		def get_wallet_owner_information_if_any():
			global walletDescription
			global walletReference
			global owners_name
			global ownerAddr1
			global ownerAddr2
			
			completeName = str(filepathdestinationfolder) + "/secure/wallets/" + walletname + ".csv"

			# Check if file exists.
			if not os.path.isfile(completeName):
				return False
			else:
				try:
					f = open(completeName, 'r')
					for row in csv.reader(f):
						walletDescription = row[0]
						walletReference = row[1]
						owners_name = row[2]
						ownerAddr1 = row[3]
						ownerAddr2 = row[4]
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No wallet information file found.")
				if walletDescription != '' or walletReference != '' or owners_name != '' or ownerAddr1 != '' or ownerAddr2 != '': 
					return True	
			return False
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		completeName = filepathdestinationfolder + "/secure/layout.csv"
		if not os.path.isfile(completeName):
			layout = ['Standard']
			
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				csvwriter.writerow(layout)
		else:
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							layout = lines[0]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No layout file found.")
				
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		
		gc.collect()
		
		if path_to_USB_secure == 'Secure USB folder is available':
			if os.path.isfile(w_icon_path):
				pathtoWalletIconimage = w_icon_path
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
			else:
				pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
				walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:	
							if os.path.isfile(w_icon_path):
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
							else:
								Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, lines[0]))
								Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
							Llabel1 = ctk.CTkLabel(left_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
							Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
							
							mnemo = Mnemonic("english")
							isValid = mnemo.check(lines[3]) # returns a boolean
							
							if isValid:
								my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
								nameLabel = ctk.CTkLabel(right_Frame, text=lines[0], text_color="white", font=my_font, fg_color="black")
								nameLabel.place(relx=0.5, rely=0.07, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
								
								pathtoicon = filepathdestinationfolder + "/secure/wallets/" + walletname + '.jpg'
								pathtoinfo = str(filepathdestinationfolder) + "/secure/wallets/" + walletname + ".csv"
								
								valid_info = get_wallet_owner_information_if_any()
								
								# Check if there is both an icon and an information
								if os.path.isfile(pathtoicon) and os.path.isfile(pathtoinfo) and valid_info:
									icon_placement = 0.4
									text_placement = 0.55
									
									if len(walletDescription) > 25 or len(walletReference) > 25 or len(owners_name) > 25 or len(ownerAddr1) > 25 or len(ownerAddr2) > 25:
										icon_placement = 0.3
										text_placement = 0.45
									iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(230, 230))
									
									Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=partial(self.editWalletInformation, walletname))
									Buttonicon.place(relx=icon_placement, rely=0.3, anchor="center")
									
									descrLabel = ctk.CTkLabel(right_Frame, text=walletDescription, text_color="white", font=my_font, fg_color="black")
									descrLabel.place(relx=text_placement, rely=0.22, anchor="w")
									refLabel = ctk.CTkLabel(right_Frame, text=walletReference, text_color="white", font=my_font, fg_color="black")
									refLabel.place(relx=text_placement, rely=0.27, anchor="w")
									nameLabel = ctk.CTkLabel(right_Frame, text=owners_name, text_color="white", font=my_font, fg_color="black")
									nameLabel.place(relx=text_placement, rely=0.32, anchor="w")
									addrLabel = ctk.CTkLabel(right_Frame, text=ownerAddr1, text_color="white", font=my_font, fg_color="black")
									addrLabel.place(relx=text_placement, rely=0.37, anchor="w")
									addr2Label = ctk.CTkLabel(right_Frame, text=ownerAddr2, text_color="white", font=my_font, fg_color="black")
									addr2Label.place(relx=text_placement, rely=0.42, anchor="w")
									showQRButton = ctk.CTkButton(right_Frame, text="Edit wallet information", text_color="black", fg_color="forest green", border_width=2, border_color="white", width=220, height=32, font=my_font, command=partial(self.editWalletInformation, walletname))
									showQRButton.place(relx=0.5, rely=0.55, anchor="center")
								elif os.path.isfile(pathtoicon):
									iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(230, 230))
									Buttonicon = ctk.CTkButton(right_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=230, height=230, font=my_font, command=partial(self.editWalletInformation, walletname))
									Buttonicon.place(relx=0.5, rely=0.3, anchor="center")
									showQRButton = ctk.CTkButton(right_Frame, text="Edit wallet information", text_color="black", fg_color="forest green", border_width=2, border_color="white", width=220, height=32, font=my_font, command=partial(self.editWalletInformation, walletname))
									showQRButton.place(relx=0.5, rely=0.55, anchor="center")
								elif os.path.isfile(pathtoinfo) and valid_info:
									get_wallet_owner_information_if_any()
									descrLabel = ctk.CTkLabel(right_Frame, text=walletDescription, text_color="white", font=my_font, fg_color="black")
									descrLabel.place(relx=0.5, rely=0.22, anchor="center")
									refLabel = ctk.CTkLabel(right_Frame, text=walletReference, text_color="white", font=my_font, fg_color="black")
									refLabel.place(relx=0.5, rely=0.28, anchor="center")
									nameLabel = ctk.CTkLabel(right_Frame, text=owners_name, text_color="white", font=my_font, fg_color="black")
									nameLabel.place(relx=0.5, rely=0.32, anchor="center")
									addrLabel = ctk.CTkLabel(right_Frame, text=ownerAddr1, text_color="white", font=my_font, fg_color="black")
									addrLabel.place(relx=0.5, rely=0.37, anchor="center")
									addr2Label = ctk.CTkLabel(right_Frame, text=ownerAddr2, text_color="white", font=my_font, fg_color="black")
									addr2Label.place(relx=0.5, rely=0.42, anchor="center")
									showQRButton = ctk.CTkButton(right_Frame, text="Edit wallet information", text_color="black", fg_color="forest green", border_width=2, border_color="white", width=220, height=32, font=my_font, command=partial(self.editWalletInformation, walletname))
									showQRButton.place(relx=0.5, rely=0.55, anchor="center")
								else:		
									# If no wallet details
									showQRButton = ctk.CTkButton(right_Frame, text="Edit wallet information", text_color="black", fg_color="forest green", border_width=2, border_color="white", width=220, height=32, font=my_font, command=partial(self.editWalletInformation, walletname))
									showQRButton.place(relx=0.5, rely=0.35, anchor="center")
								
								showQRButton = ctk.CTkButton(right_Frame, text="Show Seed", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=260, height=32, font=my_font, command=partial(self.showWalletSeed, walletname))
								showQRButton.place(relx=0.35, rely=0.62, anchor="center")
								
								showStatementButton = ctk.CTkButton(right_Frame, text="Show Statement", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=260, height=32, font=my_font, command=partial(self.showWalletStatement, walletname))
								showStatementButton.place(relx=0.65, rely=0.62, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
								dateheadLabel = ctk.CTkLabel(right_Frame, text="Description:", text_color="white", font=my_font, fg_color="black")
								dateheadLabel.place(relx=0.5, rely=0.68, anchor="center")
								my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)								
								descrLabel = ctk.CTkLabel(right_Frame, text=lines[1], text_color="white", font=my_font, fg_color="black")
								descrLabel.place(relx=0.5, rely=0.73, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
								dateheadLabel = ctk.CTkLabel(right_Frame, text="Created:  " + lines[2], text_color="white", font=my_font, fg_color="black")
								dateheadLabel.place(relx=0.5, rely=0.78, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
								delButton = ctk.CTkButton(right_Frame, text="Delete Wallet", text_color="white", fg_color="brown", border_width=2, border_color="white", width=200, height=34, font=my_font, command=partial(self.deleteBitcoinwallet, walletname))
								delButton.place(relx=0.25, rely=0.86, anchor="center")
								xpubButton = ctk.CTkButton(right_Frame, text="Show Xpub", text_color="black", fg_color="orange", border_width=2, border_color="white", width=200, height=34, font=my_font, command=partial(self.showXpub, walletname))
								xpubButton.place(relx=0.5, rely=0.86, anchor="center")
								
								signQRButton = ctk.CTkButton(right_Frame, text="Sign a transaction", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=200, height=32, font=my_font, command=partial(self.readQRfromCamera, walletname))
								signQRButton.place(relx=0.75, rely=0.86, anchor="center")
								signMsgButton = ctk.CTkButton(right_Frame, text="Sign a message", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=200, height=32, font=my_font, command=partial(self.signBitcoinMessage, walletname))
								signMsgButton.place(relx=0.75, rely=0.94, anchor="center")
								
								if layout == 'Easy':
									backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.easy_show_Bitcoin_wallets)
									backButton.place(relx=0.5, rely=0.94, anchor="center")
								else:
									backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
									backButton.place(relx=0.5, rely=0.94, anchor="center")
								if lines[5] == "True":
									my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
									bitcoinLabel1 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
									bitcoinLabel1.place(relx=0.05, rely=0.03, anchor="w")

									bitcoinLabel2 = ctk.CTkLabel(right_Frame, text="BIP38 wallet", text_color="orange", font=my_font, fg_color="black")
									bitcoinLabel2.place(relx=0.95, rely=0.03, anchor="e")

								else:
									my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=True, overstrike=False)
									bitcoinLabel3 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
									bitcoinLabel3.place(relx=0.05, rely=0.03, anchor="w")
									bitcoinLabel4 = ctk.CTkLabel(right_Frame, text="Bitcoin wallet", text_color="orange", font=my_font, fg_color="black")
									bitcoinLabel4.place(relx=0.95, rely=0.03, anchor="e")

							else:
								my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
								notcorrectLabel = ctk.CTkLabel(right_Frame, text="The wallet is not correct!", text_color="white", font=my_font, fg_color="black")
								notcorrectLabel.place(relx=0.5, rely=0.5, anchor="center")
								
								my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
								backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
								backButton.place(relx=0.5, rely=0.94, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def get_key_records(self, fingerprint):
		global filepathdestinationfolder
		global content
		global from_date
		global to_date
		global key_record
		
		def save_record():
			global content
			
			answer = messagebox.askquestion('Important!', 'Do you want to save the records on an external USB-device?')
			if answer == 'yes':
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
			else:
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure/keys')
				
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(content)
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved.')
			self.get_key_records(fingerprint)
		
		def print_textbox_useFilter():
			print_textbox(True)
				
		def print_textbox_noFilter():
			print_textbox(False)
			
		def print_textbox(usefilter):
			global content, filepathdestinationfolder
			global to_date
			global from_date
			
			content = '\n                                                       Records\n'
			
			from_date = str(cal_from.get_date())
			to_date = str(cal_to.get_date())
			
			tdates_list = to_date.split("-")
			tyear = str(tdates_list[-3])
			tmonth = str(tdates_list[-2])
			tday = str(tdates_list[-1])
			
			fdates_list = from_date.split("-")
			fyear = str(fdates_list[-3])
			fmonth = str(fdates_list[-2])
			fday = str(fdates_list[-1])
			IDinformation = filepathdestinationfolder + "/secure/ID/IDs.csv"
			pathtorecord = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
			# Check if there is a wallet information
			if os.path.isfile(IDinformation):
				try:
					f = open(IDinformation, 'r')
					for row in csv.reader(f):
						if row[1] == fingerprint:
							if row[0] != '':
								content = content +     '        ' + row[0]			# ID Description
							if row[1] != '':
								content = content +   '\n           Key: ' + row[1]			# fingerpring
							if row[2] != '':
								content = content + '\n\n    First name: ' + row[2]			# owners_name
							if row[3] != '':
								content = content +   '\n     Last name: ' + row[2]			# owners_lastname
							if row[6] != '':
								content = content + '\n\n     Birthdate: ' + row[6]			# Birth date
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No ID key information file found.")
			# Check if there is a key record
			if os.path.isfile(pathtorecord):					
				content = content + '\n__________________________________________________________________________________________________________________'
				content = content + '\n  Date/time         Key action                                   Comment                                          '
				content = content + '\n__________________________________________________________________________________________________________________'
				data = csv.reader(open(pathtorecord),delimiter=',')
				data = sorted(data, key=operator.itemgetter(0))
				
				for i in data:
					ndates_list = i[0].split("-")
					nyear = str(ndates_list[-4])
					nmonth = str(ndates_list[-3])
					nday = str(ndates_list[-2])
					action = i[1]
					comment = i[2]
					if usefilter:
						if int(nyear) > int(fyear) or (int(nyear) == int(fyear) and int(nmonth) > int(fmonth)) or (int(nyear) == int(fyear) and int(nmonth) == int(fmonth) and int(nday) >= int(fday)):
							if int(nyear) < int(tyear) or (int(nyear) == int(tyear) and int(nmonth) < int(tmonth)) or (int(nyear) == int(tyear) and int(nmonth) == int(tmonth) and int(nday) <= int(tday)):
								content = content + '\n  ' + i[0] + '  ' + action[:42]
								# Check the lenght of output and pad
								string_size = len(i[1])
								if string_size < 42:
									while string_size < 42:
										content = content + ' '
										string_size += 1
								
								content = content + '   ' + comment[:50]
								
								# Check the lenght of comment string and pad
								string_size = len(i[2])
								if string_size < 50:
									while string_size < 50:
										content = content + ' '
										string_size += 1
					else:
						content = content + '\n  ' + i[0] + '  ' + action[:42]	
						# Check the lenght of output and pad
						string_size = len(i[1])
						if string_size < 42:
							while string_size < 42:
								content = content + ' '
								string_size += 1
						
						content = content + '   ' + comment[:50]
						
						# Check the lenght of comment string and pad
						string_size = len(i[2])
						if string_size < 50:
							while string_size < 50:
								content = content + ' '
								string_size += 1
						
			content = content + '\n__________________________________________________________________________________________________________________'
			
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
					
			if color_setting == 'Dark':
				my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="black", border_spacing=2, fg_color="black", text_color="white", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			else:
				my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="white", text_color="black", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			
			my_text.insert('end', content)
			my_text.configure(state="disabled")
			my_text.place(x=10, y=140, anchor="nw")	
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		st_path = filepathdestinationfolder + '/secure/keys/records/'
		if not os.path.isdir(st_path):
			os.makedirs(st_path)
		pathtorecords = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		nameLabel = ctk.CTkLabel(my_Frame, text='Records for Key ID: ' + fingerprint[-16:], text_color="white", font=my_font, fg_color="black")
		nameLabel.place(relx=0.24, rely=0.07, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		fromLabel = ctk.CTkLabel(my_Frame, text='From:', text_color="white", font=my_font, fg_color="black")
		fromLabel.place(relx=0.09, rely=0.16, anchor="center")
		
		year = time.strftime("%Y")
		
		cal_from = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black", year=int(year)-1)
		cal_from.place(relx=0.21, rely=0.16, anchor="center")
		
		toLabel = ctk.CTkLabel(my_Frame, text='To:', text_color="white", font=my_font, fg_color="black")
		toLabel.place(relx=0.34, rely=0.16, anchor="center")
		cal_to = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black")
		cal_to.place(relx=0.45, rely=0.16, anchor="center")
		
		filterButton = ctk.CTkButton(my_Frame, text="Filter", text_color="black", fg_color="LightBlue3", border_width=2, border_color="white", width=140, height=28, font=my_font, command=print_textbox_useFilter)
		filterButton.place(relx=0.68, rely=0.16, anchor="e")
		
		allButton = ctk.CTkButton(my_Frame, text="All", text_color="black", fg_color="LightBlue3", border_width=2, border_color="white", width=60, height=28, font=my_font, command=print_textbox_noFilter)
		allButton.place(relx=0.75, rely=0.16, anchor="e")
		
		delButton = ctk.CTkButton(my_Frame, text="Delete line", text_color="black", fg_color="LightBlue3", border_width=2, border_color="white", width=140, height=28, font=my_font, command=partial(self.deleteLineFromRecord, fingerprint))
		delButton.place(relx=0.62, rely=0.07, anchor="e")
		addButton = ctk.CTkButton(my_Frame, text="Add line", text_color="black", fg_color="LightBlue3", border_width=2, border_color="white", width=140, height=28, font=my_font, command=partial(self.addLineToRecord, fingerprint))
		addButton.place(relx=0.75, rely=0.07, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		pathtorecord = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
		
		pathtoKeyIconimage = filepathdestinationfolder + "/secure/ID/ICON" + fingerprint + ".jpg"

		# Check if there is a key (ID) icon
		if not os.path.isfile(pathtoKeyIconimage):
			pathtoKeyIconimage = filepathdestinationfolder + "/images/GnuPG_keyICON.jpg"
			if os.path.isfile(pathtoKeyIconimage):
				keyiconimage = ctk.CTkImage(light_image=Image.open(pathtoKeyIconimage), dark_image=Image.open(pathtoKeyIconimage), size=(210, 126))
				Buttonicon = ctk.CTkButton(my_Frame, text='', image = keyiconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=210, height=126, font=my_font, command=partial(self.get_GnuPGKeys_compact, ['_none__']))
				Buttonicon.place(relx=0.9, rely=0.11, anchor="center")
		else:
			keyiconimage = ctk.CTkImage(light_image=Image.open(pathtoKeyIconimage), dark_image=Image.open(pathtoKeyIconimage), size=(210, 126))
			Buttonicon = ctk.CTkButton(my_Frame, text='', image = keyiconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=210, height=126, font=my_font, command=partial(self.get_key_records, fingerprint))
			Buttonicon.place(relx=0.9, rely=0.11, anchor="center")
		print_textbox_noFilter()
		
		if os.path.isfile(pathtorecord):
			exportButton = ctk.CTkButton(my_Frame, text="Export", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=partial(self.encrypt_and_sign_record, fingerprint))
			exportButton.place(relx=0.72, rely=0.95, anchor="center")
		importButton = ctk.CTkButton(my_Frame, text="Import", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=partial(self.import_and_merge_record, fingerprint))
		importButton.place(relx=0.83, rely=0.95, anchor="center")
		saveButton = ctk.CTkButton(my_Frame, text="Save", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=save_record)
		saveButton.place(relx=0.98, rely=0.95, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		if key_record == 'ID':			
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.showID_more, fingerprint))
			backButton.place(relx=0.5, rely=0.95, anchor="center")
		elif key_record == 'edit':
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.edit_public_key, fingerprint))
			backButton.place(relx=0.5, rely=0.95, anchor="center")
		else:
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.get_GnuPGKeys, fingerprint))
			backButton.place(relx=0.5, rely=0.95, anchor="center")
			
	def showWalletStatement(self, walletname):
		global filepathdestinationfolder
		global content
		global from_date
		global to_date
		
		layout = "Standard"
		def save_statement():
			global content
			
			answer = messagebox.askquestion('Important!', 'Do you want to save the statement on an external USB-device?')
			if answer == 'yes':
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
			else:
				st_path = filepathdestinationfolder + '/secure/wallets/statements/'
				if not os.path.isdir(st_path):
					os.makedirs(st_path)
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure/wallets')
				
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(content)
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved.')
			self.showBitcoinwallet(walletname)
		
		def print_textbox_useFilter():
			print_textbox(True)
				
		def print_textbox_noFilter():
			print_textbox(False)
			
		def print_textbox(usefilter):
			global content
			global to_date
			global from_date
			
			content = '\n                                                       Statement\n'
			totalamount = 0
			
			from_date = str(cal_from.get_date())
			to_date = str(cal_to.get_date())
			
			tdates_list = to_date.split("-")
			tyear = str(tdates_list[-3])
			tmonth = str(tdates_list[-2])
			tday = str(tdates_list[-1])
			
			fdates_list = from_date.split("-")
			fyear = str(fdates_list[-3])
			fmonth = str(fdates_list[-2])
			fday = str(fdates_list[-1])
			
			# Check if there is a wallet information
			if os.path.isfile(walletinformation):
				try:
					f = open(walletinformation, 'r')
					for row in csv.reader(f):
						if row[0] != '':
							content = content + '   Wallet information:\n      ' + row[0]			# walletDescription
						if row[1] != '':
							content = content + '\n      ' + row[1]			# walletReference
						if row[2] != '':
							content = content + '\n      ' + row[2]			# owners_name
						if row[3] != '':
							content = content + '\n      ' + row[3]			# ownerAddr1
						if row[4] != '':
							content = content + '\n      ' + row[4]			# ownerAddr2
						
						if row[5] != '':
							content = content + '\n\n   Statement receiver:\n      ' + row[5]			# statementReceiver
						if row[6] != '':
							content = content + '\n      ' + row[6]			# statementReference
						if row[7] != '':
							content = content + '\n      ' + row[7]			# receiver_name
						if row[8] != '':
							content = content + '\n      ' + row[8]			# receiver_addr
						if row[9] != '':
							content = content + '\n      ' + row[9] + '\n'		# receiver_addr2
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No wallet information file found.")
			# Check if there is a wallet statement
			if os.path.isfile(pathtostatement):
				content = content + '\n__________________________________________________________________________________________________________________'
				content = content + '\n  Date/time         Receiving address                            Comment                         Fee        Amount'
				content = content + '\n__________________________________________________________________________________________________________________'
				data = csv.reader(open(pathtostatement),delimiter=',')
				data = sorted(data, key=operator.itemgetter(0))
				
				for i in data:
					ndates_list = i[0].split("-")
					nyear = str(ndates_list[-4])
					nmonth = str(ndates_list[-3])
					nday = str(ndates_list[-2])
					if usefilter:
						if int(nyear) > int(fyear) or (int(nyear) == int(fyear) and int(nmonth) > int(fmonth)) or (int(nyear) == int(fyear) and int(nmonth) == int(fmonth) and int(nday) >= int(fday)):
							if int(nyear) < int(tyear) or (int(nyear) == int(tyear) and int(nmonth) < int(tmonth)) or (int(nyear) == int(tyear) and int(nmonth) == int(tmonth) and int(nday) <= int(tday)):
								content = content + '\n  ' + i[0] + '  ' + i[1]	
								totalamount = totalamount + int(i[4])
								# Check the lenght of receiving address and pad
								string_size = len(i[1])
								if string_size < 42:
									while string_size < 42:
										content = content + ' '
										string_size += 1
								
								content = content + '   ' + i[2]
								
								# Check the lenght of comment string and pad
								string_size = len(i[2])
								if string_size < 31:
									while string_size < 31:
										content = content + ' '
										string_size += 1
								
								content = content + ' ' + i[3]
								# Check the lenght of fee string and pad.
								string_size = len(i[3])
								if string_size < 7:
									while string_size < 7:
										content = content + ' '
										string_size += 1
								# pad extra for amount
								string_size = len(i[4])
								if string_size < 10:
									while string_size < 10:
										content = content + ' '
										string_size += 1
								content = content + i[4]
					else:
						content = content + '\n  ' + i[0] + '  ' + i[1]	
						totalamount = totalamount + int(i[4])
						# Check the lenght of receiving address and pad
						string_size = len(i[1])
						if string_size < 42:
							while string_size < 42:
								content = content + ' '
								string_size += 1
						
						content = content + '   ' + i[2]
						
						# Check the lenght of comment string and pad
						string_size = len(i[2])
						if string_size < 31:
							while string_size < 31:
								content = content + ' '
								string_size += 1
						
						content = content + ' ' + i[3]
						# Check the lenght of fee string and pad.
						string_size = len(i[3])
						if string_size < 7:
							while string_size < 7:
								content = content + ' '
								string_size += 1
						# pad extra for amount
						string_size = len(i[4])
						if string_size < 10:
							while string_size < 10:
								content = content + ' '
								string_size += 1
						content = content + i[4]
			
			content = content + '\n__________________________________________________________________________________________________________________'
			content = content + '\n                                                                                   Total amount (sats): '
			total_amount_lenght = len(str(totalamount))
			
			if total_amount_lenght < 10:
				while total_amount_lenght < 10:
					content = content + ' '
					total_amount_lenght += 1
			content = content + str(totalamount)
			content = content + '\n__________________________________________________________________________________________________________________\n'
			
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
					
			if color_setting == 'Dark':
				my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="black", border_spacing=2, fg_color="black", text_color="white", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			else:
				my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="white", text_color="black", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			
			my_text.insert('end', content)
			my_text.configure(state="disabled")
			my_text.place(x=10, y=140, anchor="nw")	
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"

		walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
		
		completeName = filepathdestinationfolder + "/secure/layout.csv"
		if not os.path.isfile(completeName):
			layout = ['Standard']
			
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				csvwriter.writerow(layout)
		else:
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							layout = lines[0]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No layout file found.")
		
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"							
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines[0] == walletname:	
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
						nameLabel = ctk.CTkLabel(my_Frame, text='Statement - ' + lines[0], text_color="white", font=my_font, fg_color="black")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						fromLabel = ctk.CTkLabel(my_Frame, text='From:', text_color="white", font=my_font, fg_color="black")
						year = time.strftime("%Y")
						cal_from = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black", year=int(year)-1)
						toLabel = ctk.CTkLabel(my_Frame, text='To:', text_color="white", font=my_font, fg_color="black")
						cal_to = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black")
						
						if layout == 'Easy':
							nameLabel.place(relx=0.04, rely=0.05, anchor="w")
							fromLabel.place(relx=0.15, rely=0.11, anchor="center")	
							cal_from.place(relx=0.25, rely=0.16, anchor="center")
							toLabel.place(relx=0.39, rely=0.11, anchor="center")
							cal_to.place(relx=0.5, rely=0.16, anchor="center")
						else:
							nameLabel.place(relx=0.04, rely=0.07, anchor="w")
							fromLabel.place(relx=0.16, rely=0.16, anchor="center")	
							cal_from.place(relx=0.28, rely=0.16, anchor="center")
							toLabel.place(relx=0.41, rely=0.16, anchor="center")
							cal_to.place(relx=0.52, rely=0.16, anchor="center")

						filterButton = ctk.CTkButton(my_Frame, text="Filter", text_color="white", fg_color="navy blue", border_width=2, border_color="white", width=140, height=28, font=my_font, command=print_textbox_useFilter)
						filterButton.place(relx=0.75, rely=0.16, anchor="e")
						
						allButton = ctk.CTkButton(my_Frame, text="All", text_color="white", fg_color="navy blue", border_width=2, border_color="white", width=60, height=28, font=my_font, command=print_textbox_noFilter)
						allButton.place(relx=0.82, rely=0.16, anchor="e")
						
						addButton = ctk.CTkButton(my_Frame, text="Delete line", text_color="white", fg_color="navy blue", border_width=2, border_color="white", width=140, height=28, font=my_font, command=partial(self.deleteLineFromStatement, walletname))
						addButton.place(relx=0.62, rely=0.07, anchor="e")
						addButton = ctk.CTkButton(my_Frame, text="Add line", text_color="white", fg_color="navy blue", border_width=2, border_color="white", width=140, height=28, font=my_font, command=partial(self.addLineToStatement, walletname))
						addButton.place(relx=0.75, rely=0.07, anchor="e")
						
						my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
						
						walletinformation = str(filepathdestinationfolder) + "/secure/wallets/" + walletname + ".csv"
						pathtoicon = filepathdestinationfolder + "/secure/wallets/" + walletname + '.jpg'
						pathtostatement = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
						
						# Check if there is a wallet icon
						if os.path.isfile(pathtoicon):
							iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(120, 120))
							Buttonicon = ctk.CTkButton(my_Frame, text='', image = iconImage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=120, height=120, font=my_font, command=partial(self.editWalletInformation, walletname))
							Buttonicon.place(relx=0.92, rely=0.1, anchor="center")
						
						print_textbox_noFilter()
						
						backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
						backButton.place(relx=0.5, rely=0.95, anchor="center")
						if os.path.isfile(pathtostatement):
							exportButton = ctk.CTkButton(my_Frame, text="Export", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=partial(self.encrypt_and_sign_statement, walletname))
							exportButton.place(relx=0.72, rely=0.95, anchor="center")
						importButton = ctk.CTkButton(my_Frame, text="Import", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=partial(self.import_and_merge_statement, walletname))
						importButton.place(relx=0.83, rely=0.95, anchor="center")
						backButton = ctk.CTkButton(my_Frame, text="Save", text_color="black", fg_color="orange", border_width=2, border_color="white", width=110, height=32, font=my_font, command=save_statement)
						backButton.place(relx=0.98, rely=0.95, anchor="e")
		except FileNotFoundError:
			messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
	
	def easy_showWalletStatement(self, walletname):
		global filepathdestinationfolder
		global Boltcard_button_color
			
		def print_textbox():
			content = ''
			totalamount = 0
			pathtostatement = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
			# Check if there is a wallet statement
			if os.path.isfile(pathtostatement):
				content = content + '________________________________________________________________________________________'
				content = content + '\n  Date/time          Action        Comment                                        Amount'
				content = content + '\n________________________________________________________________________________________'
				data = csv.reader(open(pathtostatement),delimiter=',')
				data = sorted(data, key=operator.itemgetter(0), reverse=True)
				
				for i in data:
					content = content + '\n  ' + i[0]
					totalamount = totalamount + int(i[4])
					# Add action
					if int(i[4]) < 0:
						content = content + '   SENT          '
					else:
						content = content + '   RECEIVED      '
					# Check the lenght of comment string and pad
					string_size = len(i[2])
					content = content + i[2]
					if string_size < 31:
						while string_size < 43:
							content = content + ' '
							string_size += 1
					
					# pad extra for amount
					string_size = len(i[4])
					if string_size < 10:
						while string_size < 10:
							content = content + ' '
							string_size += 1
					content = content + i[4]
			
			content = content + '\n_________________________________________________________________________________________'
			content = content + '\n                                                         Total amount (sats): '
			total_amount_lenght = len(str(totalamount))
			
			if total_amount_lenght < 10:
				while total_amount_lenght < 10:
					content = content + ' '
					total_amount_lenght += 1
			content = content + str(totalamount)
			
			my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="black", border_spacing=2, fg_color="black", text_color="white", font=('Consolas', 22), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', content)
			my_text.configure(state="disabled")
			my_text.place(x=10, y=80, anchor="nw")	
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines[0] == walletname:	
						my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
						nameLabel = ctk.CTkLabel(my_Frame, text='History - ' + lines[0], text_color="white", font=my_font, fg_color="black")
						nameLabel.place(relx=0.04, rely=0.07, anchor="w")
		except FileNotFoundError:
			messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=150, height=32, font=my_font, command=self.easy_show_Bitcoin_wallets)
		backButton.place(relx=0.5, rely=0.93, anchor="center")
		print_textbox()
		
	def scanForAddress(self, walletname):
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforAddress.py'], shell=True)
		self.addLineToStatement(walletname)
	
	def deleteLineFromRecord(self, fingerprint):
		global filepathdestinationfolder
		global pathtoloadaddress
		content = ''
				
		def do_deleteLineFromRecord():
			realSelectedRow = 0
			selectedRow = opt.get()
			realSelectedRow = int(selectedRow) - 1
			file_ = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
			temp_file_ = filepathdestinationfolder + "/secure/keys/records/tempRecord.csv"
			if os.path.isfile(file_):
				with open(file_, 'r') as inp, open(temp_file_, 'w') as out:
					writer = csv.writer(out)
					counter = 0
					for row in csv.reader(inp):
						if counter != realSelectedRow:
							writer.writerow(row)
						counter +=1
				shutil.copy(temp_file_, file_)
			self.get_key_records(fingerprint)
								
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
								
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		mainLabel = ctk.CTkLabel(my_Frame, text="Delete a transaction from the record:", text_color="orange", font=my_font, fg_color="black")
		mainLabel.place(relx=0.04, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		pathtorecord = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
		content = content + '\n________________________________________________________________________________________________________________'
		content = content + '\n  Row   Date/time         Key action                                   Comment                                          '
		content = content + '\n________________________________________________________________________________________________________________'
		row = 1
		linesList = []
		try:
			with open(pathtorecord, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					action = lines[1]
					comment = lines[2]
					content = content + '\n  ' + str(row)
					
					# pad extra for row
					string_size = len(str(row))
					if string_size < 6:
						while string_size < 6:
							content = content + ' '
							string_size += 1
					content = content + lines[0] + '  ' + action[:42]	
					
					# Check the lenght of action and pad
					string_size = len(lines[1])
					if string_size < 42:
						while string_size < 42:
							content = content + ' '
							string_size += 1
					
					content = content + '   ' + comment[:44]
					
					# Check the lenght of comment string and pad
					string_size = len(lines[2])
					if string_size < 44:
						while string_size < 44:
							content = content + ' '
							string_size += 1
					linesList.append(row)
					row +=1
		except FileNotFoundError:
			messagebox.showinfo("Information", "There was a problem reading the file.")
		my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="white", text_color="black", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
		my_text.insert('end', content)
		my_text.configure(state="disabled")
		my_text.place(x=10, y=140, anchor="nw")	
		
		opt = StringVar(value='')
		drop = OptionMenu(my_Frame, opt, *linesList)
		drop.config(width=4)
		drop.place(relx=0.8, rely=0.94, anchor="w")						
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=32, font=my_font, command=partial(self.get_key_records, fingerprint))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
		infoLabel = ctk.CTkLabel(my_Frame, text="Select line:", text_color="white", font=my_font, fg_color="black")
		infoLabel.place(relx=0.78, rely=0.94, anchor="e")
		delButton = ctk.CTkButton(my_Frame, text="Delete", text_color="black", fg_color="orange", border_width=2, border_color="white", width=120, height=32, font=my_font, command=do_deleteLineFromRecord)
		delButton.place(relx=0.98, rely=0.94, anchor="e")
		
	def deleteLineFromStatement(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		content = ''
				
		def do_deleteLineFromStatement():
			realSelectedRow = 0
			selectedRow = opt.get()
			realSelectedRow = int(selectedRow) - 1
			file_ = filepathdestinationfolder + "/secure/wallets/Statement" + walletname + ".csv"
			temp_file_ = filepathdestinationfolder + "/secure/wallets/tempStatement.csv"
			if os.path.isfile(file_):
				with open(file_, 'r') as inp, open(temp_file_, 'w') as out:
					writer = csv.writer(out)
					counter = 0
					for row in csv.reader(inp):
						if counter != realSelectedRow:
							writer.writerow(row)
						counter +=1
				shutil.copy(temp_file_, file_)
			self.showWalletStatement(walletname)
								
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
								
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		mainLabel = ctk.CTkLabel(my_Frame, text="Delete a transaction from the record:", text_color="orange", font=my_font, fg_color="black")
		mainLabel.place(relx=0.04, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		pathtostatement = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
		content = content + '\n________________________________________________________________________________________________________________'
		content = content + '\n  Row   Date/time         Receiving address                            Comment                            Amount'
		content = content + '\n________________________________________________________________________________________________________________'
		row = 1
		linesList = []
		try:
			with open(pathtostatement, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					content = content + '\n  ' + str(row)
					
					# pad extra for row
					string_size = len(str(row))
					if string_size < 6:
						while string_size < 6:
							content = content + ' '
							string_size += 1
					content = content + lines[0] + '  ' + lines[1]	
					
					# Check the lenght of receiving address and pad
					string_size = len(lines[1])
					if string_size < 42:
						while string_size < 42:
							content = content + ' '
							string_size += 1
					
					content = content + '   ' + lines[2]
					
					# Check the lenght of comment string and pad
					string_size = len(lines[2])
					if string_size < 31:
						while string_size < 31:
							content = content + ' '
							string_size += 1
					
					# pad extra for amount
					string_size = len(lines[4])
					if string_size < 10:
						while string_size < 10:
							content = content + ' '
							string_size += 1
					content = content + lines[4]
					linesList.append(row)
					row +=1
		except FileNotFoundError:
			messagebox.showinfo("Information", "There was a problem reading the statement file.")
		my_text = ctk.CTkTextbox(my_Frame, width=1180, height=450, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="white", text_color="black", font=('Consolas', 16), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
		my_text.insert('end', content)
		my_text.configure(state="disabled")
		my_text.place(x=10, y=140, anchor="nw")	
		
		opt = StringVar(value='')
		drop = OptionMenu(my_Frame, opt, *linesList)
		drop.config(width=4)
		drop.place(relx=0.8, rely=0.94, anchor="w")						
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
		infoLabel = ctk.CTkLabel(my_Frame, text="Select line:", text_color="white", font=my_font, fg_color="black")
		infoLabel.place(relx=0.78, rely=0.94, anchor="e")
		delButton = ctk.CTkButton(my_Frame, text="Delete", text_color="black", fg_color="orange", border_width=2, border_color="white", width=120, height=32, font=my_font, command=do_deleteLineFromStatement)
		delButton.place(relx=0.98, rely=0.94, anchor="e")
	
	def addLineToRecord(self, fingerprint):
		global filepathdestinationfolder
		global pathtoloadaddress
		comment_text = ''
		action_text = ''
		date_time_text = ''
								
		def limitSizeAction_text(*args):
			value = action_text_var.get()
			if len(value) > 42: action_text_var.set(value[:42])
		
		def limitSizeFee_text(*args):
			value = fee_text_var.get()
			if len(value) > 7: fee_text_var.set(value[:7])
		
		def limitSizeAmount_text(*args):
			value = amount_text_var.get()
			if len(value) > 9: amount_text_var.set(value[:9])
		
		def limitSizeComment_text(*args):
			value = comment_text_var.get()
			if len(value) > 50: comment_text_var.set(value[:50])
				
		def do_addLineToRecord():
			# Get the date_time field
			the_date_entry1 = str(cal_to.get_date())
			the_date_time = the_date_entry1 + '-00:00'
			
			# Get the key action as included manually
			action_text = action_text_Entry.get()
				
			# Get the comment field
			the_comment = comment_text_Entry.get()
			
			# If key record file don't exist create it
			completeName = str(filepathdestinationfolder) + "/secure/keys/records/record" + fingerprint + ".csv"
			
			new_record_entry = [
									the_date_time,
									action_text,
									the_comment]
											
			if not os.path.isfile(completeName):
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_record_entry)
			else:
				# If key record file exist add a line to it
				with open(completeName, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_record_entry)
			
			self.get_key_records(fingerprint)
										
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
								
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		mainLabel = ctk.CTkLabel(my_Frame, text="Add an action performed by key to the record *:", text_color="orange", font=my_font, fg_color="black")
		mainLabel.place(relx=0.05, rely=0.12, anchor="w")
		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		date_timeLabel = ctk.CTkLabel(my_Frame, text="Date/time:", text_color="white", fg_color="black", font=my_font)
		date_timeLabel.place(relx=0.02, rely=0.3, anchor="w")
		
		actionLabel = ctk.CTkLabel(my_Frame, text="Key action:", text_color="white", fg_color="black", font=my_font)
		actionLabel.place(relx=0.17, rely=0.3, anchor="w")
		action_text_var = ctk.StringVar(value=action_text)
		action_text_var.trace('w', limitSizeAction_text)
		
		commentLabel = ctk.CTkLabel(my_Frame, text="Comment:", text_color="white", fg_color="black", font=my_font)
		commentLabel.place(relx=0.5, rely=0.3, anchor="w")								
		comment_text_var = ctk.StringVar(value=comment_text)
		comment_text_var.trace('w', limitSizeComment_text)				
		
		my_font = ctk.CTkFont(family="Arial Black", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
		cal_to = DateEntry(my_Frame, width=16, text_color="white", bg="darkblue", fg="black")
		cal_to.place(relx=0.02, rely=0.36, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)				
		action_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=action_text, textvariable=action_text_var, width=380, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		action_text_Entry.place(relx=0.17, rely=0.36, anchor="w")
		
		comment_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=comment_text, textvariable=comment_text_var, width=500, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		comment_text_Entry.place(relx=0.5, rely=0.36, anchor="w")

		addButton = ctk.CTkButton(my_Frame, text="Add", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=34, font=my_font, command=do_addLineToRecord)
		addButton.place(relx=0.86, rely=0.42, anchor="center")
		my_font = ctk.CTkFont(family="Arial Black", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		infoLabel = ctk.CTkLabel(my_Frame, text="* For future reference.", text_color="white", fg_color="black", font=my_font)
		infoLabel.place(relx=0.04, rely=0.94, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
				
	def addLineToStatement(self, walletname):
		global filepathdestinationfolder
		global pathtoloadaddress
		comment_text = ''
		fee_text = ''
		amount_text = ''
		address_text = ''
		date_time_text = ''
								
		def limitSizeAddress_text(*args):
			value = address_text_var.get()
			if len(value) > 42: address_text_var.set(value[:42])
		
		def limitSizeFee_text(*args):
			value = fee_text_var.get()
			if len(value) > 7: fee_text_var.set(value[:7])
		
		def limitSizeAmount_text(*args):
			value = amount_text_var.get()
			if len(value) > 9: amount_text_var.set(value[:9])
		
		def limitSizeComment_text(*args):
			value = comment_text_var.get()
			if len(value) > 30: comment_text_var.set(value[:30])
				
		def do_addLineToStatement():
			# Get the date_time field
			the_date_entry1 = str(cal_to.get_date())
			the_date_time = the_date_entry1 + '-00:00'
			
			# Get the receiver address as included manually or scanned as QR
			the_address = address_text_Entry.get()
			if the_address == '':
				the_address = '<Not defined>'
				
			# Get the amount field
			try:
				the_amount = int(str(amount_text_Entry.get()))
			except:
				tk.messagebox.showinfo('Information', 'The amount needs to be an even number of sats".')
				self.addLineToStatement(walletname)
			
			if the_amount == 0:
				tk.messagebox.showinfo('Information', 'You cant add an amount of zero sats".')
				self.addLineToStatement(walletname)
					
			# Get the fee field
			the_fee_str = fee_text_Entry.get()
			if the_fee_str == '' or the_fee_str == '"0"' or the_fee_str == 'zero' or the_fee_str == 'Zero':
				the_fee = 0
			else:
				try:
					the_fee = int(str(fee_text_Entry.get()))
				except:
					tk.messagebox.showinfo('Information', 'The fee needs to be an even number of sats".')
					self.addLineToStatement(walletname)
				
			# Get the comment field
			the_comment = comment_text_Entry.get()
			if the_comment == '':
				the_comment = ' '
				
			# If wallet statement file don't exist create it
			completeName = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
			
			new_wallet_transaction = [
									the_date_time,
									the_address,
									the_comment,
									the_fee,
									the_amount]
											
			if not os.path.isfile(completeName):
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			else:
				# If wallet statement file exist add a line to it
				with open(completeName, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_wallet_transaction)
			
			scannedAddressPath = str(filepathdestinationfolder) + "/secure/wallets/scannedAddressFromQR.txt"
			if os.path.isfile(scannedAddressPath):
				os.remove(scannedAddressPath)
			
			self.showWalletStatement(walletname)
		
		scannedAddressPath = str(filepathdestinationfolder) + "/secure/wallets/scannedAddressFromQR.txt"
		if os.path.isfile(scannedAddressPath):
			with open(scannedAddressPath, 'r') as f:
				address_text = f.read()
										
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
								
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		mainLabel = ctk.CTkLabel(my_Frame, text="Add a transaction to the statement:", text_color="orange", font=my_font, fg_color="black")
		mainLabel.place(relx=0.05, rely=0.12, anchor="w")
		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		date_timeLabel = ctk.CTkLabel(my_Frame, text="Date/time:", text_color="white", fg_color="black", font=my_font)
		date_timeLabel.place(relx=0.02, rely=0.3, anchor="w")
		
		addressLabel = ctk.CTkLabel(my_Frame, text="Receiving address:", text_color="white", fg_color="black", font=my_font)
		addressLabel.place(relx=0.17, rely=0.3, anchor="w")
		address_text_var = ctk.StringVar(value=address_text)
		address_text_var.trace('w', limitSizeAddress_text)
		
		signQRButton = ctk.CTkButton(my_Frame, text="Scan from QR", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=140, height=30, font=my_font, command=partial(self.scanForAddress, walletname))
		signQRButton.place(relx=0.55, rely=0.42, anchor="e")
		
		amountLabel = ctk.CTkLabel(my_Frame, text="Amount*:", text_color="white", font=my_font, fg_color="black")
		amountLabel.place(relx=0.56, rely=0.3, anchor="w")
		amount_text_var = ctk.StringVar(value=amount_text)
		amount_text_var.trace('w', limitSizeAmount_text)	
		
		feeLabel = ctk.CTkLabel(my_Frame, text="Fee**:", text_color="white", font=my_font, fg_color="black")
		feeLabel.place(relx=0.66, rely=0.3, anchor="w")
		fee_text_var = ctk.StringVar(value=fee_text)
		fee_text_var.trace('w', limitSizeFee_text)	
		
		commentLabel = ctk.CTkLabel(my_Frame, text="Comment:", text_color="white", fg_color="black", font=my_font)
		commentLabel.place(relx=0.74, rely=0.3, anchor="w")								
		comment_text_var = ctk.StringVar(value=comment_text)
		comment_text_var.trace('w', limitSizeComment_text)				
		
		my_font = ctk.CTkFont(family="Arial Black", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
		cal_to = DateEntry(my_Frame, width=16, text_color="white", bg="darkblue", fg="black")
		cal_to.place(relx=0.02, rely=0.36, anchor="w")
						
		address_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=address_text, textvariable=address_text_var, width=450, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		address_text_Entry.place(relx=0.17, rely=0.36, anchor="w")
		
		amount_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=amount_text, textvariable=amount_text_var, width=110, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		amount_text_Entry.place(relx=0.56, rely=0.36, anchor="w")
		
		fee_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=fee_text, textvariable=fee_text_var, width=80, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		fee_text_Entry.place(relx=0.66, rely=0.36, anchor="w")
		
		comment_text_Entry = ctk.CTkEntry(my_Frame, placeholder_text=comment_text, textvariable=comment_text_var, width=280, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		comment_text_Entry.place(relx=0.74, rely=0.36, anchor="w")

		my_font = ctk.CTkFont(family="Arial Black", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		addButton = ctk.CTkButton(my_Frame, text="Add", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=34, font=my_font, command=do_addLineToStatement)
		addButton.place(relx=0.91, rely=0.42, anchor="center")
		my_font = ctk.CTkFont(family="Arial Black", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		infoLabel = ctk.CTkLabel(my_Frame, text="* When receiving sats put the amount as a positiv number and when sending put a negativ number (-).", text_color="white", fg_color="black", font=my_font)
		infoLabel.place(relx=0.02, rely=0.81, anchor="w")
		infoLabel = ctk.CTkLabel(my_Frame, text="** When sending put the fee as a positiv number (or zero) and when receiving put \"0\" (zero) or leave it empty.", text_color="white", fg_color="black", font=my_font)
		infoLabel.place(relx=0.02, rely=0.87, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=140, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
				
	def signBitcoinMessageQR(self, walletname):
		global clicked_privateSubKey
		global outputdir
		global GPG_button_color
		
		def do_scan():
			self.readQRfromCameraToSignMessage(walletname)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="STEP 1: Scan the public Bitcoin address that belongs to wallet:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.15, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=30, weight="bold", slant="roman", underline=False, overstrike=False)
		nameLabel = ctk.CTkLabel(my_Frame, text=walletname, text_color="dark orange", fg_color="black", font=my_font)
		nameLabel.place(relx=0.5, rely=0.24, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="The address has to be Native Segwit (starting with \"bc1q....\").", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.34, anchor="center")
		Label3 = ctk.CTkLabel(my_Frame, text="When you have the QR-code ready click \"Start\" (this will start the camera).", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.42, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
	
		startButton = ctk.CTkButton(self, text="Start", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_scan)
		startButton.place(relx=0.5, rely=0.75, anchor="center")
			
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
	
	def readQRfromCameraToSignMessage(self, walletname):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
		self.readQRfromCameraToSignMessage2(walletname)
				
	def readQRfromCameraToSignMessage2(self, walletname):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		link_to_signature_data = "/home/user1/secure/QRsignaturefile.txt"
			
		if os.path.isfile(link_to_signature_data):
			try:
				f = open(link_to_signature_data, "r")
				file_content = f.read()
				f.close()
				transactiondatoavailable = True
			except OSError:
				print("No file")
				
			my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		
			Label1 = ctk.CTkLabel(my_Frame, text="STEP 2: Scan a Bitcoin message.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.15, anchor="center")

			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			Label2 = ctk.CTkLabel(my_Frame, text="The message needs to be in ONE line only.", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.3, anchor="center")
			Label3 = ctk.CTkLabel(my_Frame, text="When you have the QR-code ready (with the message) click \"Start\".", text_color="white", fg_color="black", font=my_font)
			Label3.place(relx=0.5, rely=0.38, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
	
			startButton = ctk.CTkButton(self, text="Start", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.readQRfromCameraToSignMessage3, walletname))
			startButton.place(relx=0.5, rely=0.75, anchor="center")
				
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
		else:
			my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
			pubLabel = ctk.CTkLabel(my_Frame, text="Could not read QR-data", text_color="white", font=my_font, fg_color="black")
			pubLabel.place(relx=0.5, rely=0.46, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
			
	def readQRfromCameraToSignMessage3(self, walletname):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRmessagefile.txt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRmessage.py'], shell=True)
		self.readQRfromCameraToSignMessage4(walletname)
	
	def readQRfromCameraToSignMessage4(self, walletname):
		global filepathdestinationfolder
		pathtomessage = str(filepathdestinationfolder) + "/secure/QRmessagefile.txt"
		pathtoaddress = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
		
		the_address = ''
		key = ''
		msg = ''
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Checking if address belongs to wallet....... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		def show_QR_with_signature(signature, filenameMessage):	
			# Print out the seedQR
			load_signature = qrcode.make(signature)
				
			resize_load_address = load_signature.resize((270, 270))
			pathtosignature = str(filepathdestinationfolder) + "/secure/wallets/signature_message.png"
			
			resize_load_address.save(pathtosignature)
			
			loadimg = ctk.CTkImage(light_image=Image.open(pathtosignature), dark_image=Image.open(pathtosignature), size=(270, 270))
			
			my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
			nameLabel = ctk.CTkLabel(my_Frame, text=walletname, text_color="dark orange", font=my_font, fg_color="black")
			nameLabel.place(relx=0.5, rely=0.08, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
			pubLabel = ctk.CTkLabel(my_Frame, text="Signature for message:", text_color="white", font=my_font, fg_color="black")
			pubLabel.place(relx=0.5, rely=0.16, anchor="center")
			Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
			Labelpublicimg.place(relx=0.5, rely=0.44, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
			
			self.add_history("Signing of Bitcoin message for wallet (proof wallet ownership): " + walletname)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
		try:
			f = open(pathtoaddress, "r")
			the_address = f.read()
			f.close()
			the_address = the_address.replace('\n', '')
		except OSError:
			tk.messagebox.showinfo('Information', 'There was a problem reading the address.')
		
		try:
			f = open(pathtomessage, "r")
			msg = f.read()
			f.close()
			msg = msg.replace('\n', '')
		except OSError:
			tk.messagebox.showinfo('Information', 'There was a problem reading the message.')
			
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		
		if path_to_USB_secure == 'Secure USB folder is available':
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[0] == walletname:
							mnemo = Mnemonic("english")
							if lines[5] == "False":
								theHDKey = HDKey.from_passphrase(lines[3], password='', witness_type='segwit', compressed=False, multisig=False)
							else:
								theHDKey = HDKey.from_passphrase(lines[3], password=lines[6])
							
							private_Wif_key = theHDKey.wif_key()
							
							k = HDKey.from_wif(theHDKey.wif_private())
							
							found = False
							subkey_count = 0
							
							while not found and subkey_count < 300:
								d_path = "m/84'/0'/0'/0/" + str(subkey_count)
								subkey = k.subkey_for_path(d_path)
								if str(subkey.address()) == the_address:
									key = subkey.wif_key()
									found = True
									break
								else:
									subkey_count += 1
									
							# If its not found also check the change addresses 
							if not found:
								subkey_count = 0
								while not found and subkey_count < 300:
									d_path = "m/84'/0'/0'/1/" + str(subkey_count)
									subkey = k.subkey_for_path(d_path)
									if str(subkey.address()) == the_address:
										key = subkey.wif_key()
										found = True
										break
									else:
										subkey_count += 1
							
							# If its STILL not found ask if to search deep
							if not found:
								answer = messagebox.askquestion('Important!', 'Address not found. Do you want to search deeper (can take 5-10 minutes)?. \n\nContinue?')
								if answer == 'yes':
									subkey_count = 299
									while not found and subkey_count < 3000:
										d_path = "m/84'/0'/0'/0/" + str(subkey_count)
										subkey = k.subkey_for_path(d_path)
										if str(subkey.address()) == the_address:
											key = subkey.wif_key()
											found = True
											break
										else:
											subkey_count += 1
											
									# If its not found also check deep in the change addresses 
									if not found:
										subkey_count = 299
										while not found and subkey_count < 3000:
											d_path = "m/84'/0'/0'/1/" + str(subkey_count)
											subkey = k.subkey_for_path(d_path)
											if str(subkey.address()) == the_address:
												key = subkey.wif_key()
												found = True
												break
											else:
												subkey_count += 1
								else:
									self.showBitcoinwallet(walletname)
												
							if found:
								secret = CBitcoinSecret(key)
								message = BitcoinMessage(msg)
								
								filename_list = pathtomessage.split("/")
								filenameMessage = str(filename_list[-1])
								
								signature = SignMessage(secret, message)
								address_ = P2PKHBitcoinAddress.from_pubkey(secret.pub)
								
								test_check = VerifyMessage(address_, message, signature)
								if test_check:
									show_QR_with_signature(signature, filenameMessage)
								else:
									tk.messagebox.showinfo('Information', 'There was a problem to sign the message and address.')
							else:
								tk.messagebox.showinfo('Information', 'The Address is not from this wallet.')
								self.showBitcoinwallet(walletname)
			except FileNotFoundError:
				messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
						
	def signBitcoinMessageFiles(self, walletname):
		global filepathdestinationfolder
		
		the_address = ''
		key = ''
		msg = ''
		
		def show_QR_with_signature(signature, filenameMessage):	
			# Print out the seedQR
			load_signature = qrcode.make(signature)
				
			resize_load_address = load_signature.resize((270, 270))
			pathtosignature = str(filepathdestinationfolder) + "/secure/wallets/signature_message.png"
			
			resize_load_address.save(pathtosignature)
			
			loadimg = ctk.CTkImage(light_image=Image.open(pathtosignature), dark_image=Image.open(pathtosignature), size=(270, 270))
			
			my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
			nameLabel = ctk.CTkLabel(right_Frame, text=walletname, text_color="dark orange", font=my_font, fg_color="black")
			nameLabel.place(relx=0.5, rely=0.08, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
			pubLabel = ctk.CTkLabel(right_Frame, text="Signature for message:", text_color="white", font=my_font, fg_color="black")
			pubLabel.place(relx=0.5, rely=0.16, anchor="center")
			Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = loadimg)
			Labelpublicimg.place(relx=0.5, rely=0.44, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
			tk.messagebox.showinfo('Information', 'Select the directory for the signed message file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			with open(outputdir + '/Signature_' + filenameMessage, "wb") as binary_file:
				binary_file.write(signature)
			messagebox.showinfo('Information', 'Signature file \"Signature_' + filenameMessage + '\"' + ' has been saved.')
			self.add_history("Signing of Bitcoin message for wallet (proof wallet ownership): " + walletname)
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if os.path.isfile(w_icon_path):
			pathtoWalletIconimage = w_icon_path
			walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
		else:
			pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
			walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if os.path.isfile(w_icon_path):
			Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
		else:
			Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
		Llabel1 = ctk.CTkLabel(left_Frame, text=walletname, text_color="white", font=my_font, fg_color="black")
		Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
			
		answer = messagebox.askquestion('Important!', 'You will need a USB-device with TWO text files. One with a Bitcoin public address (associated with the wallet),\n and one with the message to sign. \n\nContinue?')
		if answer == 'yes':
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			messagebox.showinfo("Information", "Select the file containing the public address.")
			time.sleep(2)
			pathtoaddress = filedialog.askopenfilename(initialdir='/media/user1')
			
			try:
				f = open(pathtoaddress, "r")
				the_address = f.read()
				f.close()
				the_address = the_address.replace('\n', '')
			except OSError:
				tk.messagebox.showinfo('Information', 'There was a problem reading the address file.')
			
			messagebox.showinfo("Information", "Select the the file containing the message to sign with your wallets private key.")
			time.sleep(2)
			pathtomessage = filedialog.askopenfilename(initialdir='/media/user1')
			
			try:
				f = open(pathtomessage, "r")
				msg = f.read()
				f.close()
				msg = msg.replace('\n', '')
			except OSError:
				tk.messagebox.showinfo('Information', 'There was a problem reading the message file.')
			
			completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
			
			if path_to_USB_secure == 'Secure USB folder is available':
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines[0] == walletname:
								mnemo = Mnemonic("english")
								if lines[5] == "False":
									theHDKey = HDKey.from_passphrase(lines[3], password='', witness_type='segwit', compressed=False, multisig=False)
								else:
									theHDKey = HDKey.from_passphrase(lines[3], password=lines[6])
								
								private_Wif_key = theHDKey.wif_key()
								
								k = HDKey.from_wif(theHDKey.wif_private())
								
								found = False
								subkey_count = 0
								
								while not found and subkey_count < 300:
									d_path = "m/84'/0'/0'/0/" + str(subkey_count)
									subkey = k.subkey_for_path(d_path)
									if str(subkey.address()) == the_address:
										key = subkey.wif_key()
										found = True
										break
									else:
										subkey_count += 1
										
								# If its not found also check the change addresses 
								if not found:
									subkey_count = 0
									while not found and subkey_count < 300:
										d_path = "m/84'/0'/0'/1/" + str(subkey_count)
										subkey = k.subkey_for_path(d_path)
										if str(subkey.address()) == the_address:
											key = subkey.wif_key()
											found = True
											break
										else:
											subkey_count += 1
								
								# If its STILL not found ask if to search deep
								if not found:
									answer = messagebox.askquestion('Important!', 'Address not found. Do you want to search deeper (can take 5-10 minutes)?. \n\nContinue?')
									if answer == 'yes':
										subkey_count = 299
										while not found and subkey_count < 3000:
											d_path = "m/84'/0'/0'/0/" + str(subkey_count)
											subkey = k.subkey_for_path(d_path)
											if str(subkey.address()) == the_address:
												key = subkey.wif_key()
												found = True
												break
											else:
												subkey_count += 1
												
										# If its not found also check deep in the change addresses 
										if not found:
											subkey_count = 299
											while not found and subkey_count < 3000:
												d_path = "m/84'/0'/0'/1/" + str(subkey_count)
												subkey = k.subkey_for_path(d_path)
												if str(subkey.address()) == the_address:
													key = subkey.wif_key()
													found = True
													break
												else:
													subkey_count += 1
									else:
										self.showBitcoinwallet(walletname)
													
								if found:
									secret = CBitcoinSecret(key)
									message = BitcoinMessage(msg)
									
									filename_list = pathtomessage.split("/")
									filenameMessage = str(filename_list[-1])
									
									signature = SignMessage(secret, message)
									address_ = P2PKHBitcoinAddress.from_pubkey(secret.pub)
									
									test_check = VerifyMessage(address_, message, signature)
									if test_check:
										show_QR_with_signature(signature, filenameMessage)
									else:
										tk.messagebox.showinfo('Information', 'There was a problem to sign the message and address.')
								else:
									tk.messagebox.showinfo('Information', 'The Address is not from this wallet.')
									self.showBitcoinwallet(walletname)
				except FileNotFoundError:
					messagebox.showinfo("Information", "There are no Bitcoin wallets here yet.")
		else:
			self.showBitcoinwallet(walletname)
	
	def signBitcoinMessage(self, walletname):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=644,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
		
		w_icon_path = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
		if os.path.isfile(w_icon_path):
			pathtoWalletIconimage = w_icon_path
			walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(100, 100))
		else:
			pathtoWalletIconimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
			walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(230, 100))
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if os.path.isfile(w_icon_path):
			Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=100, height=100, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			Button1.pack(padx=80, pady=8, side= TOP, anchor="w")
		else:
			Button1 = ctk.CTkButton(left_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=220, height=100, font=my_font, command=partial(self.showBitcoinwallet, walletname))
			Button1.pack(padx=10, pady=8, side= TOP, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=14, slant="roman", underline=False, overstrike=False)
		Llabel1 = ctk.CTkLabel(left_Frame, text=walletname + ' - Signing Bitcoin message', text_color="white", font=my_font, fg_color="black")
		Llabel1.pack(padx=1, pady=0, side= TOP, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		nameLabel = ctk.CTkLabel(right_Frame, text=walletname, text_color="dark orange", font=my_font, fg_color="black")
		nameLabel.place(relx=0.5, rely=0.08, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		infoLabel = ctk.CTkLabel(right_Frame, text="To sign a Bitcoin message you need to have two seperate textfiles OR two QR-codes containing:", text_color="white", font=my_font, fg_color="black")
		infoLabel.place(relx=0.5, rely=0.16, anchor="center")
		infoLabel2 = ctk.CTkLabel(right_Frame, text="(1) The public Bitcoin address associated with the wallet, and;", text_color="white", font=my_font, fg_color="black")
		infoLabel2.place(relx=0.5, rely=0.24, anchor="center")
		infoLabel22 = ctk.CTkLabel(right_Frame, text="(2) The Bitcoin message that needs to be signed.", text_color="white", font=my_font, fg_color="black")
		infoLabel22.place(relx=0.5, rely=0.29, anchor="center")
		infoLabel3 = ctk.CTkLabel(right_Frame, text="Make sure you have the files (or QR-codes) ready before you start.", text_color="white", font=my_font, fg_color="black")
		infoLabel3.place(relx=0.5, rely=0.35, anchor="center")
		infoLabel4 = ctk.CTkLabel(right_Frame, text="A signature can prove ownership for a wallet without giving up any private information (keys)!", text_color="white", font=my_font, fg_color="black")
		infoLabel4.place(relx=0.5, rely=0.42, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		filesButton = ctk.CTkButton(right_Frame, text="Sign with files", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=250, height=38, font=my_font, command=partial(self.signBitcoinMessageFiles, walletname))
		filesButton.place(relx=0.5, rely=0.55, anchor="center")
		orLabel = ctk.CTkLabel(right_Frame, text="Or,", text_color="dark orange", font=my_font, fg_color="black")
		orLabel.place(relx=0.5, rely=0.64, anchor="center")
		QRButton = ctk.CTkButton(right_Frame, text="Sign with QR-codes *", text_color="white", fg_color="dark orange", border_width=2, border_color="white", width=250, height=38, font=my_font, command=partial(self.signBitcoinMessageQR, walletname))
		QRButton.place(relx=0.5, rely=0.73, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="italic", underline=False, overstrike=False)
		infoLabel5 = ctk.CTkLabel(right_Frame, text="* Fully Air-gapped.", text_color="white", font=my_font, fg_color="black")
		infoLabel5.place(relx=0.5, rely=0.82, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		backButton = ctk.CTkButton(right_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
	
	def editWalletInformation(self, walletname):
		global filepathdestinationfolder
		global path_to_USB_secure
		global System_button_color
		global walletDescription
		global owners_name
		global walletReference
		global ownerAddr1
		global ownerAddr2
		
		global statementReceiver
		global statementReference
		global receiver_name
		global receiver_addr
		global receiver_addr2
			
		walletDescription = ''
		owners_name = 'N/A'
		walletReference = ''
		ownerAddr1 = ''
		ownerAddr2 = ''
		
		statementReceiver = ''
		statementReference = ''
		receiver_name = 'N/A'
		receiver_addr = ''
		receiver_addr2 = ''
		
		def update_icon():
			tk.messagebox.showinfo('Information', 'Connect the USB-device with the new icon and then click \"OK\".')
			time.sleep(2)
			messagebox.showinfo("Information", "Select the picture for your wallet icon (\".png\" or \".jpg\" format)")
			time.sleep(2)
			pathtopicture = filedialog.askopenfilename(initialdir='/media/user1')
			
			filename_list = pathtopicture.split(".")
			filename_ending = str(filename_list[-1])
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
			
			if filename_ending == 'JPG' or filename_ending == 'jpg':
				img_open = Image.open(pathtopicture)
				img_open.save(pathtopicturearchivelocation)
			elif filename_ending == 'PNG' or filename_ending == 'png':
				img_open = Image.open(pathtopicture).convert("RGB")
				img_open.save(pathtopicturearchivelocation)
			else:
				messagebox.showinfo("Information", "The wallet icon image needs to be \".png\" or \".jpg\" format!")
			self.editWalletInformation(walletname)
		
		def delete_icon():
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
			
			pathtoicon = filepathdestinationfolder + "/secure/wallets/" + walletname + '.jpg'
			
			# Check if there is an icon
			if os.path.isfile(pathtoicon):
				os.remove(pathtoicon)
			self.editWalletInformation(walletname)
				
		def update_wallet():
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			Updated_walletDescription = walletDescriptionEntry.get()
			Updated_walletReference = walletReferenceEntry.get()
			Updated_owner_name = owner_name_Entry.get()
			Updated_walletownerAddr1 = walletownerAddr1Entry.get()
			Updated_walletownerAddr2 = walletownerAddr2Entry.get()
			
			Updated_statementReceiver = statementReceiverEntry.get()
			Updated_statementReference = statementReferenceEntry.get()
			Updated_receiver_name = receiver_name_Entry.get()
			Updated_receiver_addr = receiver_addrEntry.get()
			Updated_receiver_addr2 = receiver_addr2Entry.get()
			
			completeName = str(filepathdestinationfolder) + "/secure/wallets/" + walletname + ".csv"
			
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				new_wallet_information = [
										Updated_walletDescription,
										Updated_walletReference,
										Updated_owner_name,
										Updated_walletownerAddr1,
										Updated_walletownerAddr2,
										Updated_statementReceiver,
										Updated_statementReference,
										Updated_receiver_name,
										Updated_receiver_addr,
										Updated_receiver_addr2]

				csvwriter.writerow(new_wallet_information)
			
			self.showBitcoinwallet(walletname)
		
		def get_wallet_information_if_any():
			global walletDescription
			global walletReference
			global owners_name
			global ownerAddr1
			global ownerAddr2
			
			global statementReceiver
			global statementReference
			global receiver_name
			global receiver_addr
			global receiver_addr2
			
			completeName = str(filepathdestinationfolder) + "/secure/wallets/" + walletname + ".csv"

			# Check if file exists.
			if not os.path.isfile(completeName):
				return False
			else:
				try:
					f = open(completeName, 'r')
					for row in csv.reader(f):
						walletDescription = row[0]
						walletReference = row[1]
						owners_name = row[2]
						ownerAddr1 = row[3]
						ownerAddr2 = row[4]
						statementReceiver = row[5]
						statementReference = row[6]
						receiver_name = row[7]
						receiver_addr = row[8]
						receiver_addr2 = row[9]
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No wallet information file found.")
				return True
					
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		get_wallet_information_if_any()
		check_var = ctk.StringVar(value="on")
		owners_name_var = StringVar(value=owners_name)
		
		def limitSizewalletDescription(*args):
			value = walletDescription_var.get()
			if len(value) > 35: walletDescription_var.set(value[:35])
			
		def limitSizeOwnersname(*args):
			value = owners_name_var.get()
			if len(value) > 35: owners_name_var.set(value[:35])
		
		def limitSizewalletReference(*args):
			value = walletReference_var.get()
			if len(value) > 35: walletReference_var.set(value[:35])
		
		def limitSizeownerAddr1(*args):
			value = ownerAddr1_var.get()
			if len(value) > 35: ownerAddr1_var.set(value[:35])
			
		def limitSizeownerAddr2(*args):
			value = ownerAddr2_var.get()
			if len(value) > 35: ownerAddr2_var.set(value[:35])
		#############################################################		
		
		def limitSizestatementReceiver(*args):
			value = statementReceiver_var.get()
			if len(value) > 50: statementReceiver_var.set(value[:50])
			
		def limitSizestatementReference(*args):
			value = statementReference_var.get()
			if len(value) > 50: statementReference_var.set(value[:50])
			
		def limitSizeReceivername(*args):
			value = receiver_name_var.get()
			if len(value) > 50: receiver_name_var.set(value[:50])
			
		def limitSizereceiver_addr(*args):
			value = receiver_addr_var.get()
			if len(value) > 50: receiver_addr_var.set(value[:50])
		
		def limitSizereceiver_addr2(*args):
			value = receiver_addr2_var.get()
			if len(value) > 50: receiver_addr2_var.set(value[:50])
				
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Update wallet information:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.3, rely=0.1, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		walletDescriptionLabel = ctk.CTkLabel(my_Frame, text="Wallet description:", text_color="white", fg_color="black", font=my_font)
		walletDescriptionLabel.place(relx=0.18, rely=0.24, anchor="e")
		
		referenceLabel = ctk.CTkLabel(my_Frame, text="Reference:", text_color="white", fg_color="black", font=my_font)
		referenceLabel.place(relx=0.18, rely=0.3, anchor="e")
		ownerLabel = ctk.CTkLabel(my_Frame, text="Owners name:", text_color="white", fg_color="black", font=my_font)
		ownerLabel.place(relx=0.18, rely=0.36, anchor="e")
		addr1Label = ctk.CTkLabel(my_Frame, text="Owners address:", text_color="white", fg_color="black", font=my_font)
		addr1Label.place(relx=0.18, rely=0.44, anchor="e")
		addr2Label = ctk.CTkLabel(my_Frame, text="Owners address 2:", text_color="white", fg_color="black", font=my_font)
		addr2Label.place(relx=0.18, rely=0.5, anchor="e")
		
		walletDescription_var = ctk.StringVar(value=walletDescription)
		walletDescription_var.trace('w', limitSizewalletDescription)
		walletDescriptionEntry = ctk.CTkEntry(my_Frame, placeholder_text=walletDescription, textvariable=walletDescription_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		walletDescriptionEntry.place(relx=0.2, rely=0.24, anchor="w")
		
		walletReference_var = ctk.StringVar(value=walletReference)
		walletReference_var.trace('w', limitSizewalletReference)
		walletReferenceEntry = ctk.CTkEntry(my_Frame, placeholder_text=walletReference, textvariable=walletReference_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		walletReferenceEntry.place(relx=0.2, rely=0.3, anchor="w")
		
		owners_name_var = ctk.StringVar(value=owners_name)
		owners_name_var.trace('w', limitSizeOwnersname)			
		owner_name_Entry = ctk.CTkEntry(my_Frame, placeholder_text=owners_name, textvariable=owners_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		owner_name_Entry.place(relx=0.2, rely=0.36, anchor="w")
		
		ownerAddr1_var = ctk.StringVar(value=ownerAddr1)	
		ownerAddr1_var.trace('w', limitSizeownerAddr1)			
		walletownerAddr1Entry = ctk.CTkEntry(my_Frame, placeholder_text=ownerAddr1, textvariable=ownerAddr1_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		walletownerAddr1Entry.place(relx=0.2, rely=0.44, anchor="w")
		
		ownerAddr2_var = ctk.StringVar(value=ownerAddr2)	
		ownerAddr2_var.trace('w', limitSizeownerAddr2)			
		walletownerAddr2Entry = ctk.CTkEntry(my_Frame, placeholder_text=ownerAddr2, textvariable=ownerAddr2_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		walletownerAddr2Entry.place(relx=0.2, rely=0.5, anchor="w")
		
		statementReceiverLabel = ctk.CTkLabel(my_Frame, text="Statement receiver:", text_color="white", fg_color="black", font=my_font)
		statementReceiverLabel.place(relx=0.68, rely=0.24, anchor="e")
		
		reference2Label = ctk.CTkLabel(my_Frame, text="Reference:", text_color="white", fg_color="black", font=my_font)
		reference2Label.place(relx=0.68, rely=0.3, anchor="e")
		receiverLabel = ctk.CTkLabel(my_Frame, text="Receiver name:", text_color="white", fg_color="black", font=my_font)
		receiverLabel.place(relx=0.68, rely=0.36, anchor="e")
		addr1Label = ctk.CTkLabel(my_Frame, text="Receiver address:", text_color="white", fg_color="black", font=my_font)
		addr1Label.place(relx=0.68, rely=0.44, anchor="e")
		addr2Label = ctk.CTkLabel(my_Frame, text="Receiver address 2:", text_color="white", fg_color="black", font=my_font)
		addr2Label.place(relx=0.68, rely=0.5, anchor="e")
		
		statementReceiver_var = ctk.StringVar(value=statementReceiver)
		statementReceiver_var.trace('w', limitSizestatementReceiver)			
		statementReceiverEntry = ctk.CTkEntry(my_Frame, placeholder_text=statementReceiver, textvariable=statementReceiver_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		statementReceiverEntry.place(relx=0.7, rely=0.24, anchor="w")
		
		statementReference_var = ctk.StringVar(value=statementReference)
		statementReference_var.trace('w', limitSizestatementReference)		
		statementReferenceEntry = ctk.CTkEntry(my_Frame, placeholder_text=statementReference, textvariable=statementReference_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		statementReferenceEntry.place(relx=0.7, rely=0.3, anchor="w")
		
		receiver_name_var = ctk.StringVar(value=receiver_name)
		receiver_name_var.trace('w', limitSizeReceivername)			
		receiver_name_Entry = ctk.CTkEntry(my_Frame, placeholder_text=receiver_name, textvariable=receiver_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		receiver_name_Entry.place(relx=0.7, rely=0.36, anchor="w")
		
		receiver_addr_var = ctk.StringVar(value=receiver_addr)
		receiver_addr_var.trace('w', limitSizereceiver_addr)		
		receiver_addrEntry = ctk.CTkEntry(my_Frame, placeholder_text=receiver_addr, textvariable=receiver_addr_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		receiver_addrEntry.place(relx=0.7, rely=0.44, anchor="w")
		
		receiver_addr2_var = ctk.StringVar(value=receiver_addr2)
		receiver_addr2_var.trace('w', limitSizereceiver_addr2)		
		receiver_addr2Entry = ctk.CTkEntry(my_Frame, placeholder_text=receiver_addr2, textvariable=receiver_addr2_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		receiver_addr2Entry.place(relx=0.7, rely=0.5, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		pathtoicon = filepathdestinationfolder + "/secure/wallets/" + walletname + '.jpg'
		if os.path.isfile(pathtoicon):
			iconImage = ctk.CTkImage(light_image=Image.open(pathtoicon), dark_image=Image.open(pathtoicon), size=(140, 140))
			Label_icon = ctk.CTkLabel(my_Frame, image=iconImage, text = "")
			Label_icon.place(relx=0.2, rely=0.7, anchor="center")
		else:
			noIconLabel = ctk.CTkLabel(my_Frame, text="<no icon>", text_color="white", fg_color="black", font=my_font)
			noIconLabel.place(relx=0.2, rely=0.7, anchor="center")
		
		updateiconButton = ctk.CTkButton(my_Frame, text="New icon", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=update_icon)
		updateiconButton.place(relx=0.45, rely=0.69, anchor="e")
		
		deleteiconButton = ctk.CTkButton(my_Frame, text="Delete icon", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=delete_icon)
		deleteiconButton.place(relx=0.45, rely=0.75, anchor="e")
		
		updateButton = ctk.CTkButton(my_Frame, text="Update wallet information", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=update_wallet)
		updateButton.place(relx=0.9, rely=0.7, anchor="e")
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
		backButton.place(relx=0.5, rely=0.92, anchor="center")
	
	def create_DigitalIDbox(self):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=0,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")		
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=650,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=0, anchor="nw")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
		counting = 0
		FirstID = 'empty'
		
		# Go through ID csv-file to get the first entry (if any)
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if counting == 0:
							FirstID	= lines[1]
							counting+=1
		except FileNotFoundError:
			print("No CSV file found")
			
		if FirstID != 'empty':
			self.showID(FirstID)
		else:
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			Buttonnew = ctk.CTkButton(right_Frame, text="New ID", text_color="white", fg_color=DigitalID_button_color, border_width=2, border_color="white", width=150, height=20, font=my_font, command=self.create_newID)
			Buttonnew.place(relx=0.88, rely=0.07, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			
			infoLabel = ctk.CTkLabel(right_Frame, text="You have no Digital ID's yet!", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.5, rely=0.28, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			infoLabel2 = ctk.CTkLabel(right_Frame, text="A Digital ID needs to be based on an encryption key.\n\nIt should be a key dedicated only to the Digital ID\n\n(and not a key used for encrypted email communication etc).", text_color="white", font=my_font, fg_color="black")
			infoLabel2.place(relx=0.5, rely=0.5, anchor="center")
			
			AddkeyButton = ctk.CTkButton(right_Frame, text="Create new encryption key for ID", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.newGPGFull_Key, "none"))
			AddkeyButton.place(relx=0.5, rely=0.72, anchor="center")
			right_Frame.lift()
			right_Frame.focus_set()
			right_Frame.focus_force()
	
	def showID_missing(self, IDfingerprint):
		global filepathdestinationfolder
		
		def remove_ID():
			completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
			answer = messagebox.askquestion('Warning!', 'Warning! You are about to remove permenantly an ID.\n\nAre you SURE you want to proceed?')
			if answer == 'yes':
				temp_file_ = completeName + ".tmp"
				
				if os.path.isfile(completeName):
					with open(completeName, 'r') as inp, open(temp_file_, 'w') as out:
						writer = csv.writer(out)
						for row in csv.reader(inp):
							if row[1] != IDfingerprint:
								writer.writerow(row)	
					shutil.copy(temp_file_, completeName)
					if os.path.isfile(temp_file_):
						os.remove(temp_file_)
				self.create_DigitalIDbox()
						
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=648,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		ID_Frame = ctk.CTkFrame(right_Frame, 
		width=720, 
		height=460,
		border_width=2,
		border_color="brown",
		fg_color="light pink"
		)
		ID_Frame.place(x=80, y=40, anchor="nw")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(716, 456))
		Label_backg = ctk.CTkLabel(ID_Frame, image=backg, text = "")
		Label_backg.place(relx=0, rely=0, anchor="nw")
		
		bottom_Frame = ctk.CTkScrollableFrame(right_Frame, 
		width=700, 
		height=90,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="light pink"
		)
		bottom_Frame._scrollbar.configure(height=0)
		
		pathtobackg = "/home/user1/images/vectorIDart.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		pathtoIDicon = filepathdestinationfolder + "/Pictures/ID_ICON_default.jpg"
									
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			completeName = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
			pathtoIDicon = filepathdestinationfolder + "/Pictures/ID_ICON_default.jpg"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if lines[1] == IDfingerprint:
								temppathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + lines[1] + ".jpg"
								if os.path.isfile(temppathtoIDicon):
									pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + lines[1] + ".jpg"
			except FileNotFoundError:
				messagebox.showinfo("Information", "No IDsss file found.")
			IDcardiconimage = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(240, 140))
								
			Button1 = ctk.CTkButton(left_Frame, text="", image = IDcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=200, height=127, font=my_font, command=partial(self.showID_missing, IDfingerprint))
			Button1.pack(padx=20, pady=8, side= TOP, anchor="w")
				
			my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			
			infoLabel = ctk.CTkLabel(right_Frame, text="The Digital ID's is missing the encryption key!", text_color="white", font=my_font, fg_color="black")
			infoLabel.place(relx=0.5, rely=0.28, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			infoLabel2 = ctk.CTkLabel(right_Frame, text="Key Fingerprint: " + IDfingerprint, text_color="white", font=my_font, fg_color="black")
			infoLabel2.place(relx=0.5, rely=0.5, anchor="center")
			
			AddkeyButton = ctk.CTkButton(right_Frame, text="Import key for ID", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.importGPG_Key)
			AddkeyButton.place(relx=0.5, rely=0.72, anchor="center")
			removekeyButton = ctk.CTkButton(right_Frame, text="Remove ID", text_color="white", fg_color='red', border_width=2, border_color="white", width=170, height=32, font=my_font, command=remove_ID)
			removekeyButton.place(relx=0.5, rely=0.79, anchor="center")
			backButton = ctk.CTkButton(right_Frame, text="Back", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_DigitalIDbox)
			backButton.place(relx=0.5, rely=0.88, anchor="center")

		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
			
	def showID(self, IDfingerprint):
		global newIDflag
		global filepathdestinationfolder
		global bg_img
		global resize_QR_address_img
		global IDPhotoImage
		
		non_dup = True
		bottom_frame_color = 'light pink'
		special_label_color = 'old lace'
		fg_c = 'black'
		
		def export_front_image():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', "Select the directory where you want to save the ID's frontside image.")
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			full_path = outputdir + '/ID_' + IDfingerprint[-8:] + '_fronside.png'
			
			x0 = ID_Frame.winfo_rootx() + 2
			y0 = ID_Frame.winfo_rooty() + 2
			x1 = x0 + 718
			y1 = y0 + 458
			im = ImageGrab.grab(bbox=(x0, y0, x1, y1))
			im.save(full_path)
			
			tk.messagebox.showinfo('Information', 'Processing the image. This can take some time. Press OK to start.')
			statusText = "The ID's frontside image has been written to file."
			os.system("sync")
			time.sleep(1)
			self.unmount_USBs(statusText)
			new_record = [IDfingerprint, "ID.", 'Exported ID front image.']
			self.add_record(new_record)
			
			self.showID(IDfingerprint)
		
		def export_back_image():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', "Select the directory where you want to save the ID's backside image.")
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			full_path = outputdir + '/ID_' + IDfingerprint[-8:] + '_backside.png'
			
			x0 = ID_Frame.winfo_rootx() + 2
			y0 = ID_Frame.winfo_rooty() + 2
			x1 = x0 + 718
			y1 = y0 + 458
			im = ImageGrab.grab(bbox=(x0, y0, x1, y1))
			im.save(full_path)
			
			tk.messagebox.showinfo('Information', 'Processing the image. This can take some time. Press OK to start.')
			statusText = "The ID's backside image has been written to file."
			os.system("sync")
			time.sleep(1)
			self.unmount_USBs(statusText)
			new_record = [IDfingerprint, "ID.", 'Exported ID front image.']
			self.add_record(new_record)
			
			self.showID(IDfingerprint)
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		left_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=278, 
		height=634,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color="gray1"
		)
		left_Frame.place(relx=0, rely=0, anchor="nw")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(260, 630))
		Label_backg = ctk.CTkLabel(left_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		right_Frame = ctk.CTkFrame(my_Frame, 
		width=900, 
		height=648,
		border_width=2,
		border_color="brown"
		)
		right_Frame.place(x=300, y=2, anchor="nw")
		
		ID_Frame = ctk.CTkFrame(right_Frame, 
		width=720, 
		height=460,
		border_width=2,
		border_color="brown",
		fg_color="light pink"
		)
		ID_Frame.place(x=80, y=40, anchor="nw")
		
		pathtobackg = "/home/user1/images/vectorIDart.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(716, 456))
		Label_backg = ctk.CTkLabel(ID_Frame, image=backg, text = "")
		Label_backg.place(relx=0, rely=0, anchor="nw")
		
		color_setting = 'none'
		completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						color_setting = lines[1]
		except FileNotFoundError:
			logged_in_user = '<no settings file found>'
		
		if color_setting == 'Dark':
			bottom_frame_color = 'black'
			special_label_color = 'black'
			fg_c = 'white'
		
		bottom_Frame = ctk.CTkScrollableFrame(right_Frame, 
		width=700, 
		height=90,
		orientation="vertical",
		border_width=2,
		border_color="brown",
		fg_color=bottom_frame_color
		)
		bottom_Frame._scrollbar.configure(height=0)
		
		def key_available(current_ID):
			its_there = False
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
			private_keys = []
			
			private_keys = gpg.list_keys(True)
			mapp = private_keys.key_map

			for i in private_keys:
				if i['fingerprint'] == current_ID:
					its_there = True
			return its_there
		
		def flipBackID():
			ID_Frame3 = ctk.CTkFrame(right_Frame, 
			width=720, 
			height=460,
			border_width=2,
			border_color="brown",
			fg_color="light pink"
			)
			ID_Frame3.place(x=80, y=40, anchor="nw")
			
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
					
			if color_setting == 'Dark':
				pathtobackg = "/home/user1/images/black.png"
			else:	
				pathtobackg = "/home/user1/images/vectorIDart.jpg"
			
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(716, 456))
			Label_backg = ctk.CTkLabel(ID_Frame3, image=backg, text = "")
			Label_backg.place(relx=0, rely=0, anchor="nw")
			
			ID_Frame3.focus_force()
			ID_Frame3.focus_set()
			completeName = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if lines[1] == IDfingerprint:
								if key_available(lines[1]):
									tc = 'black'
									temp_pic_path = "/home/user1/secure/ID/tmppic.png"
									if os.path.isfile(temp_pic_path):
										os.remove(temp_pic_path)
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									
									# Image resize and open as PhotoImage for QR-code
									QR_address = qrcode.make(lines[1], version=1)
									resize_QR_address = QR_address.resize((180, 180))
									
									pathtoQRaddress = str(filepathdestinationfolder) + "/secure/ID/QRaddress.png"
									
									resize_QR_address.save(pathtoQRaddress)
									
									# Get key photo (if any) and save as file
									photo_path = "/home/user1/secure/ID"
									command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + IDfingerprint
									os.system(command)
									
									# Show image
									pic_icon_path = photo_path + '/pic' + IDfingerprint[-8:] + '.jpg'
									nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
									if os.path.isfile(pic_icon_path):
										final_pic_icon_path = pic_icon_path
									else:
										final_pic_icon_path = nopic_icon_path
									
									IDimge = Image.open(final_pic_icon_path).resize((200,230))
									
									IDimge.save(temp_pic_path)
									
									self.resize_QR_address_img = resize_QR_address_img = PhotoImage(file=r'/home/user1/secure/ID/QRaddress.png')
									
									# Check what front image and color on text
									ID_data1 = []
									if lines[5] != 'empty' and lines[5] != '<empty>': # New ID with data (after version 0.5.0
										ID_data1 = ast.literal_eval(lines[5])
										if ID_data1[0] == 'Upload my own':
											self.bg_img = bg_img = PhotoImage(file="/home/user1/secure/ID/" + lines[1] + "_front.png")
										elif ID_data1[0] == 'White': # 
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/white.png")
										elif ID_data1[0] == 'Black': # 
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/black.png")
										else:
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/ID_map.png")
										if ID_data1[2] == 'White': # The text color should be white
											tc = 'white'
									else:
										self.bg_img = bg_img = PhotoImage(file=r'/home/user1/images/ID_map.png')
									
									self.ID_image = ID_image = PhotoImage(file='/home/user1/secure/ID/tmppic.png')
									
									canvas_map = Canvas(ID_Frame3, width=720, height=460)
									canvas_map.pack(fill="both", expand=True)
									
									canvas_map.create_image(0,0, image=bg_img, anchor="nw") 
									canvas_map.create_image(18,110, image=resize_QR_address_img, anchor="nw") 
									canvas_map.create_image(490,82, image=ID_image, anchor="nw") 							
									
									#Create texts
									my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
									canvas_map.create_text(360,42, text=lines[0], fill=tc, anchor="center", font=my_font)
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="normal", slant="roman", underline=False, overstrike=False)
									my_font2 = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									
									canvas_map.create_text(205,115, text="First name:", fill=tc, anchor="nw", font=my_font)
									if len(lines[2]) < 15:
										canvas_map.create_text(315,115, text=lines[2], fill=tc, anchor="nw", font=my_font2)
									else:
										canvas_map.create_text(210,140, text=lines[2], fill=tc, anchor="nw", font=my_font2)
									canvas_map.create_text(205,160, text="Last name:", fill=tc, anchor="nw", font=my_font)
									if len(lines[3]) < 15 and len(lines[4]) < 15:	
										canvas_map.create_text(315,165, text=lines[3], fill=tc, anchor="nw", font=my_font2)
										if lines[4] != '<empty>':
											canvas_map.create_text(315,190, text=lines[4], fill=tc, anchor="nw", font=my_font2)
									else:
										canvas_map.create_text(210,190, text=lines[3], fill=tc, anchor="nw", font=my_font2)
										canvas_map.create_text(210,215, text=lines[4], fill=tc, anchor="nw", font=my_font2)
										
									canvas_map.create_text(205,240, text="Gender:", fill=tc, anchor="nw", font=my_font)
									canvas_map.create_text(315,240, text=lines[7], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(205,265, text="Birthdate:", fill=tc, anchor="nw", font=my_font)
									canvas_map.create_text(315,265, text=lines[6], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(60,360, text="Key ID:", fill=tc, anchor="nw", font=my_font2)
									canvas_map.create_text(140,360, text=lines[1], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(215,395, text="Encryption standard RFC 4880.", fill=tc, anchor="nw", font=my_font2)							
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									exportButton = ctk.CTkButton(right_Frame, text="Export image", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=32, font=my_font, command=export_front_image)
									exportButton.place(relx=0.1, rely=0.03, anchor="center")
									flipButton = ctk.CTkButton(right_Frame, text="Flip", text_color="white", fg_color="brown", border_width=2, border_color="white", width=80, height=22, font=my_font, command=flipID)
									flipButton.place(relx=0.84, rely=0.8, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No ID file found.")
										
		def flipID():
			ID_Frame3 = ctk.CTkFrame(right_Frame, 
			width=720, 
			height=460,
			border_width=2,
			border_color="brown",
			fg_color="light pink"
			)
			ID_Frame3.place(x=80, y=40, anchor="nw")
			
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
					
			if color_setting == 'Dark':
				pathtobackg = "/home/user1/images/black.png"
			else:	
				pathtobackg = "/home/user1/images/vectorIDart.jpg"
			
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(716, 456))
			Label_backg = ctk.CTkLabel(ID_Frame3, image=backg, text = "")
			Label_backg.place(relx=0, rely=0, anchor="nw")
			
			ID_Frame3.focus_force()
			ID_Frame3.focus_set()
			completeName = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if lines[1] == IDfingerprint:
								if key_available(lines[1]):
									tc = 'black'
									backlines = ['', '', '', '', '', '']
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									
									# Check text color and what back images and if/what backside text exists
									ID_data1 = []
									if lines[5] != 'empty' and lines[5] != '<empty>': # New ID with data (after version 0.5.0
										ID_data1 = ast.literal_eval(lines[5])
										if ID_data1[0] == 'Upload my own':
											self.bg_img = bg_img = PhotoImage(file="/home/user1/secure/ID/" + lines[1] + "_back.png")
										elif ID_data1[0] == 'White': # 
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/white.png")
										elif ID_data1[0] == 'Black': # 
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/black.png")
										else:
											self.bg_img = bg_img = PhotoImage(file="/home/user1/images/ID_map.png")
										if ID_data1[2] == 'White': # The text color should be white
											tc = 'white'
										if len(ID_data1) == 8:
											backlines[0] = ID_data1[3]
											backlines[1] = ID_data1[4]
											backlines[2] = ID_data1[5]
											backlines[3] = ID_data1[6]
											backlines[4] = ID_data1[7]
											backlines[5] = 'For more information please visit www.gnupg.org:'
											
										else:
											backlines[0] = 'To access the credentials for this Digital ID please use the'
											backlines[1] = 'identifying numbers (fingerprint). Also available as QR-code.'
											backlines[2] = 'Credential access and verification for this ID is based on the'
											backlines[3] = 'GnuPG, Public keyservers and the Web of trust.'
											backlines[4] = 'Standard used: RFC4880 (PGP)'
											backlines[5] = 'For more information please visit www.gnupg.org:'
									else:
										self.bg_img = bg_img = PhotoImage(file=r'/home/user1/images/ID_map.png')
										backlines[0] = 'To access the credentials for this Digital ID please use the'
										backlines[1] = 'identifying numbers (fingerprint). Also available as QR-code.'
										backlines[2] = 'Credential access and verification for this ID is based on the'
										backlines[3] = 'GnuPG, Public keyservers and the Web of trust.'
										backlines[4] = 'Standard used: RFC4880 (PGP)'
										backlines[5] = 'For more information please visit www.gnupg.org:'
									
									self.ID_image = ID_image = PhotoImage(file='/home/user1/secure/ID/tmppic.png')
									self.barcode_image = barcode_image = PhotoImage(file='/home/user1/images/barcode_GnuPG.png')
									
									canvas_map = Canvas(ID_Frame3, width=720, height=460)
									canvas_map.pack(fill="both", expand=True)
									
									canvas_map.create_image(0,0, image=bg_img, anchor="nw")
									canvas_map.create_image(360,410, image=barcode_image, anchor="center") 							
									#Create texts
									my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
									my_font2 = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
									
									canvas_map.create_text(355,100, text=backlines[0], fill=tc, anchor="center", font=my_font)
									
									canvas_map.create_text(355,140, text=backlines[1], fill=tc, anchor="center", font=my_font)
										
									canvas_map.create_text(355,180, text=backlines[2], fill=tc, anchor="center", font=my_font)
									
									canvas_map.create_text(355,220, text=backlines[3], fill=tc, anchor="center", font=my_font)
									
									canvas_map.create_text(355,300, text=backlines[4], fill=tc, anchor="center", font=my_font2)
									
									canvas_map.create_text(355,366, text=backlines[5], fill=tc, anchor="center", font=my_font2)	
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									exportButton = ctk.CTkButton(right_Frame, text="Export image", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=32, font=my_font, command=export_back_image)
									exportButton.place(relx=0.1, rely=0.03, anchor="center")
									flipbackButton = ctk.CTkButton(right_Frame, text="Flip", text_color="white", fg_color="brown", border_width=2, border_color="white", width=80, height=22, font=my_font, command=flipBackID)
									flipbackButton.place(relx=0.84, rely=0.8, anchor="center")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No ID file found.")
			
		def remove_ID():
			completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
			answer = messagebox.askquestion('Warning!', 'Warning! You are about to remove permenantly an ID.\n\nAre you SURE you want to proceed?')
			if answer == 'yes':
				temp_file_ = completeName + ".tmp"
				
				if os.path.isfile(completeName):
					with open(completeName, 'r') as inp, open(temp_file_, 'w') as out:
						writer = csv.writer(out)
						for row in csv.reader(inp):
							if row[1] != IDfingerprint:
								writer.writerow(row)	
					shutil.copy(temp_file_, completeName)
					if os.path.isfile(temp_file_):
						os.remove(temp_file_)
				self.create_DigitalIDbox()
					
		def create_ICON():
			global newIDflag
			pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + IDfingerprint + ".jpg"
			pathtotemppic = filepathdestinationfolder + '/ID.jpg'
			if os.path.isfile(pathtotemppic):
				os.remove(pathtotemppic)
			x0 = ID_Frame.winfo_rootx()
			y0 = ID_Frame.winfo_rooty()
			x1 = x0 + 720
			y1 = y0 + 460
			im = ImageGrab.grab(bbox=(x0, y0, x1, y1))
			im.save(pathtoIDicon)
			newIDflag = False
			pathdest = filepathdestinationfolder + "/secure/ID/picture" + IDfingerprint + ".jpg"
			if os.path.isfile(pathdest):
				os.remove(pathdest)
			
			# Backup the updated private key to the secure archive
			ascii_armored_private_key = gpg.export_keys(IDfingerprint, True, expect_passphrase=False)
			completeName = filepathdestinationfolder + '/secure/keys/' + 'privateKey' + IDfingerprint + '.gpg' 
			f2 = open(completeName, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			new_record = [IDfingerprint, "ID.", 'Added photo.']
			self.add_record(new_record)
			self.create_DigitalIDmeny()
				
		if color_setting == 'Dark':
			bottom_frame_color = 'black'
			fg_c = 'white'
			pathtobackg = "/home/user1/images/black.png"
		else:	
			pathtobackg = "/home/user1/images/vectorIDart.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(896, 646))
		Label_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
		Counting = 0
		FirstID = 'empty'
		
		# Check that the key is still available on the local keychain
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')

		private_keys = []
		
		private_keys = gpg.list_keys(True)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							found_ = False
							if not newIDflag:
								# Check if key is available for each line in the CSV-file. If yes check if ICON photo is available
								for i in private_keys:
									if lines[1] == i['fingerprint']: 
										found_ = True
										# Check if ICON photo is available
										pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + lines[1] + ".jpg"
										if os.path.isfile(pathtoIDicon):
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
										else:
											pathtoIDicon = filepathdestinationfolder + "/Pictures/ID_ICON_default.jpg"
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
								# If there is a entry for an ID in the CSV-file but private key could not be found on the local keychain		
								if not found_:
									# Look for default file in secure archive for the key backup
									default_path = filepathdestinationfolder + '/secure/keys/privateKey' + lines[1] + '.gpg'
									try:
										import_result = gpg.import_keys_file(default_path)
										gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_ULTIMATE')
									except:
										print("Key import failed")
									
									pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + lines[1] + ".jpg"
									if key_available(lines[1]):
										if os.path.isfile(pathtoIDicon):
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
										else:
											pathtoIDicon = filepathdestinationfolder + "/Pictures/ID_ICON_default.jpg"
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
									else:
										pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + lines[1] + ".jpg"
										if os.path.isfile(pathtoIDicon):
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID_missing, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
										else:
											pathtoIDicon = filepathdestinationfolder + "/Pictures/ID_ICON_default.jpg"
											IDimagebutton = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(200, 120))
											Button1 = ctk.CTkButton(left_Frame, text="", image = IDimagebutton, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="brown", width=200, height=120, font=my_font, command=partial(self.showID_missing, lines[1]))
											Button1.pack(padx=40, pady=18, side= TOP, anchor="w")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No ID file found.")
			
			completeName = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if lines[1] == IDfingerprint:
								if key_available(lines[1]):
									tc = 'black'
									temp_pic_path = "/home/user1/secure/ID/tmppic.png"
									if os.path.isfile(temp_pic_path):
										os.remove(temp_pic_path)
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									Buttonnew = ctk.CTkButton(right_Frame, text="New ID", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=32, font=my_font, command=self.create_newID)
									Buttonnew.place(relx=0.9, rely=0.03, anchor="center")
									# Make a canvas with background images
									
									# Image resize and open as PhotoImage for QR-code
									QR_address = qrcode.make(lines[1], version=1)
									resize_QR_address = QR_address.resize((180, 180))
									
									pathtoQRaddress = str(filepathdestinationfolder) + "/secure/ID/QRaddress.png"
									
									resize_QR_address.save(pathtoQRaddress)
									
									# Get key photo (if any) and save as file
									photo_path = "/home/user1/secure/ID"
									command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + IDfingerprint
									os.system(command)
									
									# Show image
									pic_icon_path = photo_path + '/pic' + IDfingerprint[-8:] + '.jpg'
									nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
									if os.path.isfile(pic_icon_path) and not newIDflag:
										final_pic_icon_path = pic_icon_path
									else:
										# This could be in the creation phase of new ID
										pathdest = filepathdestinationfolder + "/secure/ID/picture" + IDfingerprint + ".jpg"
										
										if os.path.isfile(pathdest):
											final_pic_icon_path = pathdest
										else:
											final_pic_icon_path = nopic_icon_path
									
									IDimge = Image.open(final_pic_icon_path).resize((200,230))
									
									IDimge.save(temp_pic_path)
									
									self.resize_QR_address_img = resize_QR_address_img = PhotoImage(file=r'/home/user1/secure/ID/QRaddress.png')
									
									# Check what front and back images and if/what backside text exists
									ID_data1 = []
									if lines[5] != 'empty' and lines[5] != '<empty>': # New ID with data (after version 0.5.0
										ID_data1 = ast.literal_eval(lines[5])
										print(ID_data1)
										print(ID_data1[0])
										if ID_data1[0] == 'Upload my own':
											bg_img = PhotoImage(file="/home/user1/secure/ID/" + lines[1] + "_front.png")
										elif ID_data1[0] == 'White': # 
											bg_img = PhotoImage(file="/home/user1/images/white.png")
										elif ID_data1[0] == 'Black': # 
											bg_img = PhotoImage(file="/home/user1/images/black.png")
										else:
											bg_img = PhotoImage(file="/home/user1/images/ID_map.png")
										if ID_data1[2] == 'White': # The text color should be white
											tc = 'white'
									else:
										bg_img = PhotoImage(file=r'/home/user1/images/ID_map.png')
									
									self.ID_image = ID_image = PhotoImage(file=r'/home/user1/secure/ID/tmppic.png')
									
									canvas_map = Canvas(ID_Frame, width=720, height=460)
									canvas_map.pack(fill="both", expand=True)
									
									canvas_map.create_image(0,0, image=bg_img, anchor="nw") 
									canvas_map.create_image(18,115, image=resize_QR_address_img, anchor="nw") 
									canvas_map.create_image(490,87, image=ID_image, anchor="nw") 							
									
									#Create texts
									my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
									canvas_map.create_text(360,42, text=lines[0], fill=tc, anchor="center", font=my_font)
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="normal", slant="roman", underline=False, overstrike=False)
									my_font2 = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									
									canvas_map.create_text(205,115, text="First name:", fill=tc, anchor="nw", font=my_font)
									if len(lines[2]) < 15:
										canvas_map.create_text(315,115, text=lines[2], fill=tc, anchor="nw", font=my_font2)
									else:
										canvas_map.create_text(210,140, text=lines[2], fill=tc, anchor="nw", font=my_font2)
									canvas_map.create_text(205,160, text="Last name:", fill=tc, anchor="nw", font=my_font)
									if len(lines[3]) < 15 and len(lines[4]) < 15:	
										canvas_map.create_text(315,165, text=lines[3], fill=tc, anchor="nw", font=my_font2)
										if lines[4] != '<empty>':
											canvas_map.create_text(315,190, text=lines[4], fill=tc, anchor="nw", font=my_font2)
									else:
										canvas_map.create_text(210,190, text=lines[3], fill=tc, anchor="nw", font=my_font2)
										canvas_map.create_text(210,215, text=lines[4], fill=tc, anchor="nw", font=my_font2)
										
									canvas_map.create_text(205,240, text="Gender:", fill=tc, anchor="nw", font=my_font)
									canvas_map.create_text(315,240, text=lines[7], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(205,265, text="Birthdate:", fill=tc, anchor="nw", font=my_font)
									canvas_map.create_text(315,265, text=lines[6], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(60,360, text="Key ID:", fill=tc, anchor="nw", font=my_font2)
									canvas_map.create_text(140,360, text=lines[1], fill=tc, anchor="nw", font=my_font2)
									
									canvas_map.create_text(215,395, text="Encryption standard RFC 4880.", fill=tc, anchor="nw", font=my_font2)							
									
									my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
									exportButton = ctk.CTkButton(right_Frame, text="Export image", text_color="white", fg_color="brown", border_width=2, border_color="white", width=150, height=32, font=my_font, command=export_front_image)
									exportButton.place(relx=0.1, rely=0.03, anchor="center")
									moreButton = ctk.CTkButton(right_Frame, text="More options", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.showID_more, IDfingerprint))
									moreButton.place(relx=0.72, rely=0.03, anchor="center")
									ID_Frame.lift()	
									bottom_Frame.lift()
									gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
					
									# Get sigs for the selected key
									public_keys = gpg.list_keys(sigs=True)
									
									if newIDflag:
										messagebox.showinfo("Information", "In the terminal window that will open, type \"addphoto\" and hit Enter. Enter name of photo as \"ID.jpg\" and hit Enter. Follow the instructions. Type \"quit\" when finished. To close the terminal window type \"exit\" and hit Enter.")
										pathtopic = filepathdestinationfolder + "/secure/ID/picture" + IDfingerprint + ".jpg"
										pathtotemppic = filepathdestinationfolder + '/ID.jpg'
										shutil.copy(pathtopic, pathtotemppic)
										command= 'gpg --edit-key ' + IDfingerprint
										os.system("lxterminal -e 'bash -c \""+command+";bash\"'") 
										ID_Frame.lift()	
										messagebox.showinfo("Information", "In the terminal window that will open, type \"addphoto\" and hit Enter. Enter name of photo as \"ID.jpg\" and hit Enter. Follow the instructions. Type \"quit\" when finished. To close the terminal window type \"exit\" and hit Enter.")
										my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
										ID_Frame.lift()
										time.sleep(2)
										
										nextButton = ctk.CTkButton(right_Frame, text="CLICK TO COMPLETE ID!", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=200, height=40, font=my_font, command=create_ICON)
										nextButton.place(relx=0.5, rely=0.85, anchor="center")
									else:
										flipButton = ctk.CTkButton(right_Frame, text="Update thumbnail", text_color="white", fg_color="brown", border_width=2, border_color="white", width=80, height=22, font=my_font, command=create_ICON)
										flipButton.place(relx=0.68, rely=0.8, anchor="center")
										flipButton = ctk.CTkButton(right_Frame, text="Flip", text_color="white", fg_color="brown", border_width=2, border_color="white", width=80, height=22, font=my_font, command=flipID)
										flipButton.place(relx=0.84, rely=0.8, anchor="center")
										bottom_Frame.place(x=80, y=535, anchor="nw")
										valiLabel = ctk.CTkLabel(right_Frame, text="ID-key validations (signatures): ", text_color=fg_c, font=my_font, fg_color=special_label_color)
										valiLabel.place(x=80, y=506, anchor="nw")
									temp_list = []	
									for i in public_keys:
										if i['fingerprint'] == IDfingerprint and i['sigs']: 
											my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
									
											tuple_of_sigs_in_key = i['sigs']
											for ii in tuple_of_sigs_in_key:
												if ii:
													if ii[0] != i['keyid']:
														keyID = ii[0]
														user_id = ii[1]
														signature_class = ii[2]
														if keyID not in temp_list: 
																Label = ctk.CTkLabel(bottom_Frame, text= ' ' +  user_id, text_color=fg_c, fg_color=bottom_frame_color, font=my_font)
																Label.pack(padx=10, pady=1, side= TOP, anchor="w")
														temp_list.append(keyID)
														
								# If there is no key available show default text only						
								else:
									my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			
									infoLabel = ctk.CTkLabel(right_Frame, text="The Digital ID's is missing the encryption key!", text_color="white", font=my_font, fg_color="black")
									infoLabel.place(relx=0.5, rely=0.28, anchor="center")
									my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
									infoLabel2 = ctk.CTkLabel(right_Frame, text="Key Fingerprint: " + IDfingerprint, text_color="white", font=my_font, fg_color="black")
									infoLabel2.place(relx=0.5, rely=0.5, anchor="center")
									
									AddkeyButton = ctk.CTkButton(right_Frame, text="Import key for ID", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.importGPG_Key)
									AddkeyButton.place(relx=0.5, rely=0.72, anchor="center")
									removekeyButton = ctk.CTkButton(right_Frame, text="Remove ID", text_color="white", fg_color='red', border_width=2, border_color="white", width=170, height=32, font=my_font, command=remove_ID)
									removekeyButton.place(relx=0.5, rely=0.79, anchor="center")
									right_Frame.lift()
									right_Frame.focus_set()
									right_Frame.focus_force()
			except FileNotFoundError:
				messagebox.showinfo("Information", "No ID file found.")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def showID_more(self, IDfingerprint):
		global newIDflag, diceFunction
		global filepathdestinationfolder
		global bg_img
		global resize_QR_address_img
		global IDPhotoImage, key_record
		
		name_ID = ' '
		key_record = 'ID'
		diceFunction = 'showID_more'
		
		def export_key():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			ascii_armoured_public_key = gpg.export_keys(IDfingerprint)
			result = tk.messagebox.askokcancel("Information", "Insert the USB-device and then click \"OK\".")
			if not result:
				self.showID_more(IDfingerprint)
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select where to save the file with the public ID key.')
			if not result:
				self.showID_more(IDfingerprint)
				return
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="File name (optional).", prompt="Name for exported key:")
		
			if USER_INP == "" or USER_INP == " ":
				USER_INP = 'pubKey' + IDfingerprint[-8:]
			
			USER_INP_tr = USER_INP[:42] if len(USER_INP) > 42 else USER_INP
			
			c = open(outputdir + '/' + USER_INP_tr + '.gpg', 'w')
			c.write(ascii_armoured_public_key)
			c.close()
			new_record = [IDfingerprint, "Exported the public key.", '']
			self.add_record(new_record)
			tk.messagebox.showinfo('Information', 'ID Key has been exported.')
			
			self.showID_more(IDfingerprint)
			
		def add_validation():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			tk.messagebox.showinfo('Information', 'Insert the USB-device."')
			time.sleep(4)
			tk.messagebox.showinfo('Information', 'Select the file/key with the verifying signature.')
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			
			# Scan the key in the file to get the fingerprint
			keys = gpg.scan_keys(filepathSourcefile)
			key_fingerprint = ''
			key_fingerprint = str(keys.fingerprints[0])
			
			# Import the key from file to the local keychain and assign trust
			import_result = gpg.import_keys_file(filepathSourcefile)
			gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_UNDEFINED')
			
			# Sign the key on local keychain by passing argument fingerprint
			command= 'gpg --local-user ' + IDfingerprint + ' --quick-sign-key ' + key_fingerprint
			os.system(command) 
			new_record = [IDfingerprint, "Signed a public key.", key_fingerprint]
			self.add_record(new_record)
			new_record = [key_fingerprint, "Signed/validated.", "By key:" + IDfingerprint]
			self.add_record(new_record)
			self.showID_more(IDfingerprint)
		
		color_setting = 'none'
		fg_c = 'black'
		bg_c = 'white'
		special_label_color ='old lace'
		bottom_frame_color = 'light pink'
		my_frame_border_color ='light pink'
		completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						color_setting = lines[1]
		except FileNotFoundError:
			logged_in_user = '<no settings file found>'
				
		if color_setting == 'Dark':
			fg_c = 'white'
			bg_c = 'black'
			my_frame_border_color = 'black'
			bottom_frame_color ='black'
			special_label_color='black'
			pathtobackg = "/home/user1/images/black.png"
		else:	
			pathtobackg = "/home/user1/images/vectorIDart.jpg"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color=my_frame_border_color
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1100, 
		height=140,
		orientation="vertical",
		border_width=2,
		border_color='light pink',
		fg_color=bottom_frame_color
		)
		bottom_Frame._scrollbar.configure(height=0)
		bottom_Frame.place(x=40, y=431, anchor="nw")
		
		pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + IDfingerprint + ".jpg"
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] == IDfingerprint:
							name_ID=lines[2] + ' ' + lines[3]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No ID file found.")
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
			if not os.path.isfile(pathtoIDicon):
				pathtoIDicon = filepathdestinationfolder + "/images/GnuPG_keyICON.jpg"
			
			IDcardiconimage = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(400, 260))

			iconButton = ctk.CTkButton(my_Frame, text="", image = IDcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=3, border_color="white", width=396, height=254, font=my_font, command=partial(self.showID, IDfingerprint))
			iconButton.place(relx=0.04, rely=0.18, anchor="nw")
			
			my_font = ctk.CTkFont(family="Arial", size=30, weight="bold", slant="roman", underline=True, overstrike=False)
			infoLabel = ctk.CTkLabel(my_Frame, text="Standard ID: ", text_color=fg_c, font=my_font, fg_color=special_label_color)
			infoLabel.place(relx=0.5, rely=0.06, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
			info2Label = ctk.CTkLabel(my_Frame, text=name_ID, text_color=fg_c, font=my_font, fg_color=special_label_color)
			info2Label.place(relx=0.5, rely=0.12, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			validatingLabel = ctk.CTkLabel(my_Frame, text="ID-key validations (signatures): ", text_color=fg_c, font=my_font, fg_color=special_label_color)
			validatingLabel.place(x=42, y=400, anchor="nw")
				
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			#---------------------------------------------------------------
			addValidationButton = ctk.CTkButton(my_Frame, text="Add validation", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=add_validation)
			addValidationButton.place(relx=0.54, rely=0.22, anchor="center")
			addSubkeyButton = ctk.CTkButton(my_Frame, text="Add subkeys", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.newGPG_Subkey_ID, IDfingerprint))
			addSubkeyButton.place(relx=0.54, rely=0.3, anchor="center")
			photoButton = ctk.CTkButton(my_Frame, text="Change photo", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.changePhotoID, IDfingerprint))
			photoButton.place(relx=0.54, rely=0.38, anchor="center")
			recordsButton = ctk.CTkButton(my_Frame, text="View records", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.get_key_records, IDfingerprint))
			recordsButton.place(relx=0.54, rely=0.46, anchor="center")
			detailsButton = ctk.CTkButton(my_Frame, text="View details", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.get_GnuPGKeys, IDfingerprint))
			detailsButton.place(relx=0.54, rely=0.54, anchor="center")
			#---------------------------------------------------------------
			validateButton = ctk.CTkButton(my_Frame, text="Validate someones ID", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.sign_with_key_on_keychain, IDfingerprint))
			validateButton.place(relx=0.8, rely=0.22, anchor="center")
			signFileButton = ctk.CTkButton(my_Frame, text="Sign a file", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.sign_document_with_ID, IDfingerprint))
			signFileButton.place(relx=0.8, rely=0.3, anchor="center")
			signQRButton = ctk.CTkButton(my_Frame, text="Sign a QR-code", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.sign_QR_with_ID, IDfingerprint))
			signQRButton.place(relx=0.8, rely=0.38, anchor="center")
			exportIDButton = ctk.CTkButton(my_Frame, text="Export public key", text_color="white", fg_color="brown", border_width=2, border_color="white", width=250, height=36, font=my_font, command=export_key)
			exportIDButton.place(relx=0.8, rely=0.46, anchor="center")
			deleteButton = ctk.CTkButton(my_Frame, text="Delete ID", text_color="white", fg_color="red4", border_width=2, border_color="white", width=250, height=36, font=my_font, command=partial(self.do_deleteID, IDfingerprint))
			deleteButton.place(relx=0.8, rely=0.54, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			# Get sigs for the selected key
			public_keys = gpg.list_keys(sigs=True)
			temp_list = []				
			for i in public_keys:
				if i['fingerprint'] == IDfingerprint and i['sigs']: 
					my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
			
					tuple_of_sigs_in_key = i['sigs']
					for ii in tuple_of_sigs_in_key:
						if ii:
							if ii[0] != i['keyid']:
								keyID = ii[0]
								user_id = ii[1]
								signature_class = ii[2]
								if keyID not in temp_list:
									Label = ctk.CTkLabel(bottom_Frame, text= keyID + '  ' +  user_id + '  ' + signature_class, text_color=fg_c, fg_color=bottom_frame_color, font=my_font)
									Label.pack(padx=10, pady=1, side= TOP, anchor="w")
								temp_list.append(keyID)
			bottom_Frame.lift()
			
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)		
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=140, height=32, font=my_font, command=partial(self.showID, IDfingerprint))
			backButton.place(relx=0.5, rely=0.95, anchor="center")
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def easy_sign_with_ID(self, IDfingerprint):
		global filepathdestinationfolder
		global DigitalID_button_color
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1192, 642))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=4, y=4)
		
		pathtoIDicon = filepathdestinationfolder + "/secure/ID/ICON" + IDfingerprint + ".jpg"
		
		if path_to_USB_secure == 'Secure USB folder is available':
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
			if not os.path.isfile(pathtoIDicon):
				pathtoIDicon = filepathdestinationfolder + "/images/GnuPG_keyICON.jpg"
			
			IDcardiconimage = ctk.CTkImage(light_image=Image.open(pathtoIDicon), dark_image=Image.open(pathtoIDicon), size=(480, 312))

			iconButton = ctk.CTkButton(my_Frame, text="", image = IDcardiconimage, anchor='center', text_color="white", fg_color="brown", border_width=3, border_color="white", width=396, height=254, font=my_font, command=partial(self.showID, IDfingerprint))
			iconButton.place(relx=0.5, rely=0.3, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			
			signFileButton = ctk.CTkButton(my_Frame, text="Sign File", text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=350, height=100, font=my_font, command=partial(self.easy_sign_document_with_ID, IDfingerprint))
			signFileButton.place(relx=0.33, rely=0.7, anchor="center")
			signQRButton = ctk.CTkButton(my_Frame, text="Sign QR", text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=350, height=100, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, IDfingerprint))
			signQRButton.place(relx=0.67, rely=0.7, anchor="center")
			
			bButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=DigitalID_button_color, corner_radius=12, border_width=2, border_color="white", width=250, height=60, font=my_font, command=self.create_meny)
			bButton.place(relx=0.5, rely=0.9, anchor="center")	
		else:
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)		
			
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def easy_sign_with_key(self, fingerprint):
		global filepathdestinationfolder
		global GPG_button_color, System_button_color
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1192, 642))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=4, y=4)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			# Get the alias if any
			if self.lookup_Alias_absolut(fingerprint) != "None":
				name_key = self.lookup_Alias(fingerprint)
			else:
				name_key = fingerprint[-16:]
			my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)
			
			Label = ctk.CTkLabel(my_Frame, text="Using the Private key:\n\n " + name_key, text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.23, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=34, weight="bold", slant="roman", underline=False, overstrike=False)
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			signFileButton = ctk.CTkButton(my_Frame, text="Sign File", text_color="white", fg_color=GPG_button_color, corner_radius=12, border_width=3, border_color="white", width=350, height=100, font=my_font, command=partial(self.easy_sign_document_with_ID, fingerprint))
			signFileButton.place(relx=0.33, rely=0.6, anchor="center")
			signQRButton = ctk.CTkButton(my_Frame, text="Sign QR", text_color="white", fg_color=GPG_button_color, corner_radius=12, border_width=3, border_color="white", width=350, height=100, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, fingerprint))
			signQRButton.place(relx=0.67, rely=0.6, anchor="center")
			
			bButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=System_button_color, corner_radius=8, border_width=2, border_color="white", width=250, height=60, font=my_font, command=self.create_meny)
			bButton.place(relx=0.5, rely=0.9, anchor="center")	
			
		else:
			notOKButton = ctk.CTkButton(self, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
					
	def changePhotoID(self, IDfingerprint):
		global filepathdestinationfolder
		global newIDflag
		
		result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
		if not result:
			self.showID_more(IDfingerprint)
			return
		time.sleep(2)
		result = tk.messagebox.askokcancel("Information", "Select your picture (\".jpg\" or \".png\" format) for the ID.")
		if not result:
			self.showID_more(IDfingerprint)
			return
		time.sleep(2)
		pathpic = filedialog.askopenfilename(initialdir='/media/user1')
		pathdest = filepathdestinationfolder + "/secure/ID/picture" + IDfingerprint + ".jpg"
		
		# In case it was a .png image it can be saved as .jpg
		filename_list = pathpic.split(".")
		filename_ending = str(filename_list[-1])
		
		if filename_ending == 'JPG' or filename_ending == 'jpg':
			img_open = Image.open(pathpic)
			img_open.save(pathdest)
		elif filename_ending == 'PNG' or filename_ending == 'png':
			img_open = Image.open(pathpic).convert("RGB")
			img_open.save(pathdest)
		else:
			messagebox.showinfo("Information", "The picture needs to be \".png\" or \".jpg\" format!")
			self.create_DigitalIDmeny()
			return
		newIDflag = True			
		self.showID(IDfingerprint)
	
	def changePhotoID2(self, fingerprint):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
		if not result:
			self.edit_public_key(fingerprint)
			return
		time.sleep(2)
		result = tk.messagebox.askokcancel("Information", "Select your picture (\".jpg\" or \".png\" format) for the ID.")
		if not result:
			self.edit_public_key(fingerprint)
			return
		time.sleep(2)
		pathpic = filedialog.askopenfilename(initialdir='/media/user1')
		pathKeysPic = filepathdestinationfolder + "/secure/keys/picture" + fingerprint + ".jpg"
		
		# In case it was a .png image it can be saved as .jpg
		filename_list = pathpic.split(".")
		filename_ending = str(filename_list[-1])
		
		if filename_ending == 'JPG' or filename_ending == 'jpg':
			img_open = Image.open(pathpic)
			img_open.save(pathKeysPic)
		elif filename_ending == 'PNG' or filename_ending == 'png':
			img_open = Image.open(pathpic).convert("RGB")
			img_open.save(pathKeysPic)
		else:
			messagebox.showinfo("Information", "The picture needs to be \".png\" or \".jpg\" format!")	
			self.create_GPGmeny()
			
		messagebox.showinfo("Information", "In the terminal window that will open, type \"addphoto\" and hit Enter. Enter name of photo as \"ID.jpg\" and hit Enter. Follow the instructions. Type \"quit\" when finished. To close the terminal window type \"exit\" and hit Enter.")
		pathtopic = filepathdestinationfolder + "/secure/ID/picture" + fingerprint + ".jpg"
		pathtotemppic = filepathdestinationfolder + '/ID.jpg'
		shutil.copy(pathKeysPic, pathtotemppic)
		command= 'gpg --edit-key ' + fingerprint
		os.system("lxterminal -e 'bash -c \""+command+";bash\"'") 
		my_Frame.lift()	
		messagebox.showinfo("Information", "In the terminal window that will open, type \"addphoto\" and hit Enter. Enter name of photo as \"ID.jpg\" and hit Enter. Follow the instructions. Type \"quit\" when finished. To close the terminal window type \"exit\" and hit Enter.")
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		my_Frame.lift()
		
		self.create_GPGmeny()
		
	def readQRfromCameraToSign_ID(self, fingerprint):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/seedsignerbackground.jpg"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
		self.signQRfromCamera_ID(fingerprint)
	
	def easy_readQRfromCameraToSign_ID(self, fingerprint):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Loading camera......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		
		completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
		if os.path.isfile(completeNameQRfile):
			os.remove(completeNameQRfile)
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
		self.signQRfromCamera_ID(fingerprint)
		
	def signQRfromCamera_ID(self, fingerprint):
		global clicked_privateSubKey
		global System_button_color
		
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt.sig\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt.sig', 'w', encoding='utf-8')
			c.write(str(signed_data))
			c.close()
			c2 = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c2.write(file_content)
			c2.close()
			messagebox.showinfo('Information', 'Signature file and data file has been saved to the USB-device')
			self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if path_to_USB_secure == 'Secure USB folder is available':			
			link_to_signature_data = "/home/user1/secure/QRsignaturefile.txt"
			
			if os.path.isfile(link_to_signature_data):
				try:
					f = open(link_to_signature_data, "r")
					file_content = f.read()
					f.close()
					transactiondatoavailable = True
				except OSError:
					print("No file")
				signed_data = gpg.sign(file_content, keyid=fingerprint, detach=True)
				
				signed_data_address = qrcode.make(signed_data)
									
				resize_signed_data_address = signed_data_address.resize((390, 390))
				pathtoQRsignature = str(filepathdestinationfolder) + "/secure/signatureQRmessage.png"
				
				resize_signed_data_address.save(pathtoQRsignature)
				
				loadimg = ctk.CTkImage(light_image=Image.open(pathtoQRsignature), dark_image=Image.open(pathtoQRsignature), size=(390, 390))
				
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
				
				my_font = ctk.CTkFont(family="Arial", size=30, slant="roman", underline=True, overstrike=False)
				pubLabel = ctk.CTkLabel(my_Frame, text="Signature:", text_color="white", font=my_font, fg_color="black")
				pubLabel.place(relx=0.5, rely=0.1, anchor="center")
				Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
				Labelpublicimg.place(relx=0.5, rely=0.45, anchor="center")
				users_layout = "Standard"
				completeName = str(filepathdestinationfolder) + "/secure/layout.csv"
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:	
								users_layout = lines[0]
				except FileNotFoundError:
					print("no layout file found")				
				if users_layout == "Easy":
					my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			
					bButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=System_button_color, corner_radius=40, border_width=4, border_color="white", width=250, height=80, font=my_font, command=self.create_meny)
					bButton.place(relx=0.5, rely=0.88, anchor="center")			
				else:
					my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
					saveQRButton = ctk.CTkButton(my_Frame, text="Save signature to USB", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=save_to_USB)
					saveQRButton.place(relx=0.5, rely=0.8, anchor="center")
					backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_meny)
					backButton.place(relx=0.5, rely=0.96, anchor="center")
			else:
				my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
				pubLabel = ctk.CTkLabel(my_Frame, text="Could not read QR-data", text_color="white", font=my_font, fg_color="black")
				pubLabel.place(relx=0.5, rely=0.46, anchor="center")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
				
	def sign_QR_with_ID(self, IDfingerprint):
		global clicked_privateSubKey
		global outputdir
		global GPG_button_color
		
		def do_scan():
			self.readQRfromCameraToSign_ID(IDfingerprint)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		private_fingerprints_and_aliases = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Scan a QR-code with the camera and sign the information with your ID's private key", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.16, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="This could be a hash (checksum) from a large file or a Bitcoin address etc.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.25, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="You will get an option if you like to save the detached signature as a file (.sig) or scan it back with a QR-code", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.41, anchor="center")
		
		Label4 = ctk.CTkLabel(self, text="ID's private key to sign with:", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.42, rely=0.65, anchor="e")
		Label5 = ctk.CTkLabel(self, text=IDfingerprint, text_color="white", fg_color="black", font=my_font)
		Label5.place(relx=0.43, rely=0.65, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
	
		startButton = ctk.CTkButton(self, text="Start camera", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_scan)
		startButton.place(relx=0.5, rely=0.75, anchor="center")
			
	def sign_document_with_ID(self, IDfingerprint):
		global clicked_privateSubKey 
		global GPG_button_color
		
		def start_do_sign():
			result = tk.messagebox.askokcancel("Information", "Insert USB-device and then click \"OK\".")
			if not result:
				self.showID_more(IDfingerprint)
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the document to sign.')
			if not result:
				self.showID_more(IDfingerprint)
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			tk.messagebox.showinfo('Information', 'Select the output folder for the detached signature by double clicking on it.')
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			do_sign(filepathSourcefile, outputdir)
		
		def do_new_Bitcoinwallet(TimestampAddress, totalHash, outputfilesname, filename):
		
			path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
			
			now = datetime.now()
			dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
			dt_string_short = now.strftime("%Y-%m-%d")
					
			new_paperwallet = [
								"Timestamp",
								dt_string_short,
								TimestampAddress,
								totalHash,
								filename,
								outputfilesname,
								"Not payed"]

			with open(path_to_wallets, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_paperwallet)
		
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
						
		def do_sign(filepathSourcefile, outputdir):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			filename_list = filepathSourcefile.split("/")
			filename_ = str(filename_list[-1])
			sigfilename = filename_ + '.sig'
			outputfilesname = outputdir + "/" + sigfilename
			
			with open(filepathSourcefile, 'rb') as f: 
				try:
					data_ = gpg.sign_file(f, keyid=IDfingerprint, detach=True)
					f2 = open(outputfilesname, 'w')
					f2.write(str(data_))
					f2.close()
				except ValueError as ve:
					tk.messagebox.showinfo('Information', 'Something went wrong in signing!')
			pathtobackg = self.get_background_image()
			my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			if data_.status == "signature created":
				if checkbox.get() == "on":
					# Make hash for document
					hashForDocument = sha256Hex(filepathSourcefile)
					
					# Make hash for signature
					hashForSignature = sha256Hex(outputfilesname)
					
					# Make combined hash for combination of document and signature hashes
					totalHash = hashForSignature + hashForDocument
					
					# Hash a Bitcoin address from the combined hash
					addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
					
					signatureAddress = addr.address
					
					# Generate a Bitcoin transaction including amount of 1100 sats to the newly hashed address
					transaction_payload = "bitcoin:" + signatureAddress + '?amount=0.00001100'
					
					# Clear screen and re-fill
					backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
					Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
					Label_backg.place(x=0, y=0)
		
					Label1 = ctk.CTkLabel(my_Frame, text="Signing a document with your ID's private key", text_color="white", fg_color="black", font=my_font)
					Label1.place(relx=0.5, rely=0.1, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label2 = ctk.CTkLabel(my_Frame, text="The signature file and the document together has created below QR- transaction.", text_color="white", fg_color="black", font=my_font)
					Label2.place(relx=0.5, rely=0.2, anchor="center")
					
					Label3 = ctk.CTkLabel(my_Frame, text="Scan the transaction QR-code and pay it and thereby making a proof on the Bitcoin blockchain.", text_color="white", fg_color="black", font=my_font)
					Label3.place(relx=0.5, rely=0.25, anchor="center")
					
					# Create a QR-code for the transaction
					pathtosignature = qrcode.make(transaction_payload)
					resize_pathtosignature = pathtosignature.resize((280, 280))
					pathtotransactionsignature = str(filepathdestinationfolder) + "/secure/transactionsignature.png"
					resize_pathtosignature.save(pathtotransactionsignature)
					loadimg = ctk.CTkImage(light_image=Image.open(pathtotransactionsignature), dark_image=Image.open(pathtotransactionsignature), size=(280, 280))
					Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
					Labelpublicimg.place(relx=0.72, rely=0.56, anchor="center")
					
					# Add the signatures transaction in the paper wallets CSV-file
					do_new_Bitcoinwallet(signatureAddress, totalHash, sigfilename, filename_)
					
					my_font = ctk.CTkFont(family="Arial", size=36, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="Success!", text_color="light green", font=my_font, fg_color="black")
					pubLabel.place(relx=0.35, rely=0.46, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=34, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.35, rely=0.55, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
					outLabel = ctk.CTkLabel(my_Frame, text="Output file:", text_color="white", font=my_font, fg_color="black")
					outLabel.place(relx=0.35, rely=0.64, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
					pubLabel2 = ctk.CTkLabel(my_Frame, text=sigfilename, text_color="white", font=my_font, fg_color="black")
					pubLabel2.place(relx=0.35, rely=0.7, anchor="center")
					scanLabel = ctk.CTkLabel(my_Frame, text="Pay address *:", text_color="white", fg_color="black", font=my_font)
					scanLabel.place(relx=0.72, rely=0.31, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label11 = ctk.CTkLabel(my_Frame, text="* Sending bitcoin to the stated address records the event (hashed proof) on the Bitcoin Blockchain.", text_color="white", fg_color="black", font=my_font)
					Label11.place(relx=0.1, rely=0.88, anchor="w")
					backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showID_more, IDfingerprint))
					backButton.place(relx=0.5, rely=0.94, anchor="center")
				else:
					backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
					Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
					Label_backg.place(x=0, y=0)
					
					Label4 = ctk.CTkLabel(my_Frame, text="Signing a document with your ID's private key", text_color="white", fg_color="black", font=my_font)
					Label4.place(relx=0.5, rely=0.1, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label5 = ctk.CTkLabel(my_Frame, text="The signature file has been created.", text_color="white", fg_color="black", font=my_font)
					Label5.place(relx=0.5, rely=0.2, anchor="center")
					
					Label6 = ctk.CTkLabel(my_Frame, text="Keep the signature file and the document file in the same directory.", text_color="white", fg_color="black", font=my_font)
					Label6.place(relx=0.5, rely=0.25, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=36, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel3 = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
					pubLabel3.place(relx=0.5, rely=0.5, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=False, overstrike=False)
					pubLabel4 = ctk.CTkLabel(my_Frame, text="(" + sigfilename + ")", text_color="white", font=my_font, fg_color="black")
					pubLabel4.place(relx=0.5, rely=0.62, anchor="center")
					backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.showID_more, IDfingerprint))
					backButton.place(relx=0.5, rely=0.9, anchor="center")
			else:
				tk.messagebox.showinfo('Alert!', 'Something went wrong!')	
				self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		private_fingerprints_and_aliases = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signing a document with your ID's private key", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select what document to sign and where to place the document after signing.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.2, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="The output will be a file with a detached signature (.sig) in the folder that you selected.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.25, anchor="center")

		private_keys = gpg.list_keys(True)
				
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		check_var = ctk.StringVar(value="off")
		
		checkbox = ctk.CTkCheckBox(my_Frame, text="Create timestamp *", font=my_font, variable=check_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox.place(relx=0.5, rely=0.57, anchor="center")
		
		Label4 = ctk.CTkLabel(my_Frame, text="ID's private key for signing:", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.4, rely=0.5, anchor="e")
		Label5 = ctk.CTkLabel(my_Frame, text=IDfingerprint, text_color="white", fg_color="black", font=my_font)
		Label5.place(relx=0.41, rely=0.5, anchor="w")
		
		Button = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=start_do_sign)
		Button.place(relx=0.5, rely=0.68, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
	
		Label6 = ctk.CTkLabel(my_Frame, text="* A Bitcoin transaction is needed for timestamping the document/signature combination.", text_color="white", fg_color="black", font=my_font)
		Label6.place(relx=0.2, rely=0.92, anchor="w")
	
	def easy_sign_document_with_ID(self, IDfingerprint):
		global clicked_privateSubKey 
		global GPG_button_color
		
		def start_do_sign():
			result = tk.messagebox.askokcancel("Information", "Insert USB-device and then click \"OK\".")
			if not result:
				self.create_meny()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the document to sign.')
			if not result:
				self.create_meny()
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			
			do_sign(filepathSourcefile)
						
		def do_sign(filepathSourcefile):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			filename_list = filepathSourcefile.split("/")
			filepath_ = os.path.dirname(filepathSourcefile)
			filename_ = str(filename_list[-1])
			sigfilename = filename_ + '.sig'
			outputfilesname = filepath_ + "/" + sigfilename
			
			with open(filepathSourcefile, 'rb') as f: 
				try:
					data_ = gpg.sign_file(f, keyid=IDfingerprint, detach=True)
					f2 = open(outputfilesname, 'w')
					f2.write(str(data_))
					f2.close()
				except ValueError as ve:
					tk.messagebox.showinfo('Information', 'Something went wrong in signing!')
			pathtobackg = self.get_background_image()
			my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=True, overstrike=False)
			if data_.status == "signature created":
				backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
				Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
				Label_backg.place(x=0, y=0)
				
				my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
				pubLabel3 = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
				pubLabel3.place(relx=0.5, rely=0.3, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=32, slant="roman", underline=False, overstrike=False)
				pubLabel4 = ctk.CTkLabel(my_Frame, text="(" + sigfilename + ")", text_color="white", font=my_font, fg_color="black")
				pubLabel4.place(relx=0.5, rely=0.45, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
				
				statusText = 'Information'
				self.unmount_USBs(statusText)
				
				bButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="brown", corner_radius=40, border_width=4, border_color="white", width=250, height=80, font=my_font, command=self.create_meny)
				bButton.place(relx=0.5, rely=0.72, anchor="center")	
			else:
				tk.messagebox.showinfo('Alert!', 'Something went wrong!')	
				self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		private_fingerprints_and_aliases = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select a document to sign from a USB-device.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.32, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="The signature file (.sig) is placed in the same folder as the original file.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.44, anchor="center")

		my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			
		bButton = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color="brown", corner_radius=40, border_width=4, border_color="white", width=250, height=80, font=my_font, command=start_do_sign)
		bButton.place(relx=0.5, rely=0.68, anchor="center")	
				
	def easy_sign_document(self, IDfingerprint):
		global clicked_privateSubKey 
		global GPG_button_color
		
		def start_do_sign():
			result = tk.messagebox.askokcancel("Information", "Insert USB-device and then click \"OK\".")
			if not result:
				self.create_meny()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the document to sign.')
			if not result:
				self.create_meny()
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			
			do_sign(filepathSourcefile)
						
		def do_sign(filepathSourcefile):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			filename_list = filepathSourcefile.split("/")
			filepath_ = os.path.dirname(filepathSourcefile)
			filename_ = str(filename_list[-1])
			sigfilename = filename_ + '.sig'
			outputfilesname = filepath_ + "/" + sigfilename
			
			with open(filepathSourcefile, 'rb') as f: 
				try:
					data_ = gpg.sign_file(f, keyid=IDfingerprint, detach=True)
					f2 = open(outputfilesname, 'w')
					f2.write(str(data_))
					f2.close()
				except ValueError as ve:
					tk.messagebox.showinfo('Information', 'Something went wrong in signing!')
			pathtobackg = self.get_background_image()
			my_font = ctk.CTkFont(family="Arial", size=32, weight="bold", slant="roman", underline=True, overstrike=False)
			if data_.status == "signature created":
				backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
				Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
				Label_backg.place(x=0, y=0)
				
				my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
				pubLabel3 = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
				pubLabel3.place(relx=0.5, rely=0.3, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=32, slant="roman", underline=False, overstrike=False)
				pubLabel4 = ctk.CTkLabel(my_Frame, text="(" + sigfilename + ")", text_color="white", font=my_font, fg_color="black")
				pubLabel4.place(relx=0.5, rely=0.45, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
				
				statusText = 'Information'
				self.unmount_USBs(statusText)
							
				bButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="brown", corner_radius=40, border_width=4, border_color="white", width=250, height=80, font=my_font, command=self.create_meny)
				bButton.place(relx=0.5, rely=0.72, anchor="center")	
			else:
				tk.messagebox.showinfo('Alert!', 'Something went wrong!')	
				self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		start_do_sign()
		
	def sign_with_key_on_keychain(self, IDfingerprint):
		global answer, filename_key
		
		answer = 'no'
		
		def do_sign_key_on_keychain():
			global clicked_privateKey
			global clicked_publicKey
			global answer, filename_key
			
			clicked_publicKey = str(clicked2.get())
			if answer != 'yes':
				decoded_publifingerprint = self.lookup_fingerprint(clicked_publicKey)
			else:
				decoded_publifingerprint = import_result.fingerprints[0]
				
			my_Frame = ctk.CTkFrame(self, 
			width=1200, 
			height=650,
			border_width=4,
			border_color="blue"
			)
			my_Frame.place(relx=0.5, rely=0.6, anchor="center")
			
			pathtobackg = self.get_background_image()
		
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			if answer != 'yes':				
				# Sign the public key
				command= 'gpg --local-user ' + IDfingerprint + ' --quick-sign-key ' + decoded_publifingerprint
				os.system(command) 
				new_record = [IDfingerprint, "Signed a public key.", decoded_publifingerprint]
				self.add_record(new_record)
				new_record = [decoded_publifingerprint, "Signed/validated.", "By key:" + IDfingerprint]
				self.add_record(new_record)
				tk.messagebox.showinfo('Information', 'Please check that the key on the local keychain was signed.')
			else:
				# Warning about signing others keys without proper due diligence 
				answer2 = messagebox.askquestion('Information!', 'IMPORTANT! Only sign a key that you have receive in person or that are verified using a Passport, Photo ID etc.\n\nAre you SURE you want to proceed?')
				if answer2 == 'yes':
					# Sign the public key and save as file
					command= 'gpg --local-user ' + IDfingerprint + ' --quick-sign-key ' + decoded_publifingerprint
					os.system(command) 

					tk.messagebox.showinfo('Information', 'Select where to save the signed public key.')
					time.sleep(2)
					outputdir = filedialog.askdirectory(initialdir='/media/user1')
					full_path_filename_key = outputdir + '/Signed_' + filename_key
					ascii_armored_public_key = gpg.export_keys(decoded_publifingerprint) 
					f2 = open(full_path_filename_key, 'w')
					f2.write(ascii_armored_public_key)
					f2.close()
					new_record = [IDfingerprint, "Signed a public key.", decoded_publifingerprint]
					self.add_record(new_record)
					new_record = [decoded_publifingerprint, "Signed/validated.", "By key:" + IDfingerprint]
					self.add_record(new_record)
					tk.messagebox.showinfo('Information', 'Signed key has been saved as file:\n\n\"Signed_' + filename_key + '\"')
				
			self.create_meny()
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signing a public key using one of your private keys", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.22, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		answer = messagebox.askquestion('Important!', 'Is the public key that should be signed on a external USB-device?')
		if answer == 'yes':
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the file with the GPG-key to sign.')
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			filename_list = filepathSourcefile.split("/")
			filename_key = str(filename_list[-1])
			
			import_result = gpg.import_keys_file(filepathSourcefile)
			
			gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_FULLY') 
		
		public_keys = gpg.list_keys()
				
		clicked2 = StringVar()
			
		List_fingerprints = []

		public_fingerprints_and_aliases = []
		
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i2['fingerprint'])
		
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No public keys."')
		else:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
				
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label5 = ctk.CTkLabel(my_Frame, text="The private key to sign with:", text_color="white", fg_color="black", font=my_font)
		Label5.place(relx=0.4, rely=0.4, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label52 = ctk.CTkLabel(my_Frame, text=IDfingerprint, text_color="white", fg_color="black", font=my_font)
		Label52.place(relx=0.41, rely=0.4, anchor="w")
		
		if answer == 'yes':
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
			Label6 = ctk.CTkLabel(my_Frame, text="Public key loaded from USB-file:", text_color="white", fg_color="black", font=my_font)
			Label6.place(relx=0.4, rely=0.49, anchor="e")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
			Label7 = ctk.CTkLabel(my_Frame, text=import_result.fingerprints[0], text_color="white", fg_color="black", font=my_font)
			Label7.place(relx=0.41, rely=0.49, anchor="w")
		else:
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
			Label6 = ctk.CTkLabel(my_Frame, text="Select the public key you want to sign:", text_color="white", fg_color="black", font=my_font)
			Label6.place(relx=0.4, rely=0.55, anchor="e")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.41, rely=0.55, anchor="w")
		Button2 = ctk.CTkButton(my_Frame, text="Sign the public key", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_sign_key_on_keychain)
		Button2.place(relx=0.63, rely=0.64, anchor="w")
			
	def newGPG_Subkey_ID(self, IDfingerprint):		
		global PersonalGPGKey
		global GPG_button_color
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_newGPGSubkey():
			global clicked_privateSubKey
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			key = gpg.add_subkey(IDfingerprint, algorithm='rsa4096', usage='sign', expire=combo.get())
			key = gpg.add_subkey(IDfingerprint, algorithm='rsa4096', usage='encrypt', expire=combo.get())
			key = gpg.add_subkey(IDfingerprint, algorithm='rsa4096', usage='auth', expire=combo.get())
			
			# Make a backup with the new subkeys
			privatekeyfilename = 'privateKey' + IDfingerprint + ".gpg"
			full_path_private = "/home/user1/secure/keys/" + privatekeyfilename
			
			ascii_armored_private_key = gpg.export_keys(IDfingerprint, True, expect_passphrase=False)
			
			f2 = open(full_path_private, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			
			tk.messagebox.showinfo('Information', 'Subkey\'s has been added to local keychain.\nA new backup of the key has been placed in the secure archive.')
			new_record = [IDfingerprint, "Added new subkeys.", '']
			self.add_record(new_record)
			self.add_history("Added new subkeys to key: " + IDfingerprint)
			self.showID_more(IDfingerprint)
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Create subkeys for ID (key)", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="\"Encryption\", \"Signature\" and \"Authentication\"- subkeys will all be created all at once.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.16, anchor="w")
		Label3 = ctk.CTkLabel(my_Frame, text="The subkeys will be RSA-type and 4096 in length. Three years (\"3y\") is a good validity period for subkey\'s.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.23, anchor="w")

		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			
		Label4 = ctk.CTkLabel(my_Frame, text="Subkeys will be added to ID-key:", font=my_font, text_color="white", fg_color="black")
		Label4.place(relx=0.4, rely=0.4, anchor="e")
		Label5 = ctk.CTkLabel(my_Frame, text=IDfingerprint, font=my_font, text_color="white", fg_color="black")
		Label5.place(relx=0.41, rely=0.4, anchor="w")

		Label6 = ctk.CTkLabel(my_Frame, text="Select expiry date for subkey\'s:", font=my_font, text_color="white", fg_color="black")
		Label6.place(relx=0.4, rely=0.48, anchor="e")
		combo = ttk.Combobox(my_Frame, values = ["1y","3y"], justify='right')
		combo.current(1)
		combo.place(relx=0.64, rely=0.48, anchor="w")
		Button2 = ctk.CTkButton(my_Frame, text="Add subkeys to ID", text_color="white", fg_color="brown", font=my_font, border_width=2, border_color="white", command=do_newGPGSubkey)
		Button2.place(relx=0.65, rely=0.56, anchor="w")
								
	def do_deleteID(self, IDfingerprint):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_IDs = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
		updated_path_to_IDs = str(filepathdestinationfolder) + "/secure/ID/updatedIDs.csv"
		with open(path_to_IDs, 'r') as source, open(updated_path_to_IDs, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[1] == IDfingerprint:
						answer = messagebox.askquestion('Important!', 'Are you sure you want to delete the ID?\nRemember also to replace/destroy any backups that has this ID stored! \n\nThe encryption key needs to be deleted separately (see \"GPG-menu\").')
						if answer == 'yes':
							print("Not sure")
						else:
							csvwriter.writerow(row)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_IDs, path_to_IDs)
		os.remove(updated_path_to_IDs)	
		self.create_DigitalIDmeny()
		
	def create_newID(self):
		global System_button_color
		global filepathdestinationfolder
		global newIDflag
		global PersonalGPGKey
		
		std_header = 'Digital ID'
		logged_in_user = '< Not logged in >'
		
		def limitSizeheaderLabel(*args):
			value = headerEntry.get()
			if len(value) > 34: headerLabel_var.set(value[:34])
			
		def limitSizenameLabel(*args):
			value = nameEntry.get()
			if len(value) > 24: nameLabel_var.set(value[:24])
		
		def limitSizelastnameLabel(*args):
			value = lastnameEntry.get()
			if len(value) > 24: lastnameLabel_var.set(value[:24])
			
		def limitSizelastnameLabel2(*args):
			value = lastnameEntry2.get()
			if len(value) > 24: lastname2Label_var.set(value[:24])
		
		def limitSizeline1Label(*args):
			value = line1Entry.get()
			if len(value) > 60: line1Label_var.set(value[:60])
		
		def limitSizeline2Label(*args):
			value = line2Entry.get()
			if len(value) > 60: line2Label_var.set(value[:60])
			
		def limitSizeline3Label(*args):
			value = line3Entry.get()
			if len(value) > 60: line3Label_var.set(value[:60])
			
		def limitSizeline4Label(*args):
			value = line4Entry.get()
			if len(value) > 60: line4Label_var.set(value[:60])
		
		def limitSizeline5Label(*args):
			value = line5Entry.get()
			if len(value) > 60: line5Label_var.set(value[:60])
				
		def do_newID():
			global newIDflag
			pictures_backside_text_list = []
			alreadyThere = False
			today = date.today()
			
			clicked_privateKey = str(clicked.get())
			thedate = cal.get_date()
			clicked_Sex = clicked2.get()
			datetoday = today.strftime('%d/%m/%Y')
			
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			entry_header = headerEntry.get()
			entry_name = nameEntry.get()
			entry_lastname = lastnameEntry.get()
			entry_lastname2 = lastnameEntry2.get()
			
			# Set front and back images
			if clicked_front.get() == 'Upload my own':
				result = tk.messagebox.askokcancel('Information', 'Connect the USB-device with the FRONTSIDE image then click \"OK\".')
				
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				result = tk.messagebox.askokcancel('Information', 'Select the frontside image (.jpg or .png format).')
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				pathpic = filedialog.askopenfilename(initialdir='/media/user1')
				
				# In case it was a .png image it can be saved as .jpg
				filename_list = pathpic.split(".")
				filename_ending = str(filename_list[-1])
				
				pathdest = filepathdestinationfolder + "/secure/ID/" + decoded_fingerprint + "_front.png"
				
				if filename_ending == 'JPG' or filename_ending == 'jpg':
					img_open = Image.open(pathpic)
					resized_img_open = img_open.resize((754, 460))
					resized_img_open.save(pathdest)
				elif filename_ending == 'PNG' or filename_ending == 'png':
					img_open = Image.open(pathpic).convert("RGB")
					resized_img_open = img_open.resize((754, 460))
					resized_img_open.save(pathdest)
				else:
					messagebox.showinfo("Information", "The image needs to be \".png\" or \".jpg\" format!")
					self.create_DigitalIDmeny()
					return
				pictures_backside_text_list.append('Upload my own')
			else:
				pictures_backside_text_list.append(clicked_front.get())
				
			if clicked_back.get() == 'Upload my own':
				result = tk.messagebox.askokcancel('Information', 'Connect the USB-device with the BACKSIDE image then click \"OK\".')
				
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				result = tk.messagebox.askokcancel('Information', 'Select the backside image (.jpg or .png format).')
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				pathpic = filedialog.askopenfilename(initialdir='/media/user1')
				
				# In case it was a .png image it can be saved as .jpg
				filename_list = pathpic.split(".")
				filename_ending = str(filename_list[-1])
				
				pathdest = filepathdestinationfolder + "/secure/ID/" + decoded_fingerprint + "_back.png"
				
				if filename_ending == 'JPG' or filename_ending == 'jpg':
					img_open = Image.open(pathpic)
					resized_img_open = img_open.resize((754, 460))
					resized_img_open.save(pathdest)
				elif filename_ending == 'PNG' or filename_ending == 'png':
					img_open = Image.open(pathpic).convert("RGB")
					resized_img_open = img_open.resize((754, 460))
					resized_img_open.save(pathdest)
				else:
					messagebox.showinfo("Information", "The image needs to be \".png\" or \".jpg\" format!")
					self.create_DigitalIDmeny()
					return
				pictures_backside_text_list.append('Upload my own')
			else:
				pictures_backside_text_list.append(clicked_back.get())
			
			if checkbox2.get() == 'on':   #text color is white
				pictures_backside_text_list.append('White')
			else:
				pictures_backside_text_list.append('Black')
			
			if checkbox4.get() == "on": # Use custom text on backside
				pictures_backside_text_list.append(line1Entry.get())
				pictures_backside_text_list.append(line2Entry.get())
				pictures_backside_text_list.append(line3Entry.get())
				pictures_backside_text_list.append(line4Entry.get())
				pictures_backside_text_list.append(line5Entry.get())
			
			if checkbox.get() == "on": # Use ID photo from the Secure archive
				result = tk.messagebox.askokcancel('Information', 'Select your ID (face) picture (.jpg or .png format).')
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				pathpic = filedialog.askopenfilename(initialdir='/home/user1/secure')
			else:
				result = tk.messagebox.askokcancel('Information', 'Connect the USB-device with the ID (face) picture (.jpg or .png format) and then click \"OK\".')
				
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				result = tk.messagebox.askokcancel('Information', 'Select the ID (face) picture.')
				if not result:
					tk.messagebox.showinfo('Information', 'Cancelling new ID.')
					self.create_DigitalIDbox()
					return
				time.sleep(2)
				pathpic = filedialog.askopenfilename(initialdir='/media/user1')
			pathdest = filepathdestinationfolder + "/secure/ID/picture" + decoded_fingerprint + ".jpg"	
			
			# In case it was a .png image it can be saved as .jpg
			filename_list = pathpic.split(".")
			filename_ending = str(filename_list[-1])
			
			if filename_ending == 'JPG' or filename_ending == 'jpg':
				img_open = Image.open(pathpic)
				img_open.save(pathdest)
			elif filename_ending == 'PNG' or filename_ending == 'png':
				img_open = Image.open(pathpic).convert("RGB")
				img_open.save(pathdest)
			else:
				messagebox.showinfo("Information", "The wallet icon image needs to be \".png\" or \".jpg\" format!")
				self.create_DigitalIDmeny()
				return
			
			new_ID = [
								entry_header,
								decoded_fingerprint,
								entry_name,
								entry_lastname,
								entry_lastname2,
								pictures_backside_text_list,
								str(thedate),
								clicked_Sex,
								datetoday]
			
			completeName = filepathdestinationfolder + "/secure/ID/IDs.csv"
			# Check if ID already exists for the selected key
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if lines[1] == decoded_fingerprint:
							alreadyThere = True
			if not alreadyThere:
				with open(completeName, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_ID)
				newIDflag = True
				new_record = [decoded_fingerprint, "ID linked to key.", entry_name + ' ' + entry_lastname]
				self.add_record(new_record)
				self.add_history("Made new ID linked to key: " + decoded_fingerprint)
				self.showID(decoded_fingerprint)
			else:
				tk.messagebox.showinfo('Information', 'There already exists an ID for the selected key."')
				self.create_DigitalIDmeny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							logged_in_user = lines[0]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		private_keys = gpg.list_keys(True)
		
		clicked = StringVar()
			
		List_fingerprints = []
		private_fingerprints_and_aliases = []
		
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
									
		List_Sex = ['Male', 'Female']
		List_images = ['World map', 'White', 'Black', 'Upload my own']
		
		clicked = StringVar()
		clicked2 = StringVar()
		clicked_front = StringVar()
		clicked_back = StringVar()
		
		private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
		clicked.set(private_fingerprints_and_aliases[0])
		privatekeysavailable = True
			
		clicked.set(private_fingerprints_and_aliases[0])
		clicked2.set("Male")
		clicked_front.set("World map")
		clicked_back.set("World map")
		
		thelogged_in_user = ctk.StringVar(value=logged_in_user)
		thelogged_in_user2 = ctk.StringVar(value=logged_in_user)
		empty_var = ctk.StringVar(value="<empty>")
		empty_var2 = ctk.StringVar(value="<empty>")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Create a new Digital ID", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.48, rely=0.06, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		infoLabel = ctk.CTkLabel(my_Frame, text="A Digital ID is based on an existing Private key on your local keychain.", text_color="white", fg_color="black", font=my_font)
		infoLabel.place(relx=0.48, rely=0.12, anchor="center")
		
		#---------------------------------------------------------------
		headerLabel = ctk.CTkLabel(my_Frame, text="ID header:", text_color="white", fg_color="black", font=my_font)
		headerLabel.place(relx=0.34, rely=0.2, anchor="e")
		
		headerLabel_var = ctk.StringVar(value=std_header)
		headerLabel_var.trace('w', limitSizeheaderLabel)
			
		headerEntry = ctk.CTkEntry(my_Frame, placeholder_text=std_header, textvariable=headerLabel_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		headerEntry.place(relx=0.72, rely=0.2, anchor="e")
		
		#---------------------------------------------------------------
		nameLabel = ctk.CTkLabel(my_Frame, text="First name:", text_color="white", fg_color="black", font=my_font)
		nameLabel.place(relx=0.34, rely=0.26, anchor="e")
		
		nameLabel_var = ctk.StringVar(value=logged_in_user)
		nameLabel_var.trace('w', limitSizenameLabel)
			
		nameEntry = ctk.CTkEntry(my_Frame, placeholder_text=logged_in_user, textvariable=nameLabel_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		nameEntry.place(relx=0.72, rely=0.26, anchor="e")
		#---------------------------------------------------------------
		lastnameLabel = ctk.CTkLabel(my_Frame, text="Last name:", text_color="white", fg_color="black", font=my_font)
		lastnameLabel.place(relx=0.34, rely=0.32, anchor="e")
		
		lastnameLabel_var = ctk.StringVar(value=logged_in_user)
		lastnameLabel_var.trace('w', limitSizelastnameLabel)
		
		lastnameEntry = ctk.CTkEntry(my_Frame, placeholder_text=logged_in_user, textvariable=lastnameLabel_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		lastnameEntry.place(relx=0.72, rely=0.32, anchor="e")
		#---------------------------------------------------------------
		lastnameEntry2 = ctk.CTkLabel(my_Frame, text="Last name (2):", text_color="white", fg_color="black", font=my_font)
		lastnameEntry2.place(relx=0.34, rely=0.38, anchor="e")
		
		lastname2Label_var = ctk.StringVar(value="")
		lastname2Label_var.trace('w', limitSizelastnameLabel2)
		
		lastnameEntry2 = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=lastname2Label_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		lastnameEntry2.place(relx=0.72, rely=0.38, anchor="e")
		#---------------------------------------------------------------
		
		check_var = ctk.StringVar(value="off")
		
		checkbox = ctk.CTkCheckBox(my_Frame, text="Use ID photo from the Secure archive", font=my_font, variable=check_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox.place(relx=0.15, rely=0.46, anchor="w")
		
		check_var2 = ctk.StringVar(value="off")
		
		checkbox2 = ctk.CTkCheckBox(my_Frame, text="Set text color to white (needs dark background)", font=my_font, variable=check_var2, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox2.place(relx=0.15, rely=0.52, anchor="w")
		
		frontLabel = ctk.CTkLabel(my_Frame, text="Select background image front:", text_color="white", fg_color="black", font=my_font)
		frontLabel.place(relx=0.15, rely=0.62, anchor="w")
		
		drop1 = OptionMenu(my_Frame, clicked_front, *List_images)
		drop1.place(relx=0.45, rely=0.62, anchor="w")
		
		backLabel = ctk.CTkLabel(my_Frame, text="Select background image back:", text_color="white", fg_color="black", font=my_font)
		backLabel.place(relx=0.15, rely=0.7, anchor="w")
		
		drop2 = OptionMenu(my_Frame, clicked_back, *List_images)
		drop2.place(relx=0.45, rely=0.7, anchor="w")
		
		check_var4 = ctk.StringVar(value="off")
		
		checkbox4 = ctk.CTkCheckBox(my_Frame, text="Use custom text for backside:", font=my_font, variable=check_var4, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox4.place(relx=0.6, rely=0.46, anchor="w")
		
		line1Label_var = ctk.StringVar(value='')
		line1Label_var.trace('w', limitSizeline1Label)
		line1Entry = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=line1Label_var, width=340, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		line1Entry.place(relx=0.6, rely=0.52, anchor="w")
		
		line2Label_var = ctk.StringVar(value='')
		line2Label_var.trace('w', limitSizeline2Label)	
		line2Entry = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=line2Label_var, width=340, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		line2Entry.place(relx=0.6, rely=0.57, anchor="w")
		
		line3Label_var = ctk.StringVar(value='')
		line3Label_var.trace('w', limitSizeline3Label)	
		line3Entry = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=line3Label_var, width=340, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		line3Entry.place(relx=0.6, rely=0.62, anchor="w")
		
		line4Label_var = ctk.StringVar(value='')
		line4Label_var.trace('w', limitSizeline4Label)
		line4Entry = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=line4Label_var, width=340, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		line4Entry.place(relx=0.6, rely=0.67, anchor="w")
		
		line5Label_var = ctk.StringVar(value='')
		line5Label_var.trace('w', limitSizeline5Label)	
		line5Entry = ctk.CTkEntry(my_Frame, placeholder_text="", textvariable=line5Label_var, width=340, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		line5Entry.place(relx=0.6, rely=0.72, anchor="w")
		
		Label1 = ctk.CTkLabel(my_Frame, text="Birth date:", font=my_font, text_color="white", fg_color="black")
		Label1.place(relx=0.34, rely=0.8, anchor="e")
		
		cal = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black", year=2025)
		cal.place(relx=0.55, rely=0.8, anchor="e")
		
		Label1 = ctk.CTkLabel(my_Frame, text="Sex:", font=my_font, text_color="white", fg_color="black")
		Label1.place(relx=0.63, rely=0.8, anchor="e")
		
		drop2 = OptionMenu(my_Frame, clicked2, *List_Sex)
		drop2.place(relx=0.72, rely=0.8, anchor="e")
				
		Label1 = ctk.CTkLabel(my_Frame, text="Select encryption key:", font=my_font, text_color="white", fg_color="black")
		Label1.place(relx=0.4, rely=0.88, anchor="e")
		
		drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
		drop.config(width=45)
		drop.place(relx=0.78, rely=0.88, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		Button = ctk.CTkButton(my_Frame, text="Create ID", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=do_newID)
		Button.place(relx=0.66, rely=0.96, anchor="w")
		
	def create_getSettimetextbox(self):
		global PersonalGPGKey
		global filepathdestinationfolder
		global path_to_USB_secure
		global timeSecUSBLastModified
		global System_button_color
		global users_avatar_icon
		global users_avatar_name
		logged_in_user = '< Not logged in >'
		users_theme = 'Standard'
		users_colors = 'Varied'
		users_avatar_name = 'Anon'
		users_avatar_icon = 'Male'
		
		def setdateandtime():
			thedate = cal.get_date()
			thetime = time_picker.time()
			
			thedatestr = str('sudo date -s \'' + str(thedate) + ' ' + str(thetime[0]) + ':' + str(thetime[1]) + ':00\'')			
			os.system(thedatestr)
			thestr = 'sudo hwclock -w'	
			os.system(thestr)
			os.system(thestr)
			self.create_Hometextbox()

		def delete_account():
			global path_to_USB_secure
			global timeSecUSBLastModified
			answer = messagebox.askquestion('WARNING!', 'WARNING! You are about to delete the account! Are you SURE you want to permanently delete it?')
			
			# Delete files and go to start menu
			if answer == 'yes':
				# Delete the personal GPG-key both on local keychain and the file
				path_personalGPGkey = filepathdestinationfolder + '/privateKey' + PersonalGPGKey + '.gpg' 
				cmd = 'shred -zu -n7 ' + path_personalGPGkey
				os.system(cmd)
				
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				# Delete the private key
				try:
					key = gpg.delete_keys(PersonalGPGKey, True, expect_passphrase=False) 
				except ValueError as ve:
					messagebox.showinfo('Information', 'Something went wrong.')
				# Delete the public key
				try:
					key = gpg.delete_keys(PersonalGPGKey) 
				except ValueError as ve:
					messagebox.showinfo('Information', 'Something went wrong.')
					
				# Delete reference in external alias file (if any)
				path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
				updated_path_to_aliases = str(filepathdestinationfolder) + "/Documents/updatedexternalAliases.csv"
				new_alias_data = []
				with open(path_to_externalAliases, 'r') as source, open(updated_path_to_aliases, 'w') as result:
					csvreader = csv.reader(source)
					csvwriter = csv.writer(result)
					for row in csv.reader(source):
						if row[0] != PersonalGPGKey:
							new_alias_data = [
											row[0],
											row[1],
											row[2]]
							csvwriter.writerow(new_alias_data)
				shutil.copy(updated_path_to_aliases, path_to_externalAliases)
				os.remove(updated_path_to_aliases)	
				
				# Delete the secure (unencrypted) folder and the encrypted data file
				path_encrypted_archive = filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg'
				
				full_path = filepathdestinationfolder + "/secure"
				cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
				os.system(cmd)
				cmd = 'rm -r ' +  full_path
				os.system(cmd)
				cmd = 'shred -zu -n7 ' + path_encrypted_archive
				os.system(cmd)
				
				messagebox.showinfo("Information", "The account has been deleted and the personal GPG-key removed from the local keychain.")

				path_to_USB_secure = 'Secure USB folder is not available'
				timeSecUSBLastModified = '<Unknown>'
				self.set_colors('Varied')
				self.create_meny()
			
		def update_account():
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			Updated_Username = nameEntry.get()
			clicked_Layout = clicked_layout.get()
			clicked_Theme = clicked.get()
			clicked_Color = clicked2.get()
			clicked_Avatar = clicked3.get()
			new_Avatar_Entry = avatarEntry.get()
			
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				new_settings = [
								Updated_Username,
								clicked_Theme,
								clicked_Color]

				csvwriter.writerow(new_settings)
			self.set_colors(clicked_Color)
			
			completeName = str(filepathdestinationfolder) + "/secure/layout.csv"
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				new_layout = [clicked_Layout]

				csvwriter.writerow(new_layout)
			
			completeName = str(filepathdestinationfolder) + "/secure/layout_settings.csv"		
			if not os.path.isfile(completeName) and (clicked_Layout == 'Easy' or clicked_Layout == 'Quick buttons'):
				# Create a default Easy setting if there is none
				
				type1 = 'none'
				data1 = 'none'
				type2 = 'none'
				data2 = 'none'
				type3 = 'none'
				data3 = 'none'
				type4 = 'none'
				data4 = 'none'
				
				# Check for ID's
				all_IDs = self.get_IDs()
				
				# Check for GPG private keys if not used for ID
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				
				private_keys = gpg.list_keys(True)
						
				List_fingerprints = []
				uniquePrivateKeys = []
				all_wallets = []
				
				# Dont use the private key that is only intended for Offline device encryption/decryption
				for nkey in private_keys:
					if nkey['fingerprint'] != PersonalGPGKey:
						List_fingerprints.append(nkey['fingerprint'])
				
				if List_fingerprints:
					for i2 in List_fingerprints:
						if i2 not in all_IDs:
							uniquePrivateKeys.append(i2)
				
				# Check for Bitcoin wallets
				all_wallets = self.get_Bitcoin_wallets()
				
				if all_IDs:
					type1 = 'ID'
					data1 = all_IDs[0]
				elif uniquePrivateKeys:
					type1 = 'Key'
					data1 = uniquePrivateKeys[0]
				if all_wallets:
					if len(all_wallets) > 2:
						type2 = 'Bitcoin'
						data2 = all_wallets[0]
						type3 = 'Bitcoin'
						data3 = all_wallets[1]
						type4 = 'Bitcoin'
						data4 = all_wallets[2]
					elif len(all_wallets) > 1:
						type2 = 'Bitcoin'
						data2 = all_wallets[0]
						type3 = 'Bitcoin'
						data3 = all_wallets[1]
					else:
						type2 = 'Bitcoin'
						data2 = all_wallets[0]
						
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					new_settings = [
									type1,
									data1,
									type2,
									data2,
									type3,
									data3,
									type4,
									data4]

					csvwriter.writerow(new_settings)
			
			if checkbox2.get() == "on":
				my_keyboard = 'none'
				my_mouse = 'none'
				my_dock = 'none'
				
				new_data_list = []
				data_found = False
				
				self.set_hw_settings("keyboard_mouse")
				
				# Get the keyboard data and serial number
				cmd = 'sudo lsusb | grep -i "keyboard"'
				k_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_data = k_data.stdout.strip().decode("utf-8")	
				real_k_data = clean_k_data.partition(":")
				clean_k_data_ = real_k_data[2].strip('"')
				new_data_list.append(clean_k_data_)			# Add the Keyboard data
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'keyboard' | awk '{print $6}') | grep 'iSerial'"
				k_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_serial = k_serial.stdout.strip().decode("utf-8")
				new_data_list.append(clean_k_serial)		# Add the Keyboard serial number
					
				# Get the mouse data and serial number
				cmd = 'sudo lsusb | grep -i "mouse"'
				m_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_data = m_data.stdout.strip().decode("utf-8")
				real_m_data = clean_m_data.partition(":")
				clean_m_data_ = real_m_data[2].strip('"')
				new_data_list.append(clean_m_data_)			# Add the mouse data
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'mouse' | awk '{print $6}') | grep 'iSerial'"
				m_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_serial = m_serial.stdout.strip().decode("utf-8")
				new_data_list.append(clean_m_serial)		# Add the mouse serial number
				
				self.set_sec_hw_settings(new_data_list)
			else:
				self.set_hw_settings("none")
				
			if checkbox.get() == "on":					
				# Make local copy for external alias (in case of recovery on new device)
				new_external_alias = [PersonalGPGKey, new_Avatar_Entry, clicked_Avatar]
				path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
				
				# Check if alias file exists. If not create it
				if not os.path.isfile(path_to_externalAliases):
					if clicked_Avatar == 'Upload my own':
						result = tk.messagebox.askokcancel("Information", "Connect the USB-device with the avatar picture and click \"OK\".")
						if not result:
							self.create_getSettimetextbox()
							return
						time.sleep(2)
						result = tk.messagebox.askokcancel("Information", "Select the picture for your avatar (\".jpg\" or \".png\" format)")
						if not result:
							self.create_getSettimetextbox()
							return
						time.sleep(2)
						pathtopicture = filedialog.askopenfilename(initialdir='/media/user1')
						newpicturename = PersonalGPGKey + '.png'
						pathtopicturelocation = filepathdestinationfolder + "/Documents/" + PersonalGPGKey + '.png'
						pathtopicturearchivelocation = filepathdestinationfolder + "/secure/" + PersonalGPGKey + '.png'
						shutil.copy(pathtopicture, pathtopicturelocation)
						shutil.copy(pathtopicture, pathtopicturearchivelocation)
						
						new_external_alias = [PersonalGPGKey, new_Avatar_Entry, newpicturename]
					else:
						new_external_alias = [PersonalGPGKey, new_Avatar_Entry, clicked_Avatar]
					
					f = open(path_to_externalAliases, 'w')
					writer = csv.writer(f)
					writer.writerow(new_external_alias)
					f.close()
					
					with open(path_to_externalAliases_localcopy, 'w') as f:
						writer = csv.writer(f)
						writer.writerow(new_external_alias)
				else:
					updated_path_to_aliases = str(filepathdestinationfolder) + "/Documents/updatedexternalAliases.csv"
					
					if clicked_Avatar == 'Upload my own':
						result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
						if not result:
							self.create_getSettimetextbox()
							return
						time.sleep(2)
						result = tk.messagebox.askokcancel("Information", "Select the picture for your avatar (\".png\" or \".jpg\" format)")
						if not result:
							self.create_getSettimetextbox()
							return
						time.sleep(2)
						pathtopicture = filedialog.askopenfilename(initialdir='/media/user1')
						newpicturename = PersonalGPGKey + '.png'
						pathtopicturelocation = filepathdestinationfolder + "/Documents/" + PersonalGPGKey + '.png'
						pathtopicturearchivelocation = filepathdestinationfolder + "/secure/" + PersonalGPGKey + '.png'
						shutil.copy(pathtopicture, pathtopicturelocation)
						shutil.copy(pathtopicture, pathtopicturearchivelocation)
						new_external_alias = [PersonalGPGKey, new_Avatar_Entry, newpicturename]
						foundentry = False
						with open(path_to_externalAliases, 'r') as source, open(updated_path_to_aliases, 'w') as result:
							csvreader = csv.reader(source)
							csvwriter = csv.writer(result)
							for row in csv.reader(source):
								if row[0] == PersonalGPGKey:
									csvwriter.writerow(new_external_alias)
									foundentry = True
								else:
									new_alias_data = [
													row[0],
													row[1],
													row[2]]
									csvwriter.writerow(new_alias_data)
						shutil.copy(updated_path_to_aliases, path_to_externalAliases)
						os.remove(updated_path_to_aliases)
						if foundentry == False:
							with open(path_to_externalAliases, 'a') as result:
								csvwriter = csv.writer(result)
								csvwriter.writerow(new_external_alias)
						with open(path_to_externalAliases_localcopy, 'w') as f:
							writer = csv.writer(f)
							writer.writerow(new_external_alias)
					else:
						new_external_alias = [PersonalGPGKey, new_Avatar_Entry, clicked_Avatar]
						foundentry = False
						with open(path_to_externalAliases, 'r') as source, open(updated_path_to_aliases, 'w') as result:
							csvreader = csv.reader(source)
							csvwriter = csv.writer(result)
							for row in csv.reader(source):
								if row[0] == PersonalGPGKey:
									csvwriter.writerow(new_external_alias)
									foundentry = True
								else:
									new_alias_data = [
													row[0],
													row[1],
													row[2]]
									csvwriter.writerow(new_alias_data)
						shutil.copy(updated_path_to_aliases, path_to_externalAliases)
						os.remove(updated_path_to_aliases)
						if foundentry == False:
							with open(path_to_externalAliases, 'a') as result:
								csvwriter = csv.writer(result)
								csvwriter.writerow(new_external_alias)
						with open(path_to_externalAliases_localcopy, 'w') as f:
							writer = csv.writer(f)
							writer.writerow(new_external_alias)
			else:
				updated_path_to_aliases = str(filepathdestinationfolder) + "/Documents/updatedexternalAliases.csv"
				new_alias_data = []
				with open(path_to_externalAliases, 'r') as source, open(updated_path_to_aliases, 'w') as result:
					csvreader = csv.reader(source)
					csvwriter = csv.writer(result)
					for row in csv.reader(source):
						if row[0] != PersonalGPGKey:
							new_alias_data = [
											row[0],
											row[1],
											row[2]]
							csvwriter.writerow(new_alias_data)
				shutil.copy(updated_path_to_aliases, path_to_externalAliases)
				os.remove(updated_path_to_aliases)
			self.create_meny()
		
		def get_avatar_data_if_any():
			global users_avatar_icon
			global users_avatar_name
			external_alias_file = filepathdestinationfolder + "/Documents/externalAliases.csv"	

			# Check if alias file exists.
			if not os.path.isfile(external_alias_file):
				return False
			else:
				try:
					f = open(external_alias_file, 'r')
					for row in csv.reader(f):
						if row[0] == PersonalGPGKey:
							users_avatar_name = row[1]
							users_avatar_icon = row[2]
							return True
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
			return True
		
		def testCamera():
			subprocess.run(['/home/user1/myenv/bin/python /home/user1/testCamera.py'], shell=True)
		
		def edit_keyboard_layout():
			proc = subprocess.run(['lxterminal', '-e', 'sudo raspi-config'])
			subprocess.run(["wmctrl", "-a", "sudo raspi-config"])
			return
				
		def checkForCamera():
			# model version 1, 2 and 3
			cmd = 'rpicam-hello --list-cameras | grep -c ov5647'
			result = subprocess.run(cmd, shell=True, encoding='utf-8', stdout=subprocess.PIPE) 
			numberis = int(result.stdout)

			if numberis > 0:
				LabelCam = ctk.CTkLabel(my_Frame, text="Connected camera:", text_color="white", fg_color="black", font=my_font)
				LabelCam.place(relx=0.07, rely=0.81, anchor="w")
				LabelCam2 = ctk.CTkLabel(my_Frame, text="Model:              ov5647", text_color="white", fg_color="black", font=my_font)
				LabelCam2.place(relx=0.07, rely=0.85, anchor="w")
				LabelCam3 = ctk.CTkLabel(my_Frame, text="Resolution:         5 MP", text_color="white", fg_color="black", font=my_font)
				LabelCam3.place(relx=0.07, rely=0.89, anchor="w")
				testButton = ctk.CTkButton(my_Frame, text="Test camera (10 sec)", text_color="white", border_width=2, border_color="white", fg_color="dark green", width=120, height=32, font=my_font, command=testCamera)
				testButton.place(relx=0.07, rely=0.94, anchor="w")
			else:
				cmd = 'rpicam-hello --list-cameras | grep -c imx219'
				result = subprocess.run(cmd, shell=True, encoding='utf-8', stdout=subprocess.PIPE) 
				numberis = int(result.stdout)

				if numberis > 0:
					LabelCam = ctk.CTkLabel(my_Frame, text="Connected camera:", text_color="white", fg_color="black", font=my_font)
					LabelCam.place(relx=0.07, rely=0.81, anchor="w")
					LabelCam2 = ctk.CTkLabel(my_Frame, text="Model:              imx219", text_color="white", fg_color="black", font=my_font)
					LabelCam2.place(relx=0.07, rely=0.85, anchor="w")
					LabelCam3 = ctk.CTkLabel(my_Frame, text="Resolution:         8 MP", text_color="white", fg_color="black", font=my_font)
					LabelCam3.place(relx=0.07, rely=0.89, anchor="w")
					testButton = ctk.CTkButton(my_Frame, text="Test camera (10 sec)", text_color="white", border_width=2, border_color="white", fg_color="dark green", width=120, height=32, font=my_font, command=testCamera)
					testButton.place(relx=0.07, rely=0.94, anchor="w")
				else:
					cmd = 'rpicam-hello --list-cameras | grep -c imx708'
					result = subprocess.run(cmd, shell=True, encoding='utf-8', stdout=subprocess.PIPE) 
					numberis = int(result.stdout)

					if numberis > 0:
						LabelCam = ctk.CTkLabel(my_Frame, text="Connected camera:", text_color="white", fg_color="black", font=my_font)
						LabelCam.place(relx=0.07, rely=0.81, anchor="w")
						LabelCam2 = ctk.CTkLabel(my_Frame, text="Model:               imx708", text_color="white", fg_color="black", font=my_font)
						LabelCam2.place(relx=0.07, rely=0.85, anchor="w")
						LabelCam3 = ctk.CTkLabel(my_Frame, text="Resolution:         12 MP", text_color="white", fg_color="black", font=my_font)
						LabelCam3.place(relx=0.07, rely=0.89, anchor="w")
						testButton = ctk.CTkButton(my_Frame, text="Test camera (10 sec)", text_color="white", border_width=2, border_color="white", fg_color="dark green", width=120, height=32, font=my_font, command=testCamera)
						testButton.place(relx=0.07, rely=0.94, anchor="w")
					else:
						LabelCam = ctk.CTkLabel(my_Frame, text="No camera found.", text_color="white", fg_color="black", font=my_font)
						LabelCam.place(relx=0.07, rely=0.85, anchor="w")
					
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		users_layout = 'Easy'
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							logged_in_user = lines[0]
							users_theme = lines[1]
							users_colors = lines[2]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
			completeName = str(filepathdestinationfolder) + "/secure/layout.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							users_layout = lines[0]
			except FileNotFoundError:
				print("<no layout file found>")
				
		List_Layout = ['Standard', 'Quick buttons', 'Easy']			
		List_Themes = ['Standard', 'Dark', 'Light', 'Summer', 'Winter']
		List_Colors = ['Varied', 'Navy blue', 'Green', 'Gray', 'Purple', 'Red', 'Pink']
		List_Avatars = ['Anon', 'Male', 'Woman', 'Boy', 'Girl', 'Yin Yang', 'Skull', 'Upload my own']
		
		clicked_layout = StringVar()
		clicked = StringVar()
		clicked2 = StringVar()
		clicked3 = StringVar()
		users_avatar = "Male"
		
		clicked_layout.set(users_layout)
		clicked.set(users_theme)
		clicked2.set(users_colors)
		clicked3.set(users_avatar)
		check_var = ctk.StringVar(value="on")
		
		# Check if there is a secure hardware settings file. If so, preload the checkbox for it
		existing_hw_setting_list = self.get_hw_setting()
		
		if existing_hw_setting_list[0] == "keyboard_mouse":
			check_var2 = ctk.StringVar(value="on")
		else:
			check_var2 = ctk.StringVar(value="off")
		
		def limitSizeAvatarname(*args):
			value = users_avatar_name_var.get()
			if len(value) > 17: users_avatar_name_var.set(value[:17])
			
		def limitSizeUsername(*args):
			value = users_user_name_var.get()
			if len(value) > 28: users_user_name_var.set(value[:28])
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Update account settings:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.31, rely=0.1, anchor="e")
		
		setLabel = ctk.CTkLabel(my_Frame, text="Set time and date:", text_color="white", fg_color="black", font=my_font)
		setLabel.place(relx=0.72, rely=0.17, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		editKeyboardButton = ctk.CTkButton(my_Frame, text="Change keyboard etc", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=edit_keyboard_layout) 
		editKeyboardButton.place(relx=0.87, rely=0.1, anchor="e")
		
		Label1 = ctk.CTkLabel(my_Frame, text="Layout: ", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.06, rely=0.17, anchor="w")
		
		nameLabel = ctk.CTkLabel(my_Frame, text="User name:", text_color="white", fg_color="black", font=my_font)
		nameLabel.place(relx=0.15, rely=0.24, anchor="e")
		
		Layout_drop = OptionMenu(my_Frame, clicked_layout, *List_Layout)
		Layout_drop.place(relx=0.33, rely=0.17, anchor="e")
		
		layoutButton = ctk.CTkButton(my_Frame, text="Edit", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=self.edit_easy_layout) 
		layoutButton.place(relx=0.47, rely=0.17, anchor="e")
		
		users_user_name_var = ctk.StringVar(value=logged_in_user)
		users_user_name_var.trace('w', limitSizeUsername)
		
		thelogged_in_user = ctk.StringVar(value=logged_in_user)
		
		nameEntry = ctk.CTkEntry(my_Frame, placeholder_text=logged_in_user, textvariable=users_user_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		nameEntry.place(relx=0.2, rely=0.24, anchor="w")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select theme:", font=my_font, text_color="white", fg_color="black")
		Label2.place(relx=0.18, rely=0.31, anchor="e")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Select color:", font=my_font, text_color="white", fg_color="black")
		Label3.place(relx=0.17, rely=0.38, anchor="e")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Select avatar:", font=my_font, text_color="white", fg_color="black")
		Label4.place(relx=0.46, rely=0.45, anchor="e")
		
		avatarLabel = ctk.CTkLabel(my_Frame, text="Avatar name (used for login):", text_color="white", fg_color="black", font=my_font)
		avatarLabel.place(relx=0.3, rely=0.6, anchor="e")
		
		# Get the current avatar name (if any)
		avatars = get_avatar_data_if_any()
			
		users_avatar_name_var = ctk.StringVar(value=users_avatar_name)
		users_avatar_name_var.trace('w', limitSizeAvatarname)
						
		if path_to_USB_secure == 'Secure USB folder is available':	
			drop = OptionMenu(my_Frame, clicked, *List_Themes)
			drop.place(relx=0.46, rely=0.31, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *List_Colors)
			drop2.place(relx=0.46, rely=0.38, anchor="e")
			checkbox = ctk.CTkCheckBox(my_Frame, text="Add avatar to login screen.", font=my_font, variable=check_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
			checkbox.place(relx=0.32, rely=0.45, anchor="e")
			
			clicked3 = ctk.StringVar(value=users_avatar_icon)
			drop3 = OptionMenu(my_Frame, clicked3, *List_Avatars)
			drop3.place(relx=0.46, rely=0.52, anchor="e")
			avatarEntry = ctk.CTkEntry(my_Frame, placeholder_text=users_avatar_name, textvariable=users_avatar_name_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			avatarEntry.place(relx=0.34, rely=0.6, anchor="w")
			updateButton = ctk.CTkButton(my_Frame, text="Update settings", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=update_account)
			updateButton.place(relx=0.33, rely=0.76, anchor="w")
			deleteButton = ctk.CTkButton(my_Frame, text="Delete account!", text_color="black", fg_color="red", border_width=3, border_color="white", font=my_font, command=delete_account)
			deleteButton.place(relx=0.87, rely=0.91, anchor="e")
		
		checkbox2 = ctk.CTkCheckBox(my_Frame, text="Secure hardware at startup.", font=my_font, variable=check_var2, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox2.place(relx=0.32, rely=0.67, anchor="e")
			
		sec_hwButton = ctk.CTkButton(my_Frame, text="Edit", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=self.edit_sec_hw) 
		sec_hwButton.place(relx=0.47, rely=0.67, anchor="e")
		
		time_picker = AnalogPicker(my_Frame, type=constants.HOURS24)
		time_picker.setHours(datetime.now().hour)
		time_picker.setMinutes(datetime.now().minute)
		time_picker.place(relx=0.87, rely=0.21, anchor="ne")
		
		theme = AnalogThemes(time_picker)
		theme.setNavyBlue()
		time_picker.configAnalog(textcolor="#ffffff", bg="#0a0832", bdColor="#000000", headbdcolor="#000000")
		
		year = time.strftime("%Y")
		
		cal = DateEntry(my_Frame, width=20, font="Arial 16", year=int(year))
		cal.place(relx=0.87, rely=0.76, anchor="e")
			
		setButton = ctk.CTkButton(my_Frame, text="Set time/date", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=setdateandtime) 
		setButton.place(relx=0.87, rely=0.84, anchor="e")
			
		softwareButton = ctk.CTkButton(my_Frame, text=" (Update software)", text_color="white", fg_color="black", border_width=2, border_color="black", font=my_font, command=self.updateSoftware) 
		softwareButton.place(relx=0.5, rely=0.86, anchor="center")
		
		HomeButton = ctk.CTkButton(my_Frame, text="Home", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.create_meny)
		HomeButton.place(relx=0.5, rely=0.92, anchor="center")
		
		# Check for cameras
		camButton = ctk.CTkButton(my_Frame, text="Check for camera", text_color="white", fg_color="dark grey", border_width=2, border_color="white", font=my_font, command=checkForCamera) 
		camButton.place(relx=0.07, rely=0.76, anchor="w")
	
	def edit_easy_layout(self):
		global PersonalGPGKey
		global filepathdestinationfolder
		global System_button_color
		
		List_Buttons = []	
		choice_string = ''
		type1 = 'none'
		data1 = 'none'
		type2 = 'none'
		data2 = 'none'
		type3 = 'none'
		data3 = 'none'
		type4 = 'none'
		data4 = 'none'
		
		default_selection = 'none'
		clicked1 = StringVar()
		clicked2 = StringVar()
		clicked3 = StringVar()
		clicked4 = StringVar()
		
		clicked1.set(default_selection)
		clicked2.set(default_selection)
		clicked3.set(default_selection)
		clicked4.set(default_selection)
		
		def fill_List_Buttons():
			# Check for ID and add to Button selection list
			all_IDs = self.get_IDs()
			
			List_Buttons.append('none')
			if all_IDs:
				for n in all_IDs:
					name_ID = self.lookup_Alias_absolut(n) 
					choice_string = 'Sign anything with ID :ID:' + name_ID + ':' + n
					List_Buttons.append(choice_string)
					choice_string = 'Sign FILE with ID :File_ID:' + name_ID + ':' + n
					List_Buttons.append(choice_string)
					choice_string = 'Sign QR with ID :QR_ID:' + name_ID + ':' + n
					List_Buttons.append(choice_string)
		
			# Check for GPG private keys and add if not used for ID
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			private_keys = gpg.list_keys(True)
					
			List_fingerprints = []
			uniquePrivateKeys = []
			all_wallets = []
			
			# Dont display the private key that is only intended for Offline device encryption/decryption
			for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					List_fingerprints.append(nkey['fingerprint'])
			
			if List_fingerprints:
				for i2 in List_fingerprints:
					if i2 not in all_IDs:
						uniquePrivateKeys.append(i2)
			
			if uniquePrivateKeys:
				for n2 in uniquePrivateKeys:
					name_Key = self.lookup_Alias_absolut(n2)
					choice_string = 'Sign anything with Key :Key:' + name_Key + ':' + n2
					List_Buttons.append(choice_string)
					choice_string = 'Sign FILE with Key :File:' + name_Key + ':' + n2
					List_Buttons.append(choice_string)
					choice_string = 'Sign QR with Key :QR:' + name_Key + ':' + n2
					List_Buttons.append(choice_string)
					
			# Check for Bitcoin wallets and add 
			all_wallets = self.get_Bitcoin_wallets()
			
			if all_wallets:
				for n3 in all_wallets:
					choice_string = 'Sign Transaction with :Bitcoin:' + n3 + ':' + n3
					List_Buttons.append(choice_string)
					
		def update_account():
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			Button_1_selection = clicked1.get()
			Button_2_selection = clicked2.get()
			Button_3_selection = clicked3.get()
			Button_4_selection = clicked4.get()
			
			if Button_1_selection != 'none':
				command_list = Button_1_selection.split(":")
				type1 = str(command_list[-3])
				data1 = str(command_list[-1])
			else:
				type1 = 'none'
				data1 = 'none'
			
			if Button_2_selection != 'none':
				command_list = Button_2_selection.split(":")
				type2 = str(command_list[-3])
				data2 = str(command_list[-1])
			else:
				type2 = 'none'
				data2 = 'none'
			
			if Button_3_selection != 'none':
				command_list = Button_3_selection.split(":")
				type3 = str(command_list[-3])
				data3 = str(command_list[-1])
			else:
				type3 = 'none'
				data3 = 'none'
			
			if Button_4_selection != 'none':
				command_list = Button_4_selection.split(":")
				type4 = str(command_list[-3])
				data4 = str(command_list[-1])
			else:
				type4 = 'none'
				data4 = 'none'
			
			completeName = str(filepathdestinationfolder) + "/secure/layout_settings.csv"
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				new_settings = [
								type1,
								data1,
								type2,
								data2,
								type3,
								data3,
								type4,
								data4]

				csvwriter.writerow(new_settings)
			
			self.create_meny()
		
		def get_previous():
			#global type1, data1, type2, data2, type3, data3, type4, data4
			avail = False
			completeName = str(filepathdestinationfolder) + "/secure/layout_settings.csv"
			if os.path.isfile(completeName):
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:
								avail = True
								type1 = lines[0]
								data1 = lines[1]
								type2 = lines[2]
								data2 = lines[3]
								type3 = lines[4]
								data3 = lines[5]
								type4 = lines[6]
								data4 = lines[7]
				except FileNotFoundError:
					messagebox.showinfo("Information", "No layout settings file found.")
			if avail:
				if type1 == 'ID':
					alias_ID = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign anything with ID :ID:' + alias_ID + ':' + data1)
				if type1 == 'File_ID':
					alias_ID = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign FILE with ID :File_ID:' + alias_ID + ':' + data1)
				if type1 == 'QR_ID':
					alias_ID = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign QR with ID :QR_ID:' + alias_ID + ':' + data1)
				if type1 == 'Key':
					alias_Key = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign anything with Key :Key:' + alias_Key + ':' + data1)
				if type1 == 'File':
					alias_Key = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign FILE with Key :File_ID:' + alias_Key + ':' + data1)
				if type1 == 'QR':
					alias_Key = self.lookup_Alias_absolut(data1) 
					clicked1.set('Sign QR with Key :QR:' + alias_Key + ':' + data1)
				if type1 == 'Bitcoin':
					clicked1.set('Sign Transaction with :Bitcoin:' + data1 + ':' + data1)
				if type1 == 'none':
					clicked1.set('none')
				
				if type2 == 'ID':
					alias_ID = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign with ID :ID:' + alias_ID + ':' + data2)
				if type2 == 'File_ID':
					alias_ID = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign FILE with ID :File_ID:' + alias_ID + ':' + data2)
				if type2 == 'QR_ID':
					alias_ID = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign QR with ID :QR_ID:' + alias_ID + ':' + data2)
				if type2 == 'Key':
					alias_Key = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign with Key :Key:' + alias_Key + ':' + data2)
				if type2 == 'File':
					alias_Key = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign FILE with Key :File_ID:' + alias_Key + ':' + data2)
				if type2 == 'QR':
					alias_Key = self.lookup_Alias_absolut(data2) 
					clicked2.set('Sign QR with Key :QR:' + alias_Key + ':' + data2)
				if type2 == 'Bitcoin':
					clicked2.set('Sign Transaction with :Bitcoin:' + data2 + ':' + data2)
				if type2 == 'none':
					clicked2.set('none')
					
				if type3 == 'ID':
					alias_ID = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign with ID :ID:' + alias_ID + ':' + data3)
				if type3 == 'File_ID':
					alias_ID = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign FILE with ID :File_ID:' + alias_ID + ':' + data3)
				if type3 == 'QR_ID':
					alias_ID = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign QR with ID :QR_ID:' + alias_ID + ':' + data3)
				if type3 == 'Key':
					alias_Key = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign with Key :Key:' + alias_Key + ':' + data3)
				if type3 == 'File':
					alias_Key = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign FILE with Key :File_ID:' + alias_Key + ':' + data3)
				if type3 == 'QR':
					alias_Key = self.lookup_Alias_absolut(data3) 
					clicked3.set('Sign QR with Key :QR:' + alias_Key + ':' + data3)
				if type3 == 'Bitcoin':
					clicked3.set('Sign Transaction with :Bitcoin:' + data3 + ':' + data3)
				if type3 == 'none':
					clicked3.set('none')
				
				if type4 == 'ID':
					alias_ID = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign with ID :ID:' + alias_ID + ':' + data4)
				if type4 == 'File_ID':
					alias_ID = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign FILE with ID :File_ID:' + alias_ID + ':' + data4)
				if type4 == 'QR_ID':
					alias_ID = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign QR with ID :QR_ID:' + alias_ID + ':' + data4)
				if type4 == 'Key':
					alias_Key = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign with Key :Key:' + alias_Key + ':' + data4)
				if type4 == 'File':
					alias_Key = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign FILE with Key :File_ID:' + alias_Key + ':' + data4)
				if type4 == 'QR':
					alias_Key = self.lookup_Alias_absolut(data4) 
					clicked4.set('Sign QR with Key :QR:' + alias_Key + ':' + data4)
				if type4 == 'Bitcoin':
					clicked4.set('Sign Transaction with :Bitcoin:' + data4 + ':' + data4)
				if type4 == 'none':
					clicked4.set('none')
					
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		fill_List_Buttons()
		
		get_previous()
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Select function for the main buttons when using Easy Layout:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Button 1: ", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.06, rely=0.22, anchor="w")
		
		button1_drop = OptionMenu(my_Frame, clicked1, *List_Buttons)
		button1_drop.place(relx=0.16, rely=0.22, anchor="w")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Button 2: ", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.06, rely=0.32, anchor="w")
		
		button2_drop = OptionMenu(my_Frame, clicked2, *List_Buttons)
		button2_drop.place(relx=0.16, rely=0.32, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Button 3: ", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.06, rely=0.42, anchor="w")
		
		button3_drop = OptionMenu(my_Frame, clicked3, *List_Buttons)
		button3_drop.place(relx=0.16, rely=0.42, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Button 4: ", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.06, rely=0.52, anchor="w")
		
		button4_drop = OptionMenu(my_Frame, clicked4, *List_Buttons)
		button4_drop.place(relx=0.16, rely=0.52, anchor="w")
		
		layoutButton = ctk.CTkButton(my_Frame, text="Save", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=update_account) 
		layoutButton.place(relx=0.4, rely=0.7, anchor="e")
		
		HomeButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.create_meny)
		HomeButton.place(relx=0.6, rely=0.7, anchor="center")
		
	def updateReboot(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global s_width,s_height
		
		my_big_Frame = ctk.CTkFrame(self, 
		width=s_width, 
		height=s_height,
		border_width=0,
		border_color="black"
		)
		my_big_Frame.place(relx=0.5, rely=0.5, anchor="center")
		
		pathtobackg = "/home/user1/images/black.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(s_width, s_height))
		Label_backg = ctk.CTkLabel(my_big_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		Label_backg.focus_set()
		Label_backg.focus_force()
		
		my_big_Frame.focus_set()
		my_big_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
		
		infoLabel = ctk.CTkLabel(my_big_Frame, text="Encrypting the device and rebooting...", text_color="white", font=my_font, fg_color="navy blue")
		infoLabel.place(relx=0.5, rely=0.42, anchor="center")
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if path_to_USB_secure == 'Secure USB folder is available':
			
			full_path = str(filepathdestinationfolder) + "/secure/"
			
			compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
			# Encrypt the tarfile and remove the unencrypted tarfile
			encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
			
			cmd = 'shred -zu -n7 ' + filepathdestinationfolder + "/" + "secure.tar.gz"
			os.system(cmd)

			# Write the encrypted file to disk
			compressedoutfile = open(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', 'w')
			compressedoutfile.write(str(encrypted_data))
			compressedoutfile.close()
			full_path = str(filepathdestinationfolder) + "/secure"
			cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
			os.system(cmd)
			cmd = 'rm -r ' +  full_path
			os.system(cmd)
			os.system('sudo shutdown -r now')
		else:
			os.system('sudo shutdown -r now')
			
	def updateSoftware(self):
		global System_button_color
		global filepathdestinationfolder
		global softwareVersion
		global softwareStatus
		
		def do_updateSoftware():			
			# Make temporary directory for software update
			pathtempfolder = filepathdestinationfolder + '/tempsystem/'
			pathupdatescript = pathtempfolder + 'Updatefiles/Update_script.py'
			exec_updatescript = '/home/user1/myenv/bin/python ' + pathupdatescript
			App_source_File = pathtempfolder + '/GUIApp.py'
			App_dest_File = '/home/user1/GUIApp.py'
			
			# Select tar-file with software update
			result = tk.messagebox.askokcancel("Information", "Insert the USB-device with the updated software and then press \"OK\".")
			if not result:
				self.create_getSettimetextbox()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel("Information", "Select the file with the software update.")
			if not result:
				self.create_getSettimetextbox()
				return
			time.sleep(2)
			pathSoftwarefile = filedialog.askopenfilename(initialdir='/media/user1')
			
			# Open tar-archive and write to temporary directory
			try:
				tar = tarfile.open(pathSoftwarefile) 
				tar.extractall(pathtempfolder, filter='fully_trusted')
				tar.close()
				
				if os.path.isfile(pathupdatescript):
					os.system(exec_updatescript)
			except FileNotFoundError:
				messagebox.showinfo("Information", "No file found.")
			
			# Remove the system update temp directory 
			cmd = 'find ' +  pathtempfolder + ' -type f -exec shred -zu {} \\;'
			os.system(cmd)
			cmd = 'rm -r ' +  pathtempfolder
			os.system(cmd)
			
			answer = messagebox.askquestion('Information!', 'Restart the Offline device for the changes to take effect?')
			
			if answer == 'yes':
				self.updateReboot()
			else:	
				self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()	
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Update the system software", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.2, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		nameLabel = ctk.CTkLabel(my_Frame, text="Current software version: " + softwareVersion + " (" + softwareStatus + ")", text_color="white", fg_color="black", font=my_font)
		nameLabel.place(relx=0.5, rely=0.27, anchor="center")
		
		Label1 = ctk.CTkLabel(my_Frame, text="Updating the software will make sure that you have the latest improvements and functionality.", font=my_font, text_color="white", fg_color="black")
		Label1.place(relx=0.5, rely=0.38, anchor="center")
		Label2 = ctk.CTkLabel(my_Frame, text="Make sure you have all keys and files backed-up on at least one seperate USB-device before proceeding!", font=my_font, text_color="white", fg_color="black")
		Label2.place(relx=0.5, rely=0.44, anchor="center")
		Label3 = ctk.CTkLabel(my_Frame, text="Insert the USB-device with the updated software before starting.", font=my_font, text_color="white", fg_color="black")
		Label3.place(relx=0.5, rely=0.53, anchor="center")	
		selectButton = ctk.CTkButton(my_Frame, text="Start update!", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=do_updateSoftware) 
		selectButton.place(relx=0.5, rely=0.66, anchor="center")
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=self.create_getSettimetextbox) 
		backButton.place(relx=0.5, rely=0.86, anchor="center")
	
	def get_total_BTC_amount(self):
		completeName = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		amount = 0.0
		SATs_value = 0.0
		try:
			with open(completeName, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:
						if lines[0] != 'Spent' and lines[0] != 'Timestamp':
							amount = amount + float(lines[5])
		except FileNotFoundError:
			messagebox.showinfo("Information", "No paper wallet file found.")
		
		amount = round(amount, 8)
		
		if amount < 0.01:
			SATs_value = amount * 100000000
			SATs_value_rounded = round(SATs_value, 8)
			
			return SATs_value_rounded
		else:
			
			BTC_value_rounded = round(SATs_value, 8)
			return amount
				
	def create_Hometextbox(self):
		global s_width,s_height
		global path_to_USB_secure, use_filter
		global timeSecUSBLastModified
		global PersonalGPGKey
		global filepathdestinationfolder
		global System_button_color
		global GPG_button_color
		global SecUSB_button_color
		global DigitalID_button_color
		global Boltcard_button_color
		
		global softwareVersion
		global softwareStatus, layout
		amount_round = 0.0
		amount = 0.0
		use_filter = ' '
		notset_str = ''
		logged_in_user = ''
		users_theme = ''
		users_colors = ''
		main_frame_bg = 'black'
		main_frame_bg_mid = 'black'
		
		more_info_text = "Select what Quick-select buttons that should be displayed using \"Edit\" -button in \"Settings\".\n\nMax 4 Quick-select buttons."
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
			
		def clock():
			hour = time.strftime("%H")
			minute = time.strftime("%M")
			second = time.strftime("%S")
			
			timeLabel.config(text=hour + ":" + minute + ":" + second)
			timeLabel.after(1000, clock)
		
		def date():
			weekday = time.strftime("%A")
			dayofmonth = time.strftime("%d")
			month = time.strftime("%B")
			year = time.strftime("%Y")
			
			dateLabel.config(text=weekday + " the " + dayofmonth + " of " + month + ' ' + year)
			dateLabel.after(1000, date)
		
		def update():
			timeLabel.config(text="New Text")
		
		def saveToFile():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			if USER_INP == '':
				USER_INP = logged_in_user + '_Message'
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(self.textBox.get('1.0', 'end'))
			c.close()
			messagebox.showinfo('Information', 'File \"' + USER_INP + '.txt\"' + ' has been saved.')
			self.create_meny()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		pathInheritanceMessage = str(filepathdestinationfolder) + "/secure/inheritanceMessage.txt"
		if os.path.isfile(pathInheritanceMessage):
			pathtobackg = str(filepathdestinationfolder) + '/images/Inheritance_background.JPG'
		else:
			pathtobackg = self.get_background_image()	
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
		
		def display_personal_avatar():		
			# Check if alias file exists.
			foundit = False
			if os.path.isfile(path_to_externalAliases_localcopy):
				with open(path_to_externalAliases_localcopy) as f:
					for row in csv.reader(f):
						if row[0] == PersonalGPGKey:
							if row[2] == 'Anon':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_anon.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Male':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_man.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Woman':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_woman.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Boy':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_boy.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Girl':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_girl.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Yin Yang':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_yinyang.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							elif row[2] == 'Skull':
								pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_skull.png"
								avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(100, 100))
								foundit = True
							else:
								pathtoavataricon = str(filepathdestinationfolder) + "/Documents/" + row[2]
								if os.path.isfile(pathtoavataricon):
									avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
									foundit = True
			if foundit:
				avatarButtonpic = ctk.CTkButton(my_Frame, text="", image = avatariconimage, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=self.create_getSettimetextbox)
				avatarButtonpic.place(relx=0.92, rely=0.1, anchor='center')
		
		external_alias_file = filepathdestinationfolder + "/Documents/externalAliases.csv"
				
		def display_login_avatars():
			# Check if alias file exists.
			if not os.path.isfile(external_alias_file):
				return False
			else:
				my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
				try:
					with open(external_alias_file) as f:
						nr_avatars = sum(1 for line in f)
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
				offset2 = 0.35
				offset3 = 0.25
				offset4 = 0.15
				cc = 0
				with open(external_alias_file) as f:
					for row in csv.reader(f):
						if row[2] == 'Anon':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_anon.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Male':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_man.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Woman':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_woman.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Boy':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_boy.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Girl':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/AI_girl.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Yin Yang':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_yinyang.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						elif row[2] == 'Skull':
							pathtoavataricon = str(filepathdestinationfolder) + "/Pictures/user_skull.png"
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
						else:
							pathtoavataricon = str(filepathdestinationfolder) + "/Documents/" + row[2]
							avatariconimage = ctk.CTkImage(light_image=Image.open(pathtoavataricon), dark_image=Image.open(pathtoavataricon), size=(140, 140))
							
						if nr_avatars == 1:
							Buttonpic = ctk.CTkButton(my_Frame, text=row[1], image = avatariconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=partial(self.avatar_decrypt_SecUSB, row[0]))	
							Buttonpic.place(relx=0.5, rely=0.28, anchor='center')
						elif nr_avatars == 2:
							Buttonpic = ctk.CTkButton(my_Frame, text=row[1], image = avatariconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=partial(self.avatar_decrypt_SecUSB, row[0]))	
							Buttonpic.place(relx=offset2, rely=0.28, anchor='center')
							offset2 += 0.3
						elif nr_avatars == 3:
							Buttonpic = ctk.CTkButton(my_Frame, text=row[1], image = avatariconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=partial(self.avatar_decrypt_SecUSB, row[0]))	
							Buttonpic.place(relx=offset3, rely=0.28, anchor='center')
							offset3 += 0.25
						elif nr_avatars > 3 and cc < 4:
							Buttonpic = ctk.CTkButton(my_Frame, text=row[1], image = avatariconimage, compound=TOP, anchor='center', text_color="white", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=partial(self.avatar_decrypt_SecUSB, row[0]))	
							Buttonpic.place(relx=offset4, rely=0.28, anchor='center')
							offset4 += 0.23
							cc += 1
				return True		
			
		timeLabel = tk.Label(self, text="", font=("Helvetica", 16), fg="white", bg=main_frame_bg)
		dateLabel = tk.Label(self, text="", font=("Helvetica", 16), fg="white", bg=main_frame_bg)
		
		clock()
		date()
		
		timeLabel.place(relx=0.95, rely=0.94, anchor="e")
		dateLabel.place(relx=0.95, rely=0.97, anchor="e")
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = filepathdestinationfolder + "/secure/layout.csv"
			if not os.path.isfile(completeName):
				layout = ['Standard']
				
				with open(completeName, 'w') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(layout)
			else:
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:
								layout = lines[0]
				except FileNotFoundError:
					messagebox.showinfo("Information", "No layout file found.")
			
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="italic", underline=False, overstrike=False)
		if path_to_USB_secure == 'Secure USB folder is available' and layout == 'Easy' and not os.path.isfile(pathInheritanceMessage):
			completeName = str(filepathdestinationfolder) + "/secure/layout_settings.csv"
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							type1 = lines[0]
							data1 = lines[1]
							type2 = lines[2]
							data2 = lines[3]
							type3 = lines[4]
							data3 = lines[5]
							type4 = lines[6]
							data4 = lines[7]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No layout settings file found.")
					
			if type1 != 'none':
				# Add buttons if not empty
				if type1 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your key:\n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_key, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign a transaction\n for Bitcoin wallet:\n--------------------\n " + data1, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCamera, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_ID, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
				if type1 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data1))
					Button1.place(relx=0.25, rely=0.2, anchor="center")
			if type2 != 'none':
				# Add buttons if not empty
				if type2 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your key:\n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_key, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign a transaction\n for Bitcoin wallet:\n--------------------\n " + data2, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCamera, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_ID, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
				if type2 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data2))
					Button1.place(relx=0.75, rely=0.2, anchor="center")
			if type3 != 'none':
				# Add buttons if not empty
				if type3 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your key:\n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_key, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign a transaction\n for Bitcoin wallet:\n--------------------\n " + data3, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCamera, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_ID, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data3))
					Button1.place(relx=0.25, rely=0.61, anchor="center")
				if type3 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data3))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
			if type4 != 'none':
				# Add buttons if not empty
				if type4 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your key:\n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_key, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign a transaction\n for Bitcoin wallet:\n--------------------\n " + data4, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCamera, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "  Sign with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_with_ID, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: \n--------------------\n " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
				if type4 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with your ID: \n--------------------\n " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=440, height=200, font=my_font, command=partial(self.easy_sign_document, data4))
					Button1.place(relx=0.75, rely=0.61, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
			Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=120, height=25, font=my_font, command=more_info)
			Buttonmoreinfo.place(relx=0.92, rely=0.95, anchor="center")
			iconlock_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconlocked.png"), dark_image=Image.open("/home/user1/images/iconlocked.png"), size=(35, 35))
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			LoginButton = ctk.CTkButton(my_Frame, image=iconlock_image, text=" Logout", compound="left", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.pre_encrypt_SecUSB)
			LoginButton.place(relx=0.5, rely=0.9, anchor="center")
		
		elif path_to_USB_secure == 'Secure USB folder is available' and layout == 'Quick buttons' and not os.path.isfile(pathInheritanceMessage):
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							logged_in_user = lines[0]
							users_theme = lines[1]
							users_colors = lines[2]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No settings file found.")
				
			my_font = ctk.CTkFont(family="Tahoma", size=34, weight="bold", slant="roman", underline=True, overstrike=False)
			welcomelabel = ctk.CTkLabel(my_Frame, text="WELCOME  " + logged_in_user, text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			welcomelabel.place(relx=0.5, rely=0.1, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="italic", underline=False, overstrike=False)
			applabel = ctk.CTkLabel(my_Frame, text="App: GUIApp.py.", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			applabel.place(relx=0.5, rely=0.16, anchor="center")
			versionLabel = ctk.CTkLabel(my_Frame, text="Version: " + softwareVersion + " (" + softwareStatus + ")", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			versionLabel.place(relx=0.5, rely=0.22, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			quickLabel = ctk.CTkLabel(my_Frame, text="--------------------------------------------------------------- Quick Buttons --------------------------------------------------------------- ", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			quickLabel.place(relx=0.5, rely=0.3, anchor="center")
			
			completeName = str(filepathdestinationfolder) + "/secure/layout_settings.csv"
			
			type1 = 'none'
			data1 = 'none'
			type2 = 'none'
			data2 = 'none'
			type3 = 'none'
			data3 = 'none'
			type4 = 'none'
			data4 = 'none'
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							type1 = lines[0]
							data1 = lines[1]
							type2 = lines[2]
							data2 = lines[3]
							type3 = lines[4]
							data3 = lines[5]
							type4 = lines[6]
							data4 = lines[7]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No layout settings file found.")
					
			if type1 != 'none':
				# Add buttons if not empty
				if type1 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=2, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_key, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "Sign transaction: " + data1, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCamera, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_ID, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data1) != "None":
						name_key = self.lookup_Alias(data1)[-30:]
					else:
						name_key = data1[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
				if type1 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data1)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data1))
					Button1.place(relx=0.5, rely=0.39, anchor="center")
			if type2 != 'none':
				# Add buttons if not empty
				if type2 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_key, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a transaction: " + data2, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCamera, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_ID, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data2) != "None":
						name_key = self.lookup_Alias(data2)[-30:]
					else:
						name_key = data2[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
				if type2 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data2)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data2))
					Button1.place(relx=0.5, rely=0.47, anchor="center")
			if type3 != 'none':
				# Add buttons if not empty
				if type3 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_key, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a transaction: " + data3, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCamera, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_ID, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with ID:"  + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data3) != "None":
						name_key = self.lookup_Alias(data3)[-30:]
					else:
						name_key = data3[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
				if type3 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data3)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data3))
					Button1.place(relx=0.5, rely=0.55, anchor="center")
			if type4 != 'none':
				# Add buttons if not empty
				if type4 == 'Key':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_key, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'Bitcoin':
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a transaction: " + data4, text_color="white", fg_color=Boltcard_button_color, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCamera, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_with_ID, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'QR':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'QR_ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a QR with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'File':
					# Get the alias if any
					if self.lookup_Alias_absolut(data4) != "None":
						name_key = self.lookup_Alias(data4)[-30:]
					else:
						name_key = data4[-16:]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with Key: " + name_key, text_color="white", fg_color=GPG_button_color, corner_radius=5, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
				if type4 == 'File_ID':
					name_key = self.lookup_Alias_absolut(data4)[:30]
					Button1 = ctk.CTkButton(my_Frame, text= "Sign a FILE with ID: " + name_key, text_color="white", fg_color=DigitalID_button_color, corner_radius=40, border_width=3, border_color="white", width=460, height=35, font=my_font, command=partial(self.easy_sign_document, data4))
					Button1.place(relx=0.5, rely=0.63, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
			Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=120, height=25, font=my_font, command=more_info)
			Buttonmoreinfo.place(relx=0.92, rely=0.94, anchor="center")
			iconlock_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconlocked.png"), dark_image=Image.open("/home/user1/images/iconlocked.png"), size=(35, 35))
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			LoginButton = ctk.CTkButton(my_Frame, image=iconlock_image, text=" Logout", compound="left", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.pre_encrypt_SecUSB)
			LoginButton.place(relx=0.5, rely=0.9, anchor="center")
							
		elif path_to_USB_secure == 'Secure USB folder is available':
		 
			total_amount_BTC = self.get_total_BTC_amount()
			
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							logged_in_user = lines[0]
							users_theme = lines[1]
							users_colors = lines[2]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No settings file found.")
				
			if os.path.isfile(pathInheritanceMessage):
				my_font = ctk.CTkFont(family="Tahoma", size=32, weight="bold", slant="italic", underline=True, overstrike=False)
				welcomelabel = ctk.CTkLabel(my_Frame, text="In memory of  " + logged_in_user, text_color="white", fg_color=main_frame_bg_mid, font=my_font)
				welcomelabel.place(relx=0.5, rely=0.07, anchor="center")
			else:
				my_font = ctk.CTkFont(family="Tahoma", size=34, weight="bold", slant="roman", underline=True, overstrike=False)
				welcomelabel = ctk.CTkLabel(my_Frame, text="WELCOME  " + logged_in_user, text_color="white", fg_color=main_frame_bg_mid, font=my_font)
				welcomelabel.place(relx=0.5, rely=0.07, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="italic", underline=False, overstrike=False)
			applabel = ctk.CTkLabel(my_Frame, text="App: GUIApp.py.", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			applabel.place(relx=0.5, rely=0.13, anchor="center")
			versionLabel = ctk.CTkLabel(my_Frame, text="Version: " + softwareVersion + " (" + softwareStatus + ")", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			versionLabel.place(relx=0.5, rely=0.18, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			systemLabel = ctk.CTkLabel(my_Frame, text="----------------------------------------------------------------------- System overview ----------------------------------------------------------------------- ", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			systemLabel.place(relx=0.5, rely=0.23, anchor="center")
			Label1 = ctk.CTkLabel(my_Frame, text="Bitcoin wallets:", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			Label1.place(relx=0.47, rely=0.29, anchor="e")
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
			Counting = 0
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						Counting += 1
						walletname = lines[0]
					if Counting == 1:
						Button1 = ctk.CTkButton(my_Frame, text= str(Counting) + "  Bitcoin wallet available", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=partial(self.showBitcoinwallet, walletname))
						Button1.place(relx=0.48, rely=0.29, anchor="w")
					else:
						Button1 = ctk.CTkButton(my_Frame, text= str(Counting) + "  Bitcoin wallets available", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=self.create_Bitcoinmeny)
						Button1.place(relx=0.48, rely=0.29, anchor="w")
			except FileNotFoundError:
				Button1 = ctk.CTkButton(my_Frame, text= "No wallets added", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=self.create_BitcoinWalletmeny)
				Button1.place(relx=0.48, rely=0.29, anchor="w")
			
			BTCLabel = ctk.CTkLabel(my_Frame, text="Bitcoin in singel address wallets:", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			BTCLabel.place(relx=0.47, rely=0.35, anchor="e")
			if total_amount_BTC > 100:
				amountButton = ctk.CTkButton(my_Frame, text=str(int(total_amount_BTC)) + ' sats', text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=partial(self.create_Bitcointextbox, 'all'))
				amountButton.place(relx=0.48, rely=0.35, anchor="w")
			else:
				amountButton = ctk.CTkButton(my_Frame, text=str(total_amount_BTC) + ' BTC', text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=partial(self.create_Bitcointextbox, 'all'))
				amountButton.place(relx=0.48, rely=0.35, anchor="w")
				
			Label4 = ctk.CTkLabel(my_Frame, text="Secure archive size (MB):", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			Label4.place(relx=0.47, rely=0.41, anchor="e")
			
			size = 0.0
			secure_folder_path = filepathdestinationfolder + '/secure'
			the_dir = Path(secure_folder_path)
			size = sum(f.stat().st_size for f in the_dir.glob('**/*') if f.is_file())
			 
			size_kb = size / 1024
			size_mb = size_kb / 1024
			answer = str(round(size_mb, 2))
			Button3 = ctk.CTkButton(my_Frame, text=answer, text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=partial(self.check_SecUSB, "none"))
			Button3.place(relx=0.48, rely=0.41, anchor="w")
			
			Label5 = ctk.CTkLabel(my_Frame, text="Latest modification (history):", text_color="white", fg_color=main_frame_bg_mid, font=my_font)
			Label5.place(relx=0.47, rely=0.47, anchor="e")
			Button5 = ctk.CTkButton(my_Frame, text=timeSecUSBLastModified, text_color="white", fg_color=System_button_color, border_width=2, border_color="white", width=280, height=32, font=my_font, command=self.create_historytextbox)
			Button5.place(relx=0.48, rely=0.47, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			
			iconlock_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconlocked.png"), dark_image=Image.open("/home/user1/images/iconlocked.png"), size=(35, 35))
			iconopen_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconopen.png"), dark_image=Image.open("/home/user1/images/iconopen.png"), size=(35, 35))
			
			if os.path.isfile(pathInheritanceMessage):
				f = open(pathInheritanceMessage, "r")
				file_content = f.read()
				f.close()
				self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 18), wrap = 'word', undo = True)
				self.textBox.place(relx=0.5, rely=0.64, height=172, width=860, anchor="center")
				self.textBox.tag_config("center", justify="center")
				self.textBox.insert("1.0", file_content, "center")
				my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
				verifyButton = ctk.CTkButton(my_Frame, text="Check signature for the inheritance package *", text_color="white", fg_color='red4', border_width=2, border_color="white", width=370, height=32, font=my_font, command=self.check_document)
				verifyButton.place(relx=0.5, rely=0.81, anchor="center")
				saveButton = ctk.CTkButton(my_Frame, text="Save to USB", text_color="white", fg_color='red4', border_width=2, border_color="white", width=120, height=32, font=my_font, command=saveToFile)
				saveButton.place(relx=0.8, rely=0.81, anchor="center")
				Labelinfo = ctk.CTkLabel(my_Frame, text="* Checking the signature (and timestamp) is important in order to verify authenticity.", text_color="white", fg_color="black", font=my_font)
				Labelinfo.place(relx=0.15, rely=0.86, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
				LoginButton = ctk.CTkButton(my_Frame, image=iconlock_image, text=" Logout", compound="left", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.pre_encrypt_SecUSB)
				LoginButton.place(relx=0.5, rely=0.93, anchor="center")
			else:
				LoginButton = ctk.CTkButton(my_Frame, image=iconlock_image, text=" Logout", compound="left", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.pre_encrypt_SecUSB)
				LoginButton.place(relx=0.5, rely=0.8, anchor="center")
			iconopen_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconopen.png"), dark_image=Image.open("/home/user1/images/iconopen.png"), size=(30, 30))
			openlock_Label = ctk.CTkLabel(self, text="", image=iconopen_image, fg_color=main_frame_bg)
			openlock_Label.place(relx=0.02, rely=0.95, anchor="w")
			
			display_personal_avatar()			
		else:
			iconopen_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconopen.png"), dark_image=Image.open("/home/user1/images/iconopen.png"), size=(35, 35))
			
			my_font = ctk.CTkFont(family="Arial", size=44, weight="bold", slant="roman", underline=False, overstrike=False)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
			private_keys = gpg.list_keys(True)
			
			clicked = StringVar()
				
			List_fingerprints = []
			
			for i in private_keys:
				List_fingerprints.append(i['fingerprint'])
			
			if not List_fingerprints:	
				startButton = ctk.CTkButton(my_Frame, text=" Start ", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.new_secureUSB_Pre)
				startButton.place(relx=0.5, rely=0.37, anchor="center")
			else:
				if not display_login_avatars():
					LoginButton = ctk.CTkButton(my_Frame, image=iconopen_image, text=" Login", compound="left", corner_radius=25, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=self.decrypt_SecUSB)
					LoginButton.place(relx=0.5, rely=0.35, anchor="center")
				else:
					my_font = ctk.CTkFont(family="Tahoma", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
					otherLoginButton = ctk.CTkButton(my_Frame, text="Other key Login", corner_radius=8, text_color="white", fg_color="black", border_width=1, border_color="white", font=my_font, command=self.decrypt_SecUSB)
					otherLoginButton.place(relx=0.5, rely=0.58, anchor="center")
				
				my_font = ctk.CTkFont(family="Tahoma", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
				LoginButton = ctk.CTkButton(my_Frame, text=" Create new account", corner_radius=15, text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=("Arial", 18), command=self.new_secureUSB_Pre)
				LoginButton.place(relx=0.5, rely=0.51, anchor="center")
				
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
			
			LoginButton = ctk.CTkButton(my_Frame, text="(Restore from backup)", text_color="white", fg_color='black', corner_radius=0, border_width=3, border_color="black", font=my_font, command=self.restoreFromencrypted_SecUSB)
			LoginButton.place(relx=0.5, rely=0.68, anchor="center")
			
			my_hw = self.get_common_sec_hw_data()
			if my_hw:					# there is a common secure hardware registered
				if my_hw[2] != 'none':	# and the docking station is first to be checked before connecting keyb/mouse
					dockLabel = ctk.CTkLabel(my_Frame, text="Docking station *:", text_color="light blue", fg_color="black", font=my_font)
					dockLabel.place(relx=0.48, rely=0.78, anchor="e")
					dockLabelvalue = ctk.CTkLabel(my_Frame, text=my_hw[2], text_color="light blue", fg_color="black", font=my_font)
					dockLabelvalue.place(relx=0.5, rely=0.78, anchor="w")
					my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
					warningLabel = ctk.CTkLabel(my_Frame, text="* Compare to externally written down value before connecting the Offline device.", text_color="light blue", fg_color="black", font=my_font)
					warningLabel.place(relx=0.48, rely=0.94, anchor="center")
				
					if my_hw[0] != 'none':
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)		
						keyboardLabel = ctk.CTkLabel(my_Frame, text="Keyboard **:", text_color="light blue", fg_color="black", font=my_font)
						keyboardLabel.place(relx=0.48, rely=0.83, anchor="e")
						keyboardLabelvalue = ctk.CTkLabel(my_Frame, text=my_hw[0], text_color="light blue", fg_color="black", font=my_font)
						keyboardLabelvalue.place(relx=0.5, rely=0.83, anchor="w")
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
						warningLabel2 = ctk.CTkLabel(my_Frame, text="** Compare with scanned/marked value from device before connecting it to the system.", text_color="light blue", fg_color="black", font=my_font)
						warningLabel2.place(relx=0.48, rely=0.98, anchor="center")
					if my_hw[1] != 'none':
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
						mouseLabel = ctk.CTkLabel(my_Frame, text="Mouse **:", text_color="light blue", fg_color="black", font=my_font)
						mouseLabel.place(relx=0.48, rely=0.88, anchor="e")
						mouseLabelvalue = ctk.CTkLabel(my_Frame, text=my_hw[1], text_color="light blue", fg_color="black", font=my_font)
						mouseLabelvalue.place(relx=0.5, rely=0.88, anchor="w")
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
						warningLabel2 = ctk.CTkLabel(my_Frame, text="** Compare with scanned/marked value from device before connecting it to the system.", text_color="light blue", fg_color="black", font=my_font)
						warningLabel2.place(relx=0.48, rely=0.98, anchor="center")
				else:					# There is no docking station
					if my_hw[0] != 'none':
						keyboardLabel = ctk.CTkLabel(my_Frame, text="Keyboard *:", text_color="light blue", fg_color="black", font=my_font)
						keyboardLabel.place(relx=0.48, rely=0.8, anchor="e")
						keyboardLabelvalue = ctk.CTkLabel(my_Frame, text=my_hw[0], text_color="light blue", fg_color="black", font=my_font)
						keyboardLabelvalue.place(relx=0.5, rely=0.8, anchor="w")
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
						warningLabel = ctk.CTkLabel(my_Frame, text="* Compare with scanned/marked value from device before connecting it to the Offline device...", text_color="light blue", fg_color="black", font=my_font)
						warningLabel.place(relx=0.48, rely=0.95, anchor="center")
					if my_hw[1] != 'none':
						mouseLabel = ctk.CTkLabel(my_Frame, text="Mouse *:", text_color="light blue", fg_color="black", font=my_font)
						mouseLabel.place(relx=0.48, rely=0.85, anchor="e")
						mouseLabelvalue = ctk.CTkLabel(my_Frame, text=my_hw[1], text_color="light blue", fg_color="black", font=my_font)
						mouseLabelvalue.place(relx=0.5, rely=0.85, anchor="w")
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
						warningLabel = ctk.CTkLabel(my_Frame, text="* Compare with scanned/marked value from device before connecting it to the Offline device...", text_color="light blue", fg_color="black", font=my_font)
						warningLabel.place(relx=0.48, rely=0.95, anchor="center")
			else:
				print("No Secure hardware check at startup")
			
			pathsettingsicon = str(filepathdestinationfolder) + "/images/settings_icon.jpg"
			pathofficon = str(filepathdestinationfolder) + "/images/off.jpg"
			
			settingsimage = ctk.CTkImage(light_image=Image.open(pathsettingsicon), dark_image=Image.open(pathsettingsicon), size=(22, 22))
			offimage = ctk.CTkImage(light_image=Image.open(pathofficon), dark_image=Image.open(pathofficon), size=(28, 28))
			
			offbutton = ctk.CTkButton(self, text="", image = offimage, anchor='center', text_color="black", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=self.pre_encryptanddestroy)
			offbutton.place(relx=0.03, rely=0.96, anchor='center')
								
			settingspicbutton = ctk.CTkButton(self, text="", image = settingsimage, anchor='center', text_color="black", fg_color="black", corner_radius=0, border_width=0, border_color="black", width=80, height=60, font=my_font, command=self.create_getSettimetextbox)
			settingspicbutton.place(relx=0.98, rely=0.96, anchor='center')
	
	def get_common_sec_hw_data(self):
		global PersonalGPGKey
		data_list = []
		pathtofile = "/home/user1/sec_hw.csv"
		if os.path.isfile(pathtofile): # If there is a file with common hardware data
			with open(pathtofile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					data_list.append(lines[0])
		return data_list
		
	def get_sec_hw_data(self):
		global PersonalGPGKey
		data_list = []
		pathtofile = "/home/user1/sec_hw" + PersonalGPGKey + ".csv"
		if os.path.isfile(pathtofile): # If there is a file with hardware data
			with open(pathtofile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					data_list.append(lines[0])
		return data_list
		
	def get_hw_setting(self):
		global PersonalGPGKey
		data_list = []
		pathtofile = "/home/user1/hw_setting" + PersonalGPGKey + ".csv"
		if os.path.isfile(pathtofile): # If there is a file with hardware data
			with open(pathtofile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					data_list.append(lines[0])
		else:
			data_list.append('none')
		return data_list
		
	def set_hw_settings(self, new_setting):
		global PersonalGPGKey
		pathtofile = "/home/user1/hw_setting" + PersonalGPGKey + ".csv"
		if os.path.isfile(pathtofile): # If there is a file with hardware setting remove it and create a new with data provided
			os.remove(pathtofile)
			
		with open(pathtofile, 'w') as file:
			file.write(new_setting)
		
		return True
	
	def set_common_sec_hw_settings(self, data_list):
		global PersonalGPGKey
		pathtofile = "/home/user1/sec_hw.csv"
		if os.path.isfile(pathtofile): # If there is a file with common hardware data remove it and create a new with data provided
			os.remove(pathtofile)
			
		with open(pathtofile, 'w') as file:
			writer = csv.writer(file)
			for item in data_list:
				writer.writerow([item])
		self.create_getSettimetextbox()
					
	def set_sec_hw_settings(self, data_list):
		global PersonalGPGKey
		pathtofile = "/home/user1/sec_hw" + PersonalGPGKey + ".csv"
		if os.path.isfile(pathtofile): # If there is a file with hardware data remove it and create a new with data provided
			os.remove(pathtofile)
			
		with open(pathtofile, 'w') as file:
			writer = csv.writer(file)
			for item in data_list:
				writer.writerow([item])
		self.create_getSettimetextbox()
		
	def edit_sec_hw(self):
		global PersonalGPGKey
		global filepathdestinationfolder
		global System_button_color
		global dock_name, keyboard_name, mouse_name
		
		dock_name = ''
		keyboard_name = ''
		mouse_name = ''
		
		def limitSizekeyboard(*args):
			value = keyboard_name_var.get()
			if len(value) > 25: keyboard_name_var.set(value[:25])
		
		def limitSizemouse(*args):
			value = mouse_name_var.get()
			if len(value) > 25: mouse_name_var.set(value[:25])
		
		def limitSizedock(*args):
			value = dock_name_var.get()
			if len(value) > 25: dock_name_var.set(value[:25])
			
		def pre_set_values():
			global dock_name, keyboard_name, mouse_name
			
			data_list = self.get_common_sec_hw_data()
			
			if len(data_list) == 3: 	# E.g here is a docking station already defined
				keyboard_name = data_list[0]
				mouse_name = data_list[1]
				dock_name = data_list[2]
			else:
				print("No secure hardware defined")
				
		def update_sec_hw():
			new_common_data_list = []
			new_data_list = []
			data_found = False
			
			# Set the policy of checking keyboard and data for the individual user
			self.set_hw_settings("keyboard_mouse")
			
			# Read the new common HW settings and write it to common file
			if keyboard_name_var.get() != '' and keyboard_name_var.get() != ' ':
				new_common_data_list.append(keyboard_name_var.get())
			else:
				new_common_data_list.append('none')
			if mouse_name_var.get() != '' and mouse_name_var.get() != ' ':	
				new_common_data_list.append(mouse_name_var.get())
			else:
				new_common_data_list.append('none')
			if dock_name_var.get() != '' and dock_name_var.get() != ' ':
				new_common_data_list.append(dock_name_var.get())
			else:
				new_common_data_list.append('none')
			self.set_common_sec_hw_settings(new_common_data_list)
			
			# Get the keyboard data and serial number and save in user specific file
			cmd = 'sudo lsusb | grep -i "keyboard"'
			k_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
			clean_k_data = k_data.stdout.strip().decode("utf-8")
			real_k_data = clean_k_data.partition(":")
			clean_k_data_ = real_k_data[2].strip('"')
			new_data_list.append(clean_k_data_)
			
			cmd = "sudo lsusb -v -d $(lsusb |grep -i 'keyboard' | awk '{print $6}') | grep 'iSerial'"
			k_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
			clean_k_serial = k_serial.stdout.strip().decode("utf-8")
			new_data_list.append(clean_k_serial)
			
			# Get the mouse data and serial number
			cmd = 'sudo lsusb | grep -i "mouse"'
			m_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
			clean_m_data = m_data.stdout.strip().decode("utf-8")
			real_m_data = clean_m_data.partition(":")
			clean_m_data_ = real_m_data[2].strip('"')
			new_data_list.append(clean_m_data_)
			
			cmd = "sudo lsusb -v -d $(lsusb |grep -i 'mouse' | awk '{print $6}') | grep 'iSerial'"
			m_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
			clean_m_serial = m_serial.stdout.strip().decode("utf-8")
			new_data_list.append(clean_m_serial)
			
			self.set_sec_hw_settings(new_data_list)
							
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Input identifying hardware values:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.06, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		pre_set_values()
		
		keyboard_name_var = ctk.StringVar(value=keyboard_name)
		keyboard_name_var.trace('w', limitSizekeyboard)
		mouse_name_var = ctk.StringVar(value=mouse_name)
		mouse_name_var.trace('w', limitSizemouse)
		dock_name_var = ctk.StringVar(value=dock_name)
		dock_name_var.trace('w', limitSizedock)
		
		Label0 = ctk.CTkLabel(my_Frame, text="This could be a scanned NFC-value, a permanent security sticker etc.", text_color="white", fg_color="black", font=my_font)
		Label0.place(relx=0.05, rely=0.12, anchor="w")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Docking station identifying value:", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.43, rely=0.18, anchor="e")
		dockEntry = ctk.CTkEntry(my_Frame, placeholder_text=dock_name, textvariable=dock_name_var, width=350, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		dockEntry.place(relx=0.44, rely=0.18, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Keyboard identifying value:", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.43, rely=0.24, anchor="e")
		keyboardEntry = ctk.CTkEntry(my_Frame, placeholder_text=keyboard_name, textvariable=keyboard_name_var, width=350, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		keyboardEntry.place(relx=0.44, rely=0.24, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Mouse identifying value:", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.43, rely=0.3, anchor="e")
		mouseEntry = ctk.CTkEntry(my_Frame, placeholder_text=mouse_name, textvariable=mouse_name_var, width=350, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		mouseEntry.place(relx=0.44, rely=0.3, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
		Label01 = ctk.CTkLabel(my_Frame, text="Routine for verifying your hardware at start-up:", text_color="white", fg_color="black", font=my_font)
		Label01.place(relx=0.05, rely=0.37, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		Label11 = ctk.CTkLabel(my_Frame, text="If you have a docking station, scan/check its identifying value before connecting the Offline device to it.", text_color="white", fg_color="black", font=my_font)
		Label11.place(relx=0.05, rely=0.43, anchor="w")
		Label111 = ctk.CTkLabel(my_Frame, text="The docking station ID/code/number could be visible on the backside of your Offline device (for convenience).", text_color="white", fg_color="black", font=my_font)
		Label111.place(relx=0.05, rely=0.48, anchor="w")
		Label22 = ctk.CTkLabel(my_Frame, text="If you don't have a docking station, check BOTH the keyboard and mouse's number/codes before connecting them.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.05, rely=0.56, anchor="w")
		Label222 = ctk.CTkLabel(my_Frame, text="Those number/codes could be visible on the backside of your Offline device (for convenience).", text_color="white", fg_color="black", font=my_font)
		Label222.place(relx=0.05, rely=0.61, anchor="w")
		
		layoutButton = ctk.CTkButton(my_Frame, text="Save", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=update_sec_hw) 
		layoutButton.place(relx=0.4, rely=0.78, anchor="center")
		
		HomeButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", border_width=2, border_color="white", fg_color=System_button_color, width=120, height=32, font=my_font, command=self.create_getSettimetextbox)
		HomeButton.place(relx=0.6, rely=0.78, anchor="center")
					
	def GnuPG_Home(self):		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		l1_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		l1_Frame.place(relx=0.27, rely=0.35, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(l1_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		l2_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		l2_Frame.place(relx=0.27, rely=0.6, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(l2_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		l3_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		l3_Frame.place(relx=0.27, rely=0.85, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(l3_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		r1_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		r1_Frame.place(relx=0.73, rely=0.35, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(r1_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		r2_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		r2_Frame.place(relx=0.73, rely=0.6, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(r2_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		r3_Frame = ctk.CTkFrame(my_Frame, 
		width=450, 
		height=120,
		border_width=2,
		border_color="green"
		)
		r3_Frame.place(relx=0.73, rely=0.85, anchor="center")
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(446, 116))
		Label_backg = ctk.CTkLabel(r3_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
			
		my_font = ctk.CTkFont(family="Tahoma", size=34, weight="bold", slant="roman", underline=True, overstrike=False)
		welcomelabel = ctk.CTkLabel(my_Frame, text="Gnu Privacy Guard", text_color="light green", fg_color="black", font=my_font)
		welcomelabel.place(relx=0.5, rely=0.1, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="italic", underline=False, overstrike=False)
		applabel = ctk.CTkLabel(my_Frame, text="Version: 2.2.27", text_color="light green", fg_color="black", font=my_font)
		applabel.place(relx=0.5, rely=0.17, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		systemLabel = ctk.CTkLabel(my_Frame, text="------------------------------------------------------------------------------------------------ Overview ------------------------------------------------------------------------------------------------ ", text_color="light green", fg_color="black", font=my_font)
		systemLabel.place(relx=0.5, rely=0.22, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The first left box
		Label_l1 = ctk.CTkLabel(l1_Frame, text="Check local keys", text_color="light green", fg_color="black", font=my_font)
		Label_l1.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(l1_Frame, text="View all keys on the local keychain.\nBoth the primary key's and subkey's are listed.\nSubkey's that have been moved to a Yubikey is\nmarked as such.", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The second left box
		Label5 = ctk.CTkLabel(l2_Frame,text="Add/remove key", text_color="light green", fg_color="black", font=my_font)
		Label5.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(l2_Frame, text="Add a new key or remove keys or subkeys.\nIf a new key is going to have subkeys (that can be\nmoved) then check the box \"only certify\".\nThis will create a certifying key with three subkeys.", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The third left box
		Label5 = ctk.CTkLabel(l3_Frame, text="Add subkeys", text_color="light green", fg_color="black", font=my_font)
		Label5.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(l3_Frame, text="Add subkeys to an existing key.\nIt will create three subkeys at once. Encrypt, sign\nand authenticate.", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The first right box
		Label_l1 = ctk.CTkLabel(r1_Frame, text="Backup keys", text_color="light green", fg_color="black", font=my_font)
		Label_l1.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(r1_Frame, text="Backup a selected private key and all\nthe public keys on the local keychain to the\ninternal secure archive.", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The second right box
		Label5 = ctk.CTkLabel(r2_Frame,text="Import/export", text_color="light green", fg_color="black", font=my_font)
		Label5.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(r2_Frame, text="Move a key from a file to the local keychain.\nKey file should be in ASC-format.\nExport a private or public key to a file.\n", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		# The third rigth box
		Label5 = ctk.CTkLabel(r3_Frame, text="Encrypt/Sign/check", text_color="light green", fg_color="black", font=my_font)
		Label5.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label_l12 = ctk.CTkLabel(r3_Frame, text="Encrypt files, decrypt files and sign keys or files with\none of the private keys on the local keychain.\nSigning a file will generate a \"detached signature\".", text_color="light green", fg_color="black", anchor="nw", justify=LEFT, font=my_font)
		Label_l12.place(x=7, y=27)
		
	def get_GnuPGKeys(self, fingerprint):
		global PersonalGPGKey, key_email, key_alias, diceFunction
		global GPG_button_color, key_record, expires, updated, key_length
		
		expires = 0.0
		updated = 0.0
		key_record = 'key'		
		
		def get_trust_for_key(i):
			global key_email, key_alias, expires, updated, key_length
			
			trust_level = 'UNDEFINED'
			
			key_length = i['length']
			str_expires = i['expires']
			if str_expires == '':
				expires = 0.0
			else:
				expires = float(str_expires)
			str_updated = i['updated']
			if str_updated == '':
				updated = 0.0
			else:
				updated = float(str_expires)
			key_email_list = i['uids']
			key_email = key_email_list[0]
			key_alias_list = key_email.split("<")
			key_alias = key_alias_list[0][:42]
			# Get the trust level
			if i['trust'] == 'n':
				trust_level = 'NOT VALID'
			if i['trust'] == 'm':
				trust_level = 'MARGINALLY VALID'
			if i['trust'] == 'f':
				trust_level = 'FULLY VALID'
			if i['trust'] == 'u':
				trust_level = 'VALID ULTIMATE'
			return trust_level
			
		my_Frame = ctk.CTkFrame(self,
		width=1200, 
		height=650,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1176, 
		height=316,
		border_width=0,
		orientation="vertical",
		border_color="green",
		fg_color="gray1"
		)
		
		bottom_Frame._scrollbar.configure(height=0)
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backgg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 230))
		Label_backgg = ctk.CTkLabel(bottom_Frame, image=backgg, text = "")
		Label_backgg.place(x=0, y=0)
		bottom_Frame.place(x=2, y=320, anchor="nw")
		
		if fingerprint == PersonalGPGKey:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="RoyalBlue2",
			fg_color="black"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
		else:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="DeepPink4",
			fg_color="black"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		public_keys = []
		private_keys = []
		
		public_keys = gpg.list_keys()
		private_keys = gpg.list_keys(True)
		mapp = private_keys.key_map

		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		if diceFunction == 'showID_more':
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color="dark green", border_width=2, border_color="white", command=partial(self.showID_more, fingerprint))
			backButton.place(relx=0.92, rely=0.05, anchor="center")
		else:
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color="dark green", border_width=2, border_color="white", command=partial(self.get_GnuPGKeys_compact, ['_none__']))
			backButton.place(relx=0.92, rely=0.05, anchor="center")
			
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight='bold', underline=True, overstrike=False)
	
		self.cleanupgroups()
		
		if private_keys:	
			for i in private_keys:
				if i['fingerprint'] == fingerprint:
					trust_level = get_trust_for_key(i)
					# Get key photo (if any) and save as file
					photo_path = "/home/user1/secure/keys"
					command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + fingerprint
					os.system(command)
					
					curr_Alias = ''
					if self.lookup_Alias_absolut(fingerprint) != "None":
						curr_Alias = self.lookup_Alias(fingerprint)
								
					my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
					if fingerprint == PersonalGPGKey:
						tc = 'RoyalBlue2'
					elif trust_level == 'VALID ULTIMATE' or trust_level == 'FULLY VALID':
						tc = 'light green'
					elif trust_level == 'MARGINALLY VALID':
						tc = 'orange'
					else:
						tc = 'white'
					# Show image
					pic_icon_path = photo_path + '/pic' + fingerprint[-8:] + '.jpg'
					nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
					if os.path.isfile(pic_icon_path):
						keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
					else:
						keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
					
					Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = keyiconimage)
					Labelpublicimg.place(relx=0.14, rely=0.27, anchor="center")
					
					short_alias = self.lookup_Alias_absolut(fingerprint)
												
					my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label1 = ctk.CTkLabel(my_Frame, text=short_alias, text_color=tc, fg_color="black", font=my_font)
					Label1.place(relx=0.23, rely=0.18, anchor="w")
					
					my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
					Label2 = ctk.CTkLabel(my_Frame, text="    Key ID: " + key_email[:60], text_color=tc, fg_color="black", font=my_font)	
					Label2.place(relx=0.23, rely=0.25, anchor="w")
					
					Label3 = ctk.CTkLabel(my_Frame, text="Fingerprint: " + fingerprint, text_color=tc, fg_color="black", font=my_font)	
					
					Label3.place(relx=0.08, rely=0.44, anchor="w")
					
					Label4 = ctk.CTkLabel(my_Frame, text="    Status: " + trust_level, text_color=tc, fg_color="black", font=my_font)
					Label4.place(relx=0.23, rely=0.30, anchor="w")
					Label42 = ctk.CTkLabel(my_Frame, text="Key length: " + key_length + ' bits', text_color=tc, fg_color="black", font=my_font)
					Label42.place(relx=0.5, rely=0.30, anchor="w")
					
					my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)	
					
					if expires != 0.0:
						now = time.time()
						# Add one week early warning
						now += 604800
						if now > expires:
							Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="red2", fg_color="black", font=my_font)
							Label6.place(relx=0.23, rely=0.37, anchor="w")
						else:
							Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color=tc, fg_color="black", font=my_font)
							Label6.place(relx=0.23, rely=0.37, anchor="w")
					else:
						Label6 = ctk.CTkLabel(my_Frame, text="    Expires: Never", text_color="white", fg_color="black", font=my_font)
						Label6.place(relx=0.23, rely=0.37, anchor="w")
					
					if updated != 0.0:
						Label62 = ctk.CTkLabel(my_Frame, text="Updated: " + datetime.utcfromtimestamp(updated).strftime('%Y-%m-%d'), text_color=tc, fg_color="black", font=my_font)
						Label62.place(relx=0.5, rely=0.37, anchor="w")
					else:
						Label62 = ctk.CTkLabel(my_Frame, text="Updated: < N/A >", text_color=tc, fg_color="black", font=my_font)
						Label62.place(relx=0.5, rely=0.37, anchor="w")
					
					if i['subkeys']: 
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				
						listoflistindict = i['subkeys']
						dictofsubkeyinfo = i['subkey_info']

						for ii in listoflistindict:
							if ii:
								subkinfo = ii[0]
								keytype = dictofsubkeyinfo[subkinfo]['type']
								capacity = dictofsubkeyinfo[subkinfo]['cap']
								token = dictofsubkeyinfo[subkinfo]['token']

								datecrea = int(dictofsubkeyinfo[subkinfo]['date'])		
								dt_datecrea = datetime.fromtimestamp(datecrea)
								dt_datecrea_form = dt_datecrea.strftime('%Y-%m-%d')
								
								dateexp = int(dictofsubkeyinfo[subkinfo]['expires'])
								dt_dateexp = datetime.fromtimestamp(dateexp)
								dt_dateexp_form  = dt_dateexp.strftime('%Y-%m-%d')
								
								if capacity == 's':
									capacity = 'Signing'
								if capacity == 'e':
									capacity = 'Encryption'
								if capacity == 'a':
									capacity = 'Authenticate'
								if token != '#': 
									if token == '>': 
										Label = ctk.CTkLabel(bottom_Frame, text= '         ' + '\"' + capacity + '\"' + ' subkey: ' + ii[2] + '. Created: ' + dt_datecrea_form + '. Expires: ' + dt_dateexp_form + ' (Moved to a Yubikey).', text_color="light green", fg_color="black", font=my_font)
										Label.pack(padx=10, pady=2, side= TOP, anchor="w")
									else:
										Label = ctk.CTkLabel(bottom_Frame, text= '         ' + '\"' + capacity + '\"' + ' subkey: ' + ii[2] + '. Created: ' + dt_datecrea_form + '. Expires: ' + dt_dateexp_form + ' (' + keytype + ').', text_color="light green", fg_color="black", font=my_font)
										Label.pack(padx=10, pady=2, side= TOP, anchor="w")
		else:
			Label = ctk.CTkLabel(bottom_Frame, text='<empty>', text_color="light green", fg_color="black", font=my_font)
			Label.pack(padx=25, pady=2, side= TOP, anchor="w")
		
	def edit_public_key(self, fingerprint):
		global PersonalGPGKey, key_record
		global path_to_USB_secure
		global filepathdestinationfolder
		global key_email, key_alias, trust_level_before, expires, key_date, key_record, key_record2, do_sort
		
		List_Levels = ['TRUST_UNDEFINED', 'TRUST_NEVER', 'TRUST_MARGINAL', 'TRUST_FULLY', 'TRUST_ULTIMATE']
		
		the_group = do_sort
		key_email = '<Undefined>'
		
		trust_level_before  = 'Missing'
		expires = 0.0
		key_date = 0.0
		
		more_info_text = "Trust levels:\nSet Trust level based on how responsible the keys owner is when signing other keys.\n\nExample.\nIf you set trust level on \"Key 1\" to \"TRUST_FULLY\" it means that when you import \"Key 2\" and that key is signed by \"Key 1\", the web-of-trust will tell you that the KEY is \"Valid\".\n\nNOTE: Setting the Trust level has nothing to do with if the key itself belongs to the right person or not.\nThe level \"TRUST_FULLY\" is only for those key owners that you KNOW always first check a persons PASSPORT or PHOTO ID etc before signing ANYTHING. It could be the HR-department for your company or the President of the chess club etc.\nIf you fully or marginally trust the owner you also need to sign the key after you import it (for the Web-of-trust calculations to work)!"
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
			
		def get_trust_for_key(key_fingerprint):
			global key_email, key_alias
			trust_level_never = False
			trust_level_marginal = False
			trust_level_Full = False
			trust_level_Ultimate = False
			
			recommended_trust_level = 'TRUST_UNDEFINED'
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			public_keys = gpg.list_keys()
			
			# Loop through and get the trust for the key
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == key_fingerprint:
						key_email_list = i['uids']
						key_email = key_email_list[0]
						key_alias_list = key_email.split("<")
						key_alias = key_alias_list[0][:42]
						# Get the trust level
						if i['ownertrust'] == 'n':
							trust_level_never = True
						if i['ownertrust'] == 'm':
							trust_level_marginal = True
						if i['ownertrust'] == 'f':
							trust_level_Full = True
						if i['ownertrust'] == 'u':
							trust_level_Ultimate = True
							
				my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
												
				if trust_level_Ultimate:
					recommended_trust_level = 'TRUST_ULTIMATE'
					if fingerprint != PersonalGPGKey:
						tLabel = ctk.CTkLabel(my_Frame, text="* Own keys should be TRUST_ULTIMATE.", text_color="white", fg_color="black", font=my_font)
						tLabel.place(relx=0.64, rely=0.6, anchor="w")
				elif trust_level_Full:
					recommended_trust_level = 'TRUST_FULLY'
				elif trust_level_marginal:
					recommended_trust_level = 'TRUST_MARGINAL'
				elif trust_level_never:
					recommended_trust_level = 'TRUST_NEVER'
					if fingerprint != PersonalGPGKey:
						tLabel = ctk.CTkLabel(my_Frame, text="* Probably for a good reason..", text_color="white", fg_color="black", font=my_font)
						tLabel.place(relx=0.64, rely=0.6, anchor="w")
				else:
					recommended_trust_level = 'TRUST_UNDEFINED'
			return recommended_trust_level
		
		def limitSizeAliasname(*args):
			value = users_alias_name_var.get()
			if len(value) > 42: users_alias_name_var.set(value[:42])
			
		def do_edit_public_Key():
			global filepathdestinationfolder
			global trust_level_before
			already_there = False
			the_alias = aliasEntry.get()
			the_trust = clicked.get()
			answer = 'yes'
			file_ = filepathdestinationfolder + "/secure/Alias.csv"	
			
			if the_trust == 'TRUST_ULTIMATE':
				answer = messagebox.askquestion('Information!', 'TRUST_ULTIMATE is only for your own keys. Are you SURE you want to proceed?')
			
			if the_trust == 'TRUST_FULLY':
				answer = messagebox.askquestion('Information!', 'TRUST_FULLY is only used for keys that you receive in person or that are verified with a passport, photo ID etc. Are you SURE you want to proceed?')
			
			if answer == 'yes':
				new_Alias = [fingerprint, the_alias]
				# Check if alias file exists. If not create it and add the alias and trust selected
				brand_new_alias = True
				if not os.path.isfile(file_):
					f = open(file_, 'w')
					writer = csv.writer(f)
					writer.writerow(new_Alias)
					f.close()
					new_record = [fingerprint, "New Alias.", "Alias set to: " + the_alias + '.']
					self.add_record(new_record)
					gpg.trust_keys(fingerprint, trustlevel=the_trust)
					if the_trust != trust_level_before:
						new_record = [fingerprint, "Updated trust level.", "Trust level changed to: " + the_trust + '.']
						self.add_record(new_record)
						self.add_history("Update for key: " + fingerprint + ", to " + the_trust + '.')
					tk.messagebox.showinfo('Information', "The key was sucessfully updated.")
				else:
					if the_alias == '' or the_alias == ' ':
						the_alias = fingerprint[-16:]
					new_Alias = [fingerprint, the_alias]
					# Go through the alias file and check that the new alias is unique
					with open(file_, 'r') as in_:
						csvfile = csv.reader(in_)
						for lines in csvfile:
							if lines[1] == the_alias and lines[0] != fingerprint:
								brand_new_alias = False
								tk.messagebox.showinfo("Information", "Alias already exists!")
					
					if not brand_new_alias:	
						# The alias was not unique so go back and try again
						self.edit_public_key(fingerprint)			
					else:
						# Remove the old alias-line for the fingerprint 
						self.remove_Alias(fingerprint)
						with open(file_, 'a') as result:
							csvwriter = csv.writer(result)
							csvwriter.writerow(new_Alias)
						new_record = [fingerprint, "Updated Alias.", "Alias changed to: " + the_alias + '.']
						self.add_record(new_record)
						gpg.trust_keys(fingerprint, trustlevel=the_trust)
						if the_trust != trust_level_before:
							new_record = [fingerprint, "Updated trust level.", "Trust level changed to: " + the_trust + '.']
							self.add_record(new_record)
							self.add_history("Update for key: " + fingerprint + ", to " + the_trust + '.')
						tk.messagebox.showinfo('Information', "The key was sucessfully updated.")
						
						# The alias file existed and it was a brand new alias, the alias and trust is updated, now go back to list of keys
						self.get_GnuPGKeys_compact(['_none__'])
			else:
				# The user changed his/her mind and dont want to update, now go back to edit and try again
				self.edit_public_key(fingerprint)
		
		def get_validity():
			global expires, key_date
			validity_text = ' '
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			public_keys = gpg.list_keys()
			for i in public_keys:
				if i['fingerprint'] == fingerprint:
					str_key_date = i['date']
					if str_key_date == '':
						key_date = 0.0
					else:
						key_date = float(str_key_date)
					str_expires = i['expires']
					if str_expires == '':
						expires = 0.0
					else:
						expires = float(str_expires)
					# Get the validity level
					if i['trust'] == 'm':
						validity_text = 'Valid(M)'
					if i['trust'] == 'f' or i['trust'] == 'u':
						validity_text = 'Valid  '
			return validity_text
		
		def set_expire():
			cmd = 'gpg --quick-set-expire ' + fingerprint + ' 2y'
			# set the expiration date
			try:
				os.system(cmd) 
			except Exception:
				pass	
			new_record = [fingerprint, "Set expire date to 2 years.", '']
			self.add_record(new_record)
			self.edit_public_key(fingerprint)
			
		def signed_or_not():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			private_keys = []
			List_fingerprints = []
			public_keys = gpg.list_keys(sigs=True)
			private_keys = gpg.list_keys(True)
			
			# List the private keys that can be used for signing			
			for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					tmp = nkey['fingerprint']
					List_fingerprints.append(tmp[-16:])
				
			if List_fingerprints:	 
				for i in private_keys:
					if i['subkeys']: 
						listoflistindict = i['subkeys']
						dictofsubkeyinfo = i['subkey_info']
						for ii in listoflistindict:
							if ii:
								subkinfo = ii[0]
								tmmp = subkinfo[-16:]
								capacity = dictofsubkeyinfo[subkinfo]['cap']
								if capacity == 's':
									List_fingerprints.append(tmmp)
					for i2 in public_keys:
						# Check if the public key is signed by any private key on local keychain
						if i2['fingerprint'] == fingerprint:
							if i2['sigs']: 
								tuple_of_sigs_in_key = i2['sigs']
								for ii in tuple_of_sigs_in_key:
									if ii:
										if ii[0] in List_fingerprints:
											return True
					return False
			return False
			
		def check_sigs_on_key():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			
			# Get sigs for the selected key
			public_keys = gpg.list_keys(sigs=True)
			temp_list = []
			# Loop through and display sigs
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == fingerprint and i['sigs']: 
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
				
						tuple_of_sigs_in_key = i['sigs']

						for ii in tuple_of_sigs_in_key:
							if ii:
								if ii[0] != i['keyid']:
									sig_Button = ctk.CTkButton(my_Frame, text="List signatures", text_color="white", fg_color="green", width=80, border_width=2, border_color="white", height=30, font=my_font, command=partial(self.show_key_signatures, fingerprint))
									sig_Button.place(relx=0.73, rely=0.13, anchor="center")
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if fingerprint == PersonalGPGKey:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="RoyalBlue2",
			fg_color="gray3"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
		else:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="DeepPink4",
			fg_color="black"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
		
		trust_level = get_trust_for_key(fingerprint)
		trust_level_before = trust_level
		
		# Get key photo (if any) and save as file
		photo_path = "/home/user1/secure/keys"
		command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + fingerprint
		os.system(command)
		
		curr_Alias = ''
		if self.lookup_Alias_absolut(fingerprint) != "None":
			curr_Alias = self.lookup_Alias(fingerprint)
					
		my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
		if fingerprint == PersonalGPGKey:
			tc = 'RoyalBlue2'
		elif signed_or_not() or get_validity() == 'Valid  ':
			tc = 'light green'
		elif get_validity() == 'Valid(M)':
			tc = 'orange'
		else:
			tc = 'white'
		# Show image
		pic_icon_path = photo_path + '/pic' + fingerprint[-8:] + '.jpg'
		nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
		if os.path.isfile(pic_icon_path):
			keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
		else:
			keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
		
		Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = keyiconimage)
		Labelpublicimg.place(relx=0.14, rely=0.27, anchor="center")
		
		short_alias = self.lookup_Alias_absolut(fingerprint)
									
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text=short_alias, text_color=tc, fg_color="black", font=my_font)
		Label1.place(relx=0.23, rely=0.18, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
		Label2 = ctk.CTkLabel(my_Frame, text="    Key ID: " + key_email[:60], text_color=tc, fg_color="black", font=my_font)	
		Label2.place(relx=0.23, rely=0.25, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Fingerprint: " + fingerprint, text_color=tc, fg_color="black", font=my_font)	
		Label3.place(relx=0.08, rely=0.44, anchor="w")
		
		if fingerprint != PersonalGPGKey:
			check_sigs_on_key()
			if signed_or_not():
				Label4 = ctk.CTkLabel(my_Frame, text="    Status: Signed", text_color="light green", fg_color="black", font=my_font)
				Label4.place(relx=0.23, rely=0.30, anchor="w")
				sign_Button = ctk.CTkButton(my_Frame, text=" Sign Key ", text_color="white", fg_color="dark green", width=80, border_width=2, border_color="white", height=30, font=my_font, command=partial(self.sign_specific_key_on_keychain, fingerprint))
				sign_Button.place(relx=0.86, rely=0.2, anchor="center")
			else:
				Label4 = ctk.CTkLabel(my_Frame, text="    Status: Not signed", text_color="white", fg_color="black", font=my_font)
				Label4.place(relx=0.23, rely=0.30, anchor="w")
				if fingerprint != PersonalGPGKey:
					sign_Button = ctk.CTkButton(my_Frame, text=" Sign Key ", text_color="white", fg_color="dark green", width=80, border_width=2, border_color="white", height=30, font=my_font, command=partial(self.sign_specific_key_on_keychain, fingerprint))
					sign_Button.place(relx=0.86, rely=0.2, anchor="center")
			if get_validity() == 'Valid  ':
				if not signed_or_not():
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Valid", text_color="orange", fg_color="black", font=my_font)
				else:
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Valid", text_color="light green", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			elif get_validity() == 'Valid(M)':
				if not signed_or_not():
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Marginally valid", text_color="orange", fg_color="black", font=my_font)
				else:
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Marginally valid", text_color="light green", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			else:
				Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Unknown", text_color="white", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)	
			
			if expires != 0.0:
				now = time.time()
				# Add one week early warning
				now += 604800
				if now > expires:
					Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="red2", fg_color="black", font=my_font)
					Label6.place(relx=0.23, rely=0.37, anchor="w")
				else:
					Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="white", fg_color="black", font=my_font)
					Label6.place(relx=0.23, rely=0.37, anchor="w")
			else:
				Label6 = ctk.CTkLabel(my_Frame, text="    Expires: Never", text_color="white", fg_color="black", font=my_font)
				Label6.place(relx=0.23, rely=0.37, anchor="w")
			
			Label66 = ctk.CTkLabel(my_Frame, text="Created: " + datetime.utcfromtimestamp(key_date).strftime('%Y-%m-%d'), text_color="white", fg_color="black", font=my_font)
			Label66.place(relx=0.46, rely=0.37, anchor="w")
					
			Label7 = ctk.CTkLabel(my_Frame, text="Select trust level in owner*:", font=my_font, text_color="white", fg_color="black")
			Label7.place(relx=0.49, rely=0.6, anchor="e")
			my_font = ctk.CTkFont(family="Arial", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
			if self.valid_for_photo(fingerprint):
				photoButton = ctk.CTkButton(my_Frame, text="Change photo", text_color="white", fg_color="red4", border_width=2, border_color="white", width=80, height=25, font=my_font, command=partial(self.changePhotoID2, fingerprint))
				photoButton.place(relx=0.14, rely=0.51, anchor="center")
			copy_button = ctk.CTkButton(my_Frame, text="Copy fingerprint to clipboard", text_color="white", fg_color="red4", border_width=2, border_color="white", height=25, font=my_font, command=partial(self.copy2clip, fingerprint))
			copy_button.place(relx=0.5, rely=0.51, anchor="center")
			# If the key has a private key and is not used with ID and it doesnt have subkeys, then give option to set/update with 2 years expiration date
			if self.valid_for_expiration(fingerprint):
				exp_Button = ctk.CTkButton(my_Frame, text="Set to expire in 2 years", text_color="white", fg_color="red4", width=80, border_width=2, border_color="white", height=25, font=my_font, command=set_expire)
				exp_Button.place(relx=0.92, rely=0.51, anchor="e")
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)		
			clicked = StringVar()
			trust_level = 'TRUST_UNDEFINED'
			trust_level = get_trust_for_key(fingerprint)
			clicked.set(trust_level)
			
			drop = OptionMenu(my_Frame, clicked, *List_Levels)
			drop.place(relx=0.5, rely=0.6, anchor="w")
			
			if short_alias == 'None':
				if key_alias != '':
					short_alias = key_alias
				else:
					short_alias = fingerprint[-5:]	
			aliasLabel = ctk.CTkLabel(my_Frame, text="Alias (for key):", text_color="white", fg_color="black", font=my_font)
			aliasLabel.place(relx=0.49, rely=0.67, anchor="e")
				
			users_alias_name_var = ctk.StringVar(value=short_alias)
			users_alias_name_var.trace('w', limitSizeAliasname)
							
			aliasEntry = ctk.CTkEntry(my_Frame, placeholder_text=short_alias, textvariable=users_alias_name_var, width=250, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			aliasEntry.place(relx=0.5, rely=0.67, anchor="w")
			key_record = 'edit'
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
			
			his_Button = ctk.CTkButton(my_Frame, text="Key history", text_color="black", fg_color="LightBlue3", width=80, border_width=2, border_color="white", height=30, font=my_font, command=partial(self.get_key_records, fingerprint))
			his_Button.place(relx=0.86, rely=0.13, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
							
			goButton = ctk.CTkButton(my_Frame, text="Save!", text_color="white", font=my_font, fg_color='dark green', border_width=2, border_color="white", command=do_edit_public_Key)
			goButton.place(relx=0.5, rely=0.77, anchor="center")
		
		if key_record2 == 'group':
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=partial(self.show_group_keys, the_group))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
		else:	
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=partial(self.get_GnuPGKeys_compact, ['_none__']))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.92, rely=0.95, anchor="center")
	
	def show_key_signatures(self, fingerprint):
		global PersonalGPGKey, key_record
		global path_to_USB_secure
		global filepathdestinationfolder
		global key_email, key_alias, trust_level_before, expires
		
		List_Levels = ['TRUST_UNDEFINED', 'TRUST_NEVER', 'TRUST_MARGINAL', 'TRUST_FULLY', 'TRUST_ULTIMATE']
		
		key_email = '<Undefined>'
		trust_level_before  = 'Missing'
		expires = 0.0
		
		more_info_text = "Signatures:\n\nSignatures are used to build trust in individual keys. As an assigned \"owners trust\" is not key specific (instead it's a trust you have in a persons ability to sign keys) it is best assigned to a personal \"ID-key\" or a corporate HR- masterkey etc (a key that is only used for signing and some special high security communications offline).\n\nNote that if someone signs another persons key, it ONLY state \"This key is from him/her\"."
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1034, 
		height=220,  #484
		orientation="vertical",
		border_width=2,
		border_color="green",
		fg_color="black"
		)
		
		bottom_Frame.place(relx=0.5, rely=0.69, anchor="center")
		bottom_Frame.focus_set()
		bottom_Frame.focus_force()
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
			
		def get_trust_for_key(key_fingerprint):
			global key_email, key_alias
			trust_level_never = False
			trust_level_marginal = False
			trust_level_Full = False
			trust_level_Ultimate = False
			
			recommended_trust_level = 'TRUST_UNDEFINED'
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			public_keys = gpg.list_keys()
			
			# Loop through and get the trust for the key
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == key_fingerprint:
						key_email_list = i['uids']
						key_email = key_email_list[0]
						key_alias_list = key_email.split("<")
						key_alias = key_alias_list[0][:42]
						# Get the trust level
						if i['ownertrust'] == 'n':
							trust_level_never = True
						if i['ownertrust'] == 'm':
							trust_level_marginal = True
						if i['ownertrust'] == 'f':
							trust_level_Full = True
						if i['ownertrust'] == 'u':
							trust_level_Ultimate = True
							
				my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
												
				if trust_level_Ultimate:
					recommended_trust_level = 'TRUST_ULTIMATE'
				elif trust_level_Full:
					recommended_trust_level = 'TRUST_FULLY'
				elif trust_level_marginal:
					recommended_trust_level = 'TRUST_MARGINAL'
				elif trust_level_never:
					recommended_trust_level = 'TRUST_NEVER'
				else:
					recommended_trust_level = 'TRUST_UNDEFINED'
			return recommended_trust_level
		
		def get_validity():
			global expires
			validity_text = ' '
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			public_keys = gpg.list_keys()
			for i in public_keys:
				if i['fingerprint'] == fingerprint:
					str_expires = i['expires']
					if str_expires == '':
						expires = 0.0
					else:
						expires = float(str_expires)
					# Get the validity level
					if i['trust'] == 'm':
						validity_text = 'Valid(M)'
					if i['trust'] == 'f' or i['trust'] == 'u':
						validity_text = 'Valid  '
			return validity_text
			
		def signed_or_not():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			private_keys = []
			List_fingerprints = []
			public_keys = gpg.list_keys(sigs=True)
			private_keys = gpg.list_keys(True)
			
			# List the private keys that can be used for signing			
			for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					tmp = nkey['fingerprint']
					List_fingerprints.append(tmp[-16:])
				
			if List_fingerprints:	 
				for i in private_keys:
					if i['subkeys']: 
						listoflistindict = i['subkeys']
						dictofsubkeyinfo = i['subkey_info']
						for ii in listoflistindict:
							if ii:
								subkinfo = ii[0]
								tmmp = subkinfo[-16:]
								capacity = dictofsubkeyinfo[subkinfo]['cap']
								if capacity == 's':
									List_fingerprints.append(tmmp)
					for i2 in public_keys:
						# Check if the public key is signed by any private key on local keychain
						if i2['fingerprint'] == fingerprint:
							if i2['sigs']: 
								tuple_of_sigs_in_key = i2['sigs']
								for ii in tuple_of_sigs_in_key:
									if ii:
										if ii[0] in List_fingerprints:
											return True
					return False
			return False
			
		def check_sigs_on_key():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			
			# Get sigs for the selected key
			public_keys = gpg.list_keys(sigs=True)
			temp_list = []
			# Loop through and display sigs
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == fingerprint and i['sigs']: 
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
				
						tuple_of_sigs_in_key = i['sigs']

						for ii in tuple_of_sigs_in_key:
							if ii:
								if ii[0] != i['keyid']:
									keyID = ii[0]
									
									user_id = ii[1]
									signature_class = ii[2]
									if keyID not in temp_list:
										Label = ctk.CTkLabel(bottom_Frame, text= ' ' + keyID + '   ' +  user_id, text_color="white", fg_color="black", font=my_font)
										Label.pack(padx=10, pady=1, side= TOP, anchor="w")
									
									temp_list.append(keyID)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if fingerprint == PersonalGPGKey:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="RoyalBlue2",
			fg_color="black"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
		else:
			card_Frame = ctk.CTkFrame(my_Frame,
			width=1048, 
			height=250,
			corner_radius=14,
			border_width=2,
			border_color="DeepPink4",
			fg_color="black"
			)
			card_Frame.place(relx=0.5, rely=0.29, anchor="center")
		
		trust_level = get_trust_for_key(fingerprint)
		
		# Get key photo (if any) and save as file
		photo_path = "/home/user1/secure/keys"
		command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + fingerprint
		os.system(command)
		
		curr_Alias = ''
		if self.lookup_Alias_absolut(fingerprint) != "None":
			curr_Alias = self.lookup_Alias(fingerprint)
					
		my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
		if fingerprint == PersonalGPGKey:
			tc = 'RoyalBlue2'
		elif signed_or_not() or get_validity() == 'Valid  ':
			tc = 'light green'
		elif get_validity() == 'Valid(M)':
			tc = 'orange'
		else:
			tc = 'white'
		# Show image
		pic_icon_path = photo_path + '/pic' + fingerprint[-8:] + '.jpg'
		nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
		if os.path.isfile(pic_icon_path):
			keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
		else:
			keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signatures", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.04, anchor="center")
		
		Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = keyiconimage)
		Labelpublicimg.place(relx=0.14, rely=0.27, anchor="center")
		
		short_alias = self.lookup_Alias_absolut(fingerprint)
									
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text=short_alias, text_color=tc, fg_color="black", font=my_font)
		Label1.place(relx=0.23, rely=0.18, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
		Label2 = ctk.CTkLabel(my_Frame, text="    Key ID: " + key_email[:60], text_color=tc, fg_color="black", font=my_font)	
		Label2.place(relx=0.23, rely=0.25, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Fingerprint: " + fingerprint, text_color=tc, fg_color="black", font=my_font)	
		Label3.place(relx=0.08, rely=0.44, anchor="w")
		
		if fingerprint != PersonalGPGKey:
			check_sigs_on_key()
			if signed_or_not():
				Label4 = ctk.CTkLabel(my_Frame, text="    Status: Signed", text_color="light green", fg_color="black", font=my_font)
				Label4.place(relx=0.23, rely=0.30, anchor="w")
			else:
				Label4 = ctk.CTkLabel(my_Frame, text="    Status: Not signed", text_color="white", fg_color="black", font=my_font)
				Label4.place(relx=0.23, rely=0.30, anchor="w")
			if get_validity() == 'Valid  ':
				if not signed_or_not():
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Valid", text_color="orange", fg_color="black", font=my_font)
				else:
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Valid", text_color="light green", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			elif get_validity() == 'Valid(M)':
				if not signed_or_not():
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Marginally valid", text_color="orange", fg_color="black", font=my_font)
				else:
					Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Marginally valid", text_color="light green", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			else:
				Label5 = ctk.CTkLabel(my_Frame, text="Key validity: Unknown", text_color="white", fg_color="black", font=my_font)
				Label5.place(relx=0.46, rely=0.30, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)	
			
			if expires != 0.0:
				now = time.time()
				# Add one week early warning
				now += 604800
				if now > expires:
					Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="red2", fg_color="black", font=my_font)
					Label6.place(relx=0.23, rely=0.37, anchor="w")
				else:
					Label6 = ctk.CTkLabel(my_Frame, text="    Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="white", fg_color="black", font=my_font)
					Label6.place(relx=0.23, rely=0.37, anchor="w")
			else:
				Label6 = ctk.CTkLabel(my_Frame, text="    Expires: Never", text_color="white", fg_color="black", font=my_font)
				Label6.place(relx=0.23, rely=0.37, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)		
			clicked = StringVar()
			trust_level = 'TRUST_UNDEFINED'
			trust_level = get_trust_for_key(fingerprint)
			clicked.set(trust_level)
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=partial(self.edit_public_key, fingerprint))
		backButton.place(relx=0.5, rely=0.94, anchor="center")
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.94, rely=0.95, anchor="center")
	
	def do_remove_member(self, fingerprint):
		global do_sort
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		temp_file_ = pathtogroupsfile + ".tmp"
		if os.path.isfile(pathtogroupsfile):
			with open(pathtogroupsfile, 'r') as inp, open(temp_file_, 'w') as out:
				writer = csv.writer(out)
				for row in csv.reader(inp):
					if not (row[1] == do_sort and row[2] == fingerprint):
						writer.writerow(row)	
			shutil.copy(temp_file_, pathtogroupsfile)
			if os.path.isfile(temp_file_):
				os.remove(temp_file_)
		self.display_group_details(do_sort)
			
	def show_group_keys(self, group):
		global PersonalGPGKey, key_record
		global path_to_USB_secure
		global filepathdestinationfolder
		global key_email, key_alias, trust_level_before, expires
		global key_record, key_record2, do_sort
		
		do_sort = group
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		key_email = '<Undefined>'
		trust_level_before  = 'Missing'
		expires = 0.0
		
		more_info_text = "Trust levels:\nSet Trust level based on how responsible the keys owner is when signing other keys.\n\nExample.\nIf you set trust level on \"Key 1\" to \"TRUST_FULLY\" it means that when you import \"Key 2\" and that key is signed by \"Key 1\", the web-of-trust will tell you that the KEY is \"Valid\".\n\nNOTE: Setting the Trust level has nothing to do with if the key itself belongs to the right person or not.\nThe level \"TRUST_FULLY\" is only for those key owners that you KNOW always first check a persons PASSPORT or PHOTO ID etc before signing ANYTHING. It could be the HR-department for your company or the President of the chess club etc.\nIf you fully or marginally trust the owner you also need to sign the key after you import it (for the Web-of-trust calculations to work)!"
		
		def limitSizeAliasname(*args):
			value = users_alias_name_var.get()
			if len(value) > 42: users_alias_name_var.set(value[:42])
		
		def get_validity(fingerprint):
			global expires
			validity_text = ' '
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			public_keys = gpg.list_keys()
			for i in public_keys:
				if i['fingerprint'] == fingerprint:
					str_expires = i['expires']
					if str_expires == '':
						expires = 0.0
					else:
						expires = float(str_expires)
					# Get the validity level
					if i['trust'] == 'm':
						validity_text = 'Valid(M)'
					if i['trust'] == 'f' or i['trust'] == 'u':
						validity_text = 'Valid  '
			return validity_text
		
		def get_trust_for_key(key_fingerprint):
			global key_email, key_alias
			trust_level_never = False
			trust_level_marginal = False
			trust_level_Full = False
			trust_level_Ultimate = False
			
			recommended_trust_level = 'TRUST_UNDEFINED'
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			public_keys = gpg.list_keys()
			
			# Loop through and get the trust for the key
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == key_fingerprint:
						key_email_list = i['uids']
						key_email = key_email_list[0]
						key_alias_list = key_email.split("<")
						key_alias = key_alias_list[0][:42]
						# Get the trust level
						if i['ownertrust'] == 'n':
							trust_level_never = True
						if i['ownertrust'] == 'm':
							trust_level_marginal = True
						if i['ownertrust'] == 'f':
							trust_level_Full = True
						if i['ownertrust'] == 'u':
							trust_level_Ultimate = True
							
				my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
												
				if trust_level_Ultimate:
					recommended_trust_level = 'TRUST_ULTIMATE'
				elif trust_level_Full:
					recommended_trust_level = 'TRUST_FULLY'
				elif trust_level_marginal:
					recommended_trust_level = 'TRUST_MARGINAL'
				elif trust_level_never:
					recommended_trust_level = 'TRUST_NEVER'
				else:
					recommended_trust_level = 'TRUST_UNDEFINED'
			return recommended_trust_level
				
		def signed_or_not(fingerprint):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			private_keys = []
			List_fingerprints = []
			public_keys = gpg.list_keys(sigs=True)
			private_keys = gpg.list_keys(True)
			
			# List the private keys that can be used for signing			
			for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					tmp = nkey['fingerprint']
					List_fingerprints.append(tmp[-16:])
				
			if List_fingerprints:	 
				for i in private_keys:
					if i['subkeys']: 
						listoflistindict = i['subkeys']
						dictofsubkeyinfo = i['subkey_info']
						for ii in listoflistindict:
							if ii:
								subkinfo = ii[0]
								tmmp = subkinfo[-16:]
								capacity = dictofsubkeyinfo[subkinfo]['cap']
								if capacity == 's':
									List_fingerprints.append(tmmp)
					for i2 in public_keys:
						# Check if the public key is signed by any private key on local keychain
						if i2['fingerprint'] == fingerprint:
							if i2['sigs']: 
								tuple_of_sigs_in_key = i2['sigs']
								for ii in tuple_of_sigs_in_key:
									if ii:
										if ii[0] in List_fingerprints:
											return True
					return False
			return False
		
		# remove any entry in group file where the fingerprint is not as a public key on the local keychain (it could have been removed..) 
		self.cleanupgroups()
			
		my_Frame = ctk.CTkScrollableFrame(self, 
		width=1176, 
		height=634,
		border_width=2,
		fg_color="black",
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		all_members = self.get_members(group)

		if all_members:
			count_i = 0
			for i2 in all_members:
				if count_i == 0:
					my_font = ctk.CTkFont(family="Arial", size=24, weight='bold', slant="roman", underline=True, overstrike=False)
		
					gLabel = ctk.CTkLabel(my_Frame, text="Group - " + group, text_color="white", fg_color="black", font=my_font)
					gLabel.pack(pady=10, anchor="center")
					count_i += 1
					
				card_Frame = ctk.CTkFrame(my_Frame,
				width=1048, 
				height=250,
				corner_radius=14,
				border_width=2,
				border_color="DeepPink4",
				fg_color="black"
				)
				card_Frame.pack(padx=70, pady=15, anchor="w")
		
				trust_level = get_trust_for_key(i2)
				
				# Get key photo (if any) and save as file
				photo_path = "/home/user1/secure/keys"
				command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + i2
				os.system(command)
				
				curr_Alias = ''
				if self.lookup_Alias_absolut(i2) != "None":
					curr_Alias = self.lookup_Alias(i2)
							
				my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
				
				if signed_or_not(i2) or get_validity(i2) == 'Valid  ':
					tc = 'light green'
				elif get_validity(i2) == 'Valid(M)':
					tc = 'orange'
				else:
					tc = 'white'
				# Show image
				pic_icon_path = photo_path + '/pic' + i2[-8:] + '.jpg'
				nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
				if os.path.isfile(pic_icon_path):
					keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
				else:
					keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
				
				key_record2 = 'group'
				do_sort = group				
				Button1 = ctk.CTkButton(card_Frame, text="", image = keyiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=149, height=164, font=my_font, command=partial(self.edit_public_key, i2))
				Button1.place(relx=0.09, rely=0.5, anchor="center")
			
				my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)	
				remove_Button = ctk.CTkButton(card_Frame, text="Remove from group", text_color="white", fg_color="red2", border_width=2, border_color="white", height=30, font=my_font, command=partial(self.do_remove_member, i2))
				remove_Button.place(relx=0.88, rely=0.1, anchor="center")
			
				short_alias = self.lookup_Alias_absolut(i2)
											
				my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
				
				Label1 = ctk.CTkLabel(card_Frame, text=short_alias, text_color=tc, fg_color="black", font=my_font)
				Label1.place(relx=0.21, rely=0.08, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)	
				Label2 = ctk.CTkLabel(card_Frame, text="Key ID: " + key_email[:60], text_color=tc, fg_color="black", font=my_font)	
				Label2.place(relx=0.21, rely=0.35, anchor="w")
				
				Label3 = ctk.CTkLabel(card_Frame, text="Fingerprint: " + i2, text_color=tc, fg_color="black", font=my_font)	
				Label3.place(relx=0.03, rely=0.92, anchor="w")
				
				if signed_or_not(i2):
					Label4 = ctk.CTkLabel(card_Frame, text="Status: Signed", text_color="light green", fg_color="black", font=my_font)
					Label4.place(relx=0.21, rely=0.52, anchor="w")
				else:
					Label4 = ctk.CTkLabel(card_Frame, text="Status: Not signed", text_color="white", fg_color="black", font=my_font)
					Label4.place(relx=0.21, rely=0.52, anchor="w")
				if get_validity(i2) == 'Valid  ':
					if not signed_or_not(i2):
						Label5 = ctk.CTkLabel(card_Frame, text="Key validity: Valid", text_color="orange", fg_color="black", font=my_font)
					else:
						Label5 = ctk.CTkLabel(card_Frame, text="Key validity: Valid", text_color="light green", fg_color="black", font=my_font)
					Label5.place(relx=0.46, rely=0.52, anchor="w")
				elif get_validity(i2) == 'Valid(M)':
					if not signed_or_not(i2):
						Label5 = ctk.CTkLabel(card_Frame, text="Key validity: Marginally valid", text_color="orange", fg_color="black", font=my_font)
					else:
						Label5 = ctk.CTkLabel(card_Frame, text="Key validity: Marginally valid", text_color="light green", fg_color="black", font=my_font)
					Label5.place(relx=0.46, rely=0.52, anchor="w")
				else:
					Label5 = ctk.CTkLabel(card_Frame, text="Key validity: Unknown", text_color="white", fg_color="black", font=my_font)
					Label5.place(relx=0.46, rely=0.52, anchor="w")
				
				if trust_level == 'TRUST_ULTIMATE':
					tc = 'RoyalBlue2'
				elif trust_level == 'TRUST_FULLY':
					tc = 'light green'
				elif trust_level == 'TRUST_MARGINAL':
					tc = 'orange'
				elif trust_level == 'TRUST_NEVER':
					tc = 'red'
				else:
					tc = 'white'
				
				ownerLabel = ctk.CTkLabel(card_Frame, text="Owner trust: " + trust_level, text_color=tc, fg_color="black", font=my_font)
				ownerLabel.place(relx=0.46, rely=0.69, anchor="w")
						
				my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)	
				
				if expires != 0.0:
					now = time.time()
					# Add one week early warning
					now += 604800
					if now > expires:
						Label6 = ctk.CTkLabel(card_Frame, text="Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="red2", fg_color="black", font=my_font)
						Label6.place(relx=0.21, rely=0.69, anchor="w")
					else:
						Label6 = ctk.CTkLabel(card_Frame, text="Expires: " + datetime.utcfromtimestamp(expires).strftime('%Y-%m-%d'), text_color="white", fg_color="black", font=my_font)
						Label6.place(relx=0.21, rely=0.69, anchor="w")
				else:
					Label6 = ctk.CTkLabel(card_Frame, text="Expires: Never", text_color="white", fg_color="black", font=my_font)
					Label6.place(relx=0.21, rely=0.69, anchor="w")

		my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
	
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=partial(self.display_group_details, group))
		backButton.pack(padx=500, pady=15, anchor="w")
	
	def easy_show_ID_keys(self):
		global PersonalGPGKey
		global path_to_USB_secure
		global filepathdestinationfolder
		global DigitalID_button_color, SecUSB_button_color
			
		my_Frame = ctk.CTkScrollableFrame(self, 
		width=1176, 
		height=634,
		border_width=2,
		fg_color="black",
		border_color="red"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1174, 634))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		all_IDs = self.get_IDs()

		if all_IDs:
			count_i = 0
			for i2 in all_IDs:
				if count_i == 0:
					my_font = ctk.CTkFont(family="Arial", size=32, weight='bold', slant="roman", underline=True, overstrike=False)
		
					gLabel = ctk.CTkLabel(my_Frame, text="ID's:", text_color="white", fg_color="black", font=my_font)
					gLabel.pack(pady=10, anchor="center")
					count_i += 1
					
				card_Frame = ctk.CTkFrame(my_Frame,
				width=1048, 
				height=250,
				corner_radius=14,
				border_width=2,
				border_color="DeepPink4",
				fg_color="black"
				)
				card_Frame.pack(padx=70, pady=15, anchor="w")
		
				# Get key photo (if any) and save as file
				photo_path = "/home/user1/secure/keys"
				command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + i2
				os.system(command)
				
				curr_Alias = ''
				if self.lookup_Alias_absolut(i2) != "None":
					curr_Alias = self.lookup_Alias(i2)
							
				my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
				
				# Show image
				pic_icon_path = photo_path + '/pic' + i2[-8:] + '.jpg'
				nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
				if os.path.isfile(pic_icon_path):
					keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
				else:
					keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
				
				Button1 = ctk.CTkButton(card_Frame, text="", image = keyiconimage, anchor='center', text_color="white", fg_color="brown", border_width=2, border_color="white", width=149, height=164, font=my_font, command=partial(self.showID, i2))
				Button1.place(relx=0.12, rely=0.5, anchor="center")
				
				short_alias = self.lookup_Alias_absolut(i2)
				
				my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)	
				Label2 = ctk.CTkLabel(card_Frame, text=short_alias, text_color="white", fg_color="black", font=my_font)	
				Label2.place(relx=0.24, rely=0.15, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)	
				signFile_Button = ctk.CTkButton(card_Frame, text="Sign File", text_color="white", fg_color=DigitalID_button_color, border_width=3, corner_radius=30, border_color="white", width=320, height=90, font=my_font, command=partial(self.easy_sign_document_with_ID, i2))
				signFile_Button.place(relx=0.4, rely=0.52, anchor="center")
				signQR_Button = ctk.CTkButton(card_Frame, text="Sign QR", text_color="white", fg_color=DigitalID_button_color, border_width=3, corner_radius=30, border_color="white", width=320, height=90, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, i2))
				signQR_Button.place(relx=0.76, rely=0.52, anchor="center")

		my_font = ctk.CTkFont(family="Arial", size=30, weight="normal", slant="roman", underline=False, overstrike=False)
	
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=DigitalID_button_color, border_width=2, corner_radius=12, border_color="white", width=120, height=50, font=my_font, command=self.create_meny)
		backButton.pack(padx=500, pady=15, anchor="w")
	
	def easy_show_Bitcoin_wallets(self):
		global PersonalGPGKey
		global path_to_USB_secure
		global filepathdestinationfolder
		global Boltcard_button_color
			
		my_Frame = ctk.CTkScrollableFrame(self, 
		width=1176, 
		height=634,
		border_width=2,
		fg_color="black",
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1174, 634))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		all_wallets = self.get_Bitcoin_wallets()
		
		pathtoWalletimage = str(filepathdestinationfolder) + "/images/btc_wallet_icon.jpg"
		
		if all_wallets:
			count_i = 0
			for i2 in all_wallets:
				if count_i == 0:
					my_font = ctk.CTkFont(family="Arial", size=32, weight='bold', slant="roman", underline=True, overstrike=False)
		
					gLabel = ctk.CTkLabel(my_Frame, text="Bitcoin wallets:", text_color="white", fg_color="black", font=my_font)
					gLabel.pack(pady=10, anchor="center")
					count_i += 1
					
				card_Frame = ctk.CTkFrame(my_Frame,
				width=1048, 
				height=250,
				corner_radius=14,
				border_width=2,
				border_color=Boltcard_button_color,
				fg_color="black"
				)
				card_Frame.pack(padx=70, pady=15, anchor="w")
		
				# Get wallet photo (if any) and save as file
				w_icon_path = filepathdestinationfolder + "/secure/wallets/" + i2 + ".jpg"
				
				if os.path.isfile(w_icon_path):
					pathtoWalletIconimage = w_icon_path
					walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletIconimage), dark_image=Image.open(pathtoWalletIconimage), size=(145, 160))
				else:
					walleticonimage = ctk.CTkImage(light_image=Image.open(pathtoWalletimage), dark_image=Image.open(pathtoWalletimage), size=(145, 160))
				
				Button1 = ctk.CTkButton(card_Frame, text="", image = walleticonimage, anchor='center', text_color="white", fg_color=Boltcard_button_color, border_width=2, border_color="white", width=149, height=164, font=my_font, command=partial(self.showBitcoinwallet, i2))
				Button1.place(relx=0.12, rely=0.5, anchor="center")
				
				my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)	
				Label2 = ctk.CTkLabel(card_Frame, text=i2, text_color="white", fg_color="black", font=my_font)	
				Label2.place(relx=0.26, rely=0.15, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)	
				signFile_Button = ctk.CTkButton(card_Frame, text="Sign Transaction", text_color="white", fg_color=Boltcard_button_color, border_width=4, corner_radius=8, border_color="white", width=400, height=90, font=my_font, command=partial(self.easy_readQRfromCamera, i2))
				signFile_Button.place(relx=0.26, rely=0.52, anchor="w")
				
				history_Button = ctk.CTkButton(card_Frame, text="History", text_color="white", fg_color=Boltcard_button_color, border_width=4, corner_radius=8, border_color="white", width=240, height=90, font=my_font, command=partial(self.easy_showWalletStatement, i2))
				history_Button.place(relx=0.7, rely=0.52, anchor="w")
				
		my_font = ctk.CTkFont(family="Arial", size=30, weight="normal", slant="roman", underline=False, overstrike=False)
	
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=Boltcard_button_color, border_width=4, border_color="white", width=120, height=50, font=my_font, command=self.create_meny)
		backButton.pack(padx=500, pady=15, anchor="w")
			
	def easy_show_private_keys(self):
		global PersonalGPGKey
		global path_to_USB_secure
		global filepathdestinationfolder
		global GPG_button_color
			
		my_Frame = ctk.CTkScrollableFrame(self, 
		width=1176, 
		height=634,
		border_width=2,
		fg_color="black",
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1174, 634))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		private_keys = gpg.list_keys(True)
				
		List_fingerprints = []
		
		# Dont display the private key that is only intended for Offline device encryption/decryption
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
		
		all_IDs = self.get_IDs()

		if List_fingerprints:
			count_i = 0
			for i2 in List_fingerprints:
				if i2 not in all_IDs:	
					if count_i == 0:
						my_font = ctk.CTkFont(family="Arial", size=32, weight='bold', slant="roman", underline=True, overstrike=False)
			
						gLabel = ctk.CTkLabel(my_Frame, text="Private key's:", text_color="white", fg_color="black", font=my_font)
						gLabel.pack(pady=10, anchor="center")
						count_i += 1
						
					card_Frame = ctk.CTkFrame(my_Frame,
					width=1048, 
					height=250,
					corner_radius=14,
					border_width=2,
					border_color=GPG_button_color,
					fg_color="black"
					)
					card_Frame.pack(padx=70, pady=15, anchor="w")
			
					# Get key photo (if any) and save as file
					photo_path = "/home/user1/secure/keys"
					command= 'gpg --list-options show-photos --photo-viewer "cat > ' + photo_path + '/pic%k.%t" --list-keys ' + i2
					os.system(command)
					
					curr_Alias = ''
					if self.lookup_Alias_absolut(i2) != "None":
						curr_Alias = self.lookup_Alias(i2)
								
					my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
					
					# Show image
					pic_icon_path = photo_path + '/pic' + i2[-8:] + '.jpg'
					nopic_icon_path = filepathdestinationfolder + "/Pictures/male_anon_ID.JPG"
					if os.path.isfile(pic_icon_path):
						keyiconimage = ctk.CTkImage(light_image=Image.open(pic_icon_path), dark_image=Image.open(pic_icon_path), size=(145, 160))
					else:
						keyiconimage = ctk.CTkImage(light_image=Image.open(nopic_icon_path), dark_image=Image.open(nopic_icon_path), size=(145, 160))
					
					Button1 = ctk.CTkButton(card_Frame, text="", image = keyiconimage, anchor='center', text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=149, height=164, font=my_font, command=partial(self.edit_public_key, i2))
					Button1.place(relx=0.12, rely=0.5, anchor="center")
					
					short_alias = self.lookup_Alias_absolut(i2)
					
					my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)	
					Label2 = ctk.CTkLabel(card_Frame, text=short_alias, text_color="white", fg_color="black", font=my_font)	
					Label2.place(relx=0.24, rely=0.15, anchor="w")
					
					my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=False, overstrike=False)	
					signFile_Button = ctk.CTkButton(card_Frame, text="Sign File", text_color="white", fg_color=GPG_button_color, border_width=3, corner_radius=8, border_color="white", width=320, height=90, font=my_font, command=partial(self.easy_sign_document_with_ID, i2))
					signFile_Button.place(relx=0.4, rely=0.52, anchor="center")
					signQR_Button = ctk.CTkButton(card_Frame, text="Sign QR", text_color="white", fg_color=GPG_button_color, border_width=3, corner_radius=8, border_color="white", width=320, height=90, font=my_font, command=partial(self.easy_readQRfromCameraToSign_ID, i2))
					signQR_Button.place(relx=0.76, rely=0.52, anchor="center")

		my_font = ctk.CTkFont(family="Arial", size=30, weight="normal", slant="roman", underline=False, overstrike=False)
	
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=GPG_button_color, border_width=2, corner_radius=5, border_color="white", width=120, height=50, font=my_font, command=self.create_meny)
		backButton.pack(padx=500, pady=15, anchor="w")
			
	def valid_for_photo(self, fingerprint):
		global filepathdestinationfolder
		avail = False
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		private_keys = []
		private_keys = gpg.list_keys(True)
		
		# List the private keys and match the public fingerprint			
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				if i['fingerprint'] == fingerprint:
					avail = True
		return avail
		
	def valid_for_expiration(self, fingerprint):
		global filepathdestinationfolder
		avail = False
		sub_avail = False
		full_path_IDs_file = filepathdestinationfolder + "/secure/ID/IDs.csv"
		
		def used_as_ID():
			as_ID = False
			with open(full_path_IDs_file, 'r') as source:
				csvreader = csv.reader(source)
				for row in csv.reader(source):
					if row[1] == fingerprint:
						as_ID = True
			return as_ID
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		private_keys = []
		private_keys = gpg.list_keys(True)
		
		# List the private keys and match the public fingerprint			
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				if i['fingerprint'] == fingerprint and not used_as_ID():
					avail = True
					if i['subkeys']: 
						listoflistindict = i['subkeys']
						for ii in listoflistindict:
							if ii:
								sub_avail = True
		if avail and not sub_avail:
			return True
		return False
		
	def get_GnuPGKeys_compact(self, search_key):
		global PersonalGPGKey
		global GPG_button_color, expires, key_record2, diceFunction, use_filter
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		data = []
		Sorted_data = []
		
		key_record2 = ''
		diceFunction = ''
		expires = 0.0
		clicked = StringVar()
		clicked2 = StringVar()
		
		my_Frame = ctk.CTkFrame(self,
		width=1200, 
		height=650,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		top_Frame = ctk.CTkScrollableFrame(my_Frame,
		width=1176, 
		height=390,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 386))
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=0, y=0, anchor="nw")
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1176, 
		height=232,
		border_width=2,
		orientation="vertical",
		border_color="green",
		fg_color="gray1"
		)
		
		bottom_Frame._scrollbar.configure(height=0)
		
		pathtobackg = "/home/user1/images/black.png"
		backgg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 230))
		Label_backgg = ctk.CTkLabel(bottom_Frame, image=backgg, text = "")
		Label_backgg.place(x=2, y=2)
		bottom_Frame.place(x=0, y=400, anchor="nw")
		
		group_Frame = ctk.CTkScrollableFrame(my_Frame,
		width=350, 
		height=230,
		orientation="vertical",
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		group_Frame._scrollbar.configure(height=0)
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 396))
		Label_backg = ctk.CTkLabel(group_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		group_Frame.place(x=810, y=152, anchor="nw")
		
		# remove any entry in group file where the fingerprint is not as a public key on the local keychain (it could have been removed..) 
		self.cleanupgroups()
		
		more_info_text = "Viewing and editing keys:\n\nClick on \"+\"-sign to view or edit details.\n\nTo view, add or edit groups click on \"Show groups\".\n\nThe key used for encrypting/decrypting the Offline device itself will show in blue color.\n\n\nTo instead ADD or DELETE keys then use menu \"GPG\" -> \"Add/remove key\"."
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
		
		def search_data():
			global use_filter
			
			key = searchEntry.get()
			use_filter = key
			found_fingerprints = []
			for sublist in Sorted_data:
				if key in sublist[0] or key in sublist[3] or key in sublist[4] or key in sublist[5]:
						found_fingerprints.append(sublist[5])
			if found_fingerprints:
				self.get_GnuPGKeys_compact(found_fingerprints)
				return
			else:
				self.get_GnuPGKeys_compact(['_empty__'])
				return
			
		def get_trust(i):
			global expires
			trust_text = ' '
			str_expires = i['expires']
			if str_expires == '':
				expires = 0.0
			else:
				expires = float(str_expires)
			# Get the trust level
			if i['ownertrust'] == 'm':
				trust_text = 'Trust(M)'
			if i['ownertrust'] == 'f' or i['ownertrust'] == 'u':
				trust_text = 'Trusted'
			return trust_text
		
		def limitSearchField(*args):
			value = Search_var.get()
			if len(value) > 42: Search_var.set(value[:42])
			
		def get_expires(fingerprint):
			expires = 0.0
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			public_keys = gpg.list_keys()
			
			for i in public_keys:
				if i['fingerprint'] == fingerprint:
					str_expires = i['expires']
					if str_expires == '':
						expires = 0.0
					else:
						expires = float(str_expires)
			return expires
			
		def get_validity(i):
			validity_text = ' '
			# Get the validity level
			if i['trust'] == 'm':
				validity_text = 'Valid(M)'
			if i['trust'] == 'f' or i['trust'] == 'u':
				validity_text = 'Valid  '
			return validity_text
		
		def display_groups():
			my_font = ctk.CTkFont(family="Arial", size=20, weight='bold', slant="roman", underline=False, overstrike=False)
			if os.path.isfile(pathtogroupsfile):
				list_of_groups = []
				try:
					with open(pathtogroupsfile, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines[1] not in list_of_groups:	
								list_of_groups.append(lines[1])
				except FileNotFoundError:
					print("Could not open groups file")
				my_font = ctk.CTkFont(family="Arial", size=18, weight='bold', slant="roman", underline=False, overstrike=False)
		
				if list_of_groups:
					tt_count = 0
					for groupname in list_of_groups:
						m_list = self.get_members(groupname)
						size_group = len(m_list)
						if tt_count == 0:
							my_font = ctk.CTkFont(family="Arial", size=20, weight='bold', slant="roman", underline=True, overstrike=False)
							fLabel = ctk.CTkLabel(group_Frame, text="Groups:", text_color="white", fg_color="black", font=my_font)
							fLabel.pack(padx=10, pady=1, side= TOP, anchor="w")
							tt_count+=1
						my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
						group1_Button = ctk.CTkButton(group_Frame, text=groupname + ' (' + str(size_group) + ')', text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=340, height=30, font=my_font, command=partial(self.display_group_details, groupname))
						group1_Button.pack(padx=15, pady=1, anchor="w")
				else:
					emptyLabel = ctk.CTkLabel(group_Frame, text="No Groups yet...", text_color="light green", fg_color="black", font=my_font)
					emptyLabel.pack(padx=25, pady=20, anchor="nw")
					new_Button = ctk.CTkButton(group_Frame, text="Create a group", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=self.create_group)
					new_Button.pack(padx=70, pady=45, side= TOP, anchor="w")
			else:
				emptyLabel = ctk.CTkLabel(group_Frame, text="No Groups yet...", text_color="light green", fg_color="black", font=my_font)
				emptyLabel.pack(padx=25, pady=20, anchor="nw")
				new_Button = ctk.CTkButton(group_Frame, text="Create a group", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=self.create_group)
				new_Button.pack(padx=70, pady=45, side= TOP, anchor="w")
		
		pixel = tk.PhotoImage(width=1, height=1)
		
		self.cleanupaliases()
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight='bold', underline=True, overstrike=False)
	
		Label1 = ctk.CTkLabel(my_Frame, text="All public keys:", text_color="light green", fg_color="black", font=my_font)
		Label1.place(relx=0.3, rely=0.04, anchor="center")
		
		gLabel = ctk.CTkLabel(my_Frame, text="All private keys:", text_color="light green", fg_color="black", font=my_font)
		gLabel.place(relx=0.3, rely=0.64, anchor="center")
		
		my_font = ctk.CTkFont(family="Helvetica", size=14, slant="roman", weight='bold', underline=False, overstrike=False)
	
		verLabel = ctk.CTkLabel(my_Frame, text="GnuPG version: 2.2.27", text_color="white", fg_color="black", font=my_font)
		verLabel.place(relx=0.97, rely=0.03, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		group_Button = ctk.CTkButton(my_Frame, text="Show groups", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=partial(self.display_group_details, '_no_selected_'))
		group_Button.place(relx=0.81, rely=0.06, anchor="nw")
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		public_keys = []
		private_keys = []
		List_fingerprints = []
		List_fingerprints_full = []
		data_line = []
		public_keys = gpg.list_keys(sigs=True)
		private_keys = gpg.list_keys(True)
		mapp = private_keys.key_map
		
		# List the private keys that can be used for signing			
		for nkey in private_keys:
			List_fingerprints_full.append(nkey['fingerprint'])
			if nkey['fingerprint'] != PersonalGPGKey:
				tmp = nkey['fingerprint']
				List_fingerprints.append(tmp[-16:])
			
		if List_fingerprints:	 
			for i in private_keys:
				if i['subkeys']: 
					listoflistindict = i['subkeys']
					dictofsubkeyinfo = i['subkey_info']
					for ii in listoflistindict:
						if ii:
							subkinfo = ii[0]
							tmmp = subkinfo[-16:]
							capacity = dictofsubkeyinfo[subkinfo]['cap']
							if capacity == 's':
								List_fingerprints.append(tmmp)
		
		# Make data list of list with all data from the public keys (to sort later)
		if public_keys:
			count_pub = 0
			
			# Create a list of lists to do sorting on (fingerprint/alias, private key available, signature, validity, ownertrust)
			for i2 in public_keys:
				d_fingerprint = ''
				d_pri_available = False
				d_sig_available = False
				d_validity = ''
				d_ownertrust = ''
				d_true_fingerprint = i2['fingerprint']
				
				# Get the alias if any
				if self.lookup_Alias_absolut(i2['fingerprint']) != "None":
					d_fingerprint = self.lookup_Alias(i2['fingerprint'])
				else:
					key_email_list = i2['uids']
					key_email = key_email_list[0]
					key_alias_list = key_email.split("<")
					d_fingerprint = key_alias_list[1][:42]
					if d_fingerprint == '' or d_fingerprint == ' ':
						d_fingerprint = i2['fingerprint']
						
				# Check if the private key is available for the public key
				if i2['fingerprint'] in List_fingerprints_full:
					d_pri_available = True
					
				# Check if the public key is signed by any private key on local keychain
				if i2['sigs']: 
					tuple_of_sigs_in_key = i2['sigs']
					for ii in tuple_of_sigs_in_key:
						if ii:
							if ii[0] in List_fingerprints:
								d_sig_available = True
				
				# Check if the key is valid
				d_validity = get_validity(i2)
				
				# Check the ownertrust
				d_ownertrust = get_trust(i2)
				
				data_line = [d_fingerprint, d_pri_available, d_sig_available, d_validity, d_ownertrust, d_true_fingerprint]
				data.append(data_line)
				
			data = sorted(data, key = operator.itemgetter(0))
			
			# Append the final data in correct order
			
			# Don't add the Offline device key
			# Add all keys that has a private key on the local keychain (but are not the Offline device Key)
			for i in data:
				if i[1] == True and i[5] != PersonalGPGKey and i[4] == 'Trusted':
					Sorted_data.append(i)
			for i in data:
				if i[1] == True and i[5] != PersonalGPGKey and i[4] == 'Trust(M)':
					Sorted_data.append(i)	
			for i in data:
				if i[1] == True and i[5] != PersonalGPGKey and i[4] == ' ':
					Sorted_data.append(i)		
			# Add all keys without private key that are signed and has SOME owners trust and then those without ownerstrust	
			for i in data:
				if i[1] == False and i[2] == True and i[4] == 'Trusted':
					Sorted_data.append(i)
			for i in data:
				if i[1] == False and i[2] == True and i[4] == 'Trust(M)':
					Sorted_data.append(i)
			for i in data:
				if i[1] == False and i[2] == True and i[4] == ' ':
					Sorted_data.append(i)
			# Add all keys that doesn't have a private key and are NOT signed and based on validity 	
			for i in data:
				if i[1] == False and i[2] == False and i[3] == 'Valid  ':
					Sorted_data.append(i)
			for i in data:
				if i[1] == False and i[2] == False and i[3] == 'Valid(M)':
					Sorted_data.append(i)
			for i in data:
				if i[1] == False and i[2] == False and i[3] == ' ':
					Sorted_data.append(i)	
				
			Search_var = ctk.StringVar(value='')
			Search_var.trace('w', limitSearchField)
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
							
			searchEntry = ctk.CTkEntry(my_Frame, placeholder_text='', textvariable=Search_var, width=200, height=30, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			searchEntry.place(relx=0.85, rely=0.16, anchor="ne")
			
			search_Button = ctk.CTkButton(my_Frame, text="Search", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", height=30, font=my_font, command=search_data)
			search_Button.place(relx=0.86, rely=0.16, anchor="nw")
					
		if Sorted_data and search_key[0] == '_none__':
			count_pub = 0
			for i2 in Sorted_data:
				sz = 6
				it_has_expired = False
				expires = get_expires(i2[5])
				if expires != 0.0:
					now = time.time()
					# Give a week of warning
					now += 604800
					if now > expires:
						it_has_expired = True
						
				CD = tk.Frame(top_Frame, width=650, borderwidth=0, bg="black")
				my_font = ctk.CTkFont(family="Consolas", size=22, slant="roman", underline=False, overstrike=False)
				if count_pub == 0:
					fLabel = ctk.CTkLabel(top_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
					fLabel.pack(padx=55, pady=1, side= TOP, anchor="w")	
				if i2[1] == True: # It is a part of a private key on the local keychain
					if it_has_expired:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Owner ' + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					else:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Owner ' + ' ' + i2[4], text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
				elif i2[2] == True: # It is signed
					if it_has_expired:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Signed' + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					else:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Signed' + ' ' + i2[4], text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
				elif i2[3] == 'Valid  ' or i2[3] == 'Valid(M)': # It is not signed but valid based on calculations
					if it_has_expired:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[3] + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					else:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[3] + ' ' + i2[4], text_color="gold2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
				else:
					if it_has_expired:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					else:
						link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[4], text_color="white", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
				link_Button.pack(padx=2, side=tk.LEFT, fill=tk.BOTH, anchor="w")
				CD.pack(fill=tk.BOTH, expand=tk.TRUE)
				count_pub+=1
		elif Sorted_data:
			my_font = ctk.CTkFont(family="Consolas", size=22, weight='bold', slant="roman", underline=True, overstrike=False)
			
			fLabel = ctk.CTkLabel(top_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
			fLabel.pack(padx=55, pady=1, side= TOP, anchor="w")	
			fLabel2 = ctk.CTkLabel(top_Frame, text="Search results for \"" + use_filter + "\":", text_color="light green", fg_color="black", font=my_font)
			fLabel2.pack(padx=20, pady=1, side= TOP, anchor="w")
			my_font = ctk.CTkFont(family="Consolas", size=18, weight='bold', slant="roman", underline=False, overstrike=False)
			clear_search_Button = ctk.CTkButton(my_Frame, text="Clear search", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", height=25, font=my_font, command=partial(self.get_GnuPGKeys_compact, ['_none__']))
			clear_search_Button.place(relx=0.65, rely=0.07, anchor="e")
			for i2 in Sorted_data:
				sz = 6
				it_has_expired = False
				expires = get_expires(i2[5])
				if expires != 0.0:
					now = time.time()
					# Give a week of warning
					now += 604800
					if now > expires:
						it_has_expired = True
						
				CD = tk.Frame(top_Frame, width=650, borderwidth=0, bg="black")
				
				my_font = ctk.CTkFont(family="Consolas", size=22, weight='normal', slant="roman", underline=False, overstrike=False)
				if i2[5] in search_key:
					if i2[1] == True: # It is a part of a private key on the local keychain
						if it_has_expired:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Owner ' + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
						else:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Owner ' + ' ' + i2[4], text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					elif i2[2] == True: # It is signed
						if it_has_expired:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Signed' + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
						else:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + 'Signed' + ' ' + i2[4], text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					elif i2[3] == 'Valid  ' or i2[3] == 'Valid(M)': # It is not signed but valid based on calculations
						if it_has_expired:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[3] + ' ' + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
						else:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[3] + ' ' + i2[4], text_color="gold2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					else:
						if it_has_expired:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[4], text_color="red2", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
						else:
							link_Button = ctk.CTkButton(CD, text=" " + f"{i2[0]:43}" + i2[4], text_color="white", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.edit_public_key, i2[5]))
					link_Button.pack(padx=2, side=tk.LEFT, fill=tk.BOTH, anchor="w")
					CD.pack(fill=tk.BOTH, expand=tk.TRUE)
					count_pub+=1
		else:
			Label = ctk.CTkLabel(top_Frame, text='<empty>', text_color="light green", fg_color="black", font=my_font)
			Label.pack(padx=55, pady=50, side= TOP, anchor="w")
			
		if private_keys:
			count = 0
			for i in private_keys:
				sz = 6
				EF = tk.Frame(bottom_Frame, width=650, borderwidth=0, bg="black")
				my_font = ctk.CTkFont(family="Consolas", size=22, slant="roman", underline=False, overstrike=False)
				if count == 0:
					fLabel = ctk.CTkLabel(bottom_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
					fLabel.pack(padx=25, pady=1, side= TOP, anchor="w")	
				if self.lookup_Alias_absolut(i['fingerprint']) != "None":	
					if i['fingerprint'] != PersonalGPGKey:
						link_Button = ctk.CTkButton(EF, text=" " + self.lookup_Alias(i['fingerprint']), text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.get_GnuPGKeys, i['fingerprint']))
						link_Button.pack(padx=2, side=tk.LEFT, fill=tk.BOTH, anchor="w")
					EF.pack(fill=tk.BOTH, expand=tk.TRUE)
					count +=1
				else:
					if i['fingerprint'] != PersonalGPGKey:
						link_Button = ctk.CTkButton(EF, text=" " + str(i['uids']), text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.get_GnuPGKeys, i['fingerprint']))
						link_Button.pack(padx=2, side=tk.LEFT, fill=tk.BOTH, anchor="w")
					EF.pack(fill=tk.BOTH, expand=tk.TRUE)
					count +=1
						
				if i['subkeys']: 
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			
					listoflistindict = i['subkeys']
					dictofsubkeyinfo = i['subkey_info']

					for ii in listoflistindict:
						if ii:
							subkinfo = ii[0]
							keytype = dictofsubkeyinfo[subkinfo]['type']
							capacity = dictofsubkeyinfo[subkinfo]['cap']
							token = dictofsubkeyinfo[subkinfo]['token']

							datecrea = int(dictofsubkeyinfo[subkinfo]['date'])		
							dt_datecrea = datetime.fromtimestamp(datecrea)
							dt_datecrea_form = dt_datecrea.strftime('%Y-%m-%d')
							
							dateexp = int(dictofsubkeyinfo[subkinfo]['expires'])
							dt_dateexp = datetime.fromtimestamp(dateexp)
							dt_dateexp_form  = dt_dateexp.strftime('%Y-%m-%d')
							
							if capacity == 's':
								capacity = 'Signing'
							if capacity == 'e':
								capacity = 'Encryption'
							if capacity == 'a':
								capacity = 'Authenticate'
							if token != '#': 
								if token == '>': 
									Label = ctk.CTkLabel(bottom_Frame, text= '         ' + capacity + '. Expires: ' + dt_dateexp_form + ' (Moved to a Yubikey).', text_color="light green", fg_color="black", font=my_font)
									Label.pack(padx=45, pady=1, side= TOP, anchor="w")
								else:
									Label = ctk.CTkLabel(bottom_Frame, text= '         ' + capacity + '. Expires: ' + dt_dateexp_form + ' (' + keytype + ').', text_color="light green", fg_color="black", font=my_font)
									Label.pack(padx=45, pady=1, side= TOP, anchor="w")
		else:
			my_font = ctk.CTkFont(family="Arial", size=18, weight='bold', slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(bottom_Frame, text='<empty>', text_color="light green", fg_color="black", font=my_font)
			Label.pack(padx=5, pady=2, side= TOP, anchor="w") 
		my_font = ctk.CTkFont(family="Arial", size=18, weight='bold', slant="roman", underline=False, overstrike=False)
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.93, rely=0.95, anchor="center")
		display_groups()
	
	def cleanupaliases(self):
		pathtofile = "/home/user1/secure/Alias.csv"
		temp_file_ = "/home/user1/secure/tempAlias.csv"
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		public_keys = []
		private_keys = []
		public_keys = gpg.list_keys()
		private_keys = gpg.list_keys()
		total_keys = []
		
		for i in public_keys:
			total_keys.append(i['fingerprint'])
				
		for i2 in private_keys:
			total_keys.append(i2['fingerprint'])
					
		if os.path.isfile(pathtofile):
			with open(pathtofile, 'r') as inp, open(temp_file_, 'w') as out:
				writer = csv.writer(out)
				for row in csv.reader(inp):
					if row[0] in total_keys:
						writer.writerow(row)	
			shutil.copy(temp_file_, pathtofile)
		
			if os.path.isfile(temp_file_):
				os.remove(temp_file_)
				
	def cleanupgroups(self):
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		temp_file_ = "/home/user1/secure/tempgroups.csv"
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		public_keys = []
		
		public_keys = gpg.list_keys()
		
		List_fingerprints = []

		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i2['fingerprint'])
					
		if os.path.isfile(pathtogroupsfile):
			with open(pathtogroupsfile, 'r') as inp, open(temp_file_, 'w') as out:
				writer = csv.writer(out)
				for row in csv.reader(inp):
					if row[2] in List_fingerprints:
						writer.writerow(row)	
			shutil.copy(temp_file_, pathtogroupsfile)
		
			if os.path.isfile(temp_file_):
				os.remove(temp_file_)
	
	def get_members(self, group):
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		list_of_members = []
		try:
			with open(pathtogroupsfile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines[1] == group:	
						list_of_members.append(lines[2])
		except FileNotFoundError:
			print("Could not open groups file")
		return list_of_members
	
	def get_IDs(self):
		pathtoIDfile = "/home/user1/secure/ID/IDs.csv"
		list_of_IDs = []
		try:
			with open(pathtoIDfile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						list_of_IDs.append(lines[1])
		except FileNotFoundError:
			print("Could not open IDs file")
		return list_of_IDs
	
	def get_Bitcoin_wallets(self):
		pathtowalletfile = "/home/user1/secure/wallets/bitconwallets.csv"
		list_of_wallets = []
		try:
			with open(pathtowalletfile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines:	
						list_of_wallets.append(lines[0])
		except FileNotFoundError:
			print("Could not open Bitcoin wallets file")
		return list_of_wallets
			
	def check_if_already_in_group(self, group, fingerprint):
		members_in_group = self.get_members(group)
		for i in members_in_group:
			if i == fingerprint:
				return True
		return False
		
	def check_if_group(self, groupname):
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		try:
			with open(pathtogroupsfile, 'r') as file:
				csvfile = csv.reader(file)
				for lines in csvfile:
					if lines[1] == groupname:
						return True
		except FileNotFoundError:
			print("Could not open groups file")
		return False
			
	def display_group_details(self, group):
		global PersonalGPGKey
		global GPG_button_color
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		clicked = StringVar()
		clicked2 = StringVar()
		
		my_Frame = ctk.CTkFrame(self,
		width=1200, 
		height=650,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		top_Frame = ctk.CTkFrame(my_Frame,
		width=1176, 
		height=400,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 396))
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=0, y=0, anchor="nw")
		
		pub_Frame = ctk.CTkScrollableFrame(my_Frame,
		width=350, 
		height=230,
		orientation="vertical",
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		pub_Frame._scrollbar.configure(height=0)
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 396))
		Label_backg = ctk.CTkLabel(pub_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		pub_Frame.place(x=810, y=152, anchor="nw")
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1176, 
		height=232,
		border_width=2,
		orientation="vertical",
		border_color="green",
		fg_color="gray1"
		)
		
		bottom_Frame._scrollbar.configure(height=0)
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backgg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 230))
		Label_backgg = ctk.CTkLabel(bottom_Frame, image=backgg, text = "")
		Label_backgg.place(x=2, y=2)
		bottom_Frame.place(x=0, y=400, anchor="nw")
		
		# remove any entry in group file where the fingerprint is not as a public key on the local keychain (it could have been removed..) 
		self.cleanupgroups()
		
		more_info_text = "General:\nIn Group view you can't delete or create any new keys, only manage your groups.\n\nImporting group:\nIf you plan to import key(s) into a Group you first need to create the group and after that use \"GPG\" - \"Import\". Inform the sender to (if needed) first create a temporary group without so-and-so keys and after that export it and send it to you. That way, you can import it without replacing your existing keys or merging any signatures etc.\n\nExporting group of keys:\nAsk the receiver what keys they would want excluded from the group. Create a temporary group with the remaing keys, the keys that the receiver actually wants/needs, and export that to a file and send (or encrypted it first and then send it)."
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
		
		def display_pub():
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			
			public_keys = gpg.list_keys()
			
			if public_keys:
				count_pub = 0
				for i2 in public_keys:
					my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
					alias_or_fingerprint = self.lookup_Alias_absolut(i2['fingerprint'])
					if i2['fingerprint'] != PersonalGPGKey:
						if count_pub == 0:
							my_font = ctk.CTkFont(family="Arial", size=20, weight='bold', slant="roman", underline=True, overstrike=False)
							fLabel = ctk.CTkLabel(pub_Frame, text="All public keys:", text_color="white", fg_color="black", font=my_font)
							fLabel.pack(padx=10, pady=1, side= TOP, anchor="w")
						if alias_or_fingerprint != "None":
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
							Label = ctk.CTkLabel(pub_Frame, text=alias_or_fingerprint, text_color="white", fg_color="black", font=my_font)
							Label.pack(padx=10, pady=1, side= TOP, anchor="w")
							count_pub+=1
						else:
							key_email_list = i2['uids']
							key_email = key_email_list[0]
							key_alias_list = key_email.split("<")
							key_alias = key_alias_list[1][:42]
							if key_alias == '' or key_alias == ' ':
								key_alias = i2['fingerprint']
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
							Label = ctk.CTkLabel(pub_Frame, text=key_alias, text_color="white", fg_color="black", font=my_font)
							Label.pack(padx=10, pady=1, side= TOP, anchor="w")
							count_pub+=1
			else:
				Label = ctk.CTkLabel(pub_Frame, text='<empty>', text_color="white", fg_color="black", font=my_font)
				Label.pack(padx=55, pady=50, side= TOP, anchor="w")
					
		def display_groups():
			if os.path.isfile(pathtogroupsfile):
				list_of_groups = []
				try:
					with open(pathtogroupsfile, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines[1] not in list_of_groups:	
								list_of_groups.append(lines[1])
				except FileNotFoundError:
					print("Could not open groups file")
				
				if list_of_groups:
					xpadding = 50
					ypadding = 70
					g_count = 0
					for groupname in list_of_groups:
						m_list = self.get_members(groupname)
						size_group = len(m_list)
						group1_Button = ctk.CTkButton(top_Frame, text=groupname + ' (' + str(size_group) + ')', text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=340, height=30, font=my_font, command=partial(self.display_group_details, groupname))
						group1_Button.place(x=xpadding, y=ypadding, anchor="w")
						ypadding += 45
						g_count += 1
						if g_count == 7:
							xpadding += 400
							ypadding = 70
				else:
					emptyLabel = ctk.CTkLabel(top_Frame, text="It looks a little bit empty here...", text_color="light green", fg_color="black", font=my_font)
					emptyLabel.place(x=60, y=100, anchor="w")
			else:
				emptyLabel = ctk.CTkLabel(top_Frame, text="It looks a little bit empty here...", text_color="light green", fg_color="black", font=my_font)
				emptyLabel.place(x=60, y=100, anchor="w")
				
		def copy_group():
			available_groups = []
			# Get number of groups to check if max already there
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in available_groups:	
							available_groups.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
			
			number_of_groups = len(available_groups)
			if number_of_groups < 14:
				# Ask for name for copy (optional).
				USER_INP = simpledialog.askstring(title="Optional!", prompt="Enter name for the new group.")
				input_size = len(USER_INP)
				if input_size > 24:
					USER_INP = USER_INP[:24]
				elif USER_INP == '':
					USER_INP = group[:17] + ' (copy)'
					
				if USER_INP not in available_groups:
					temp_file_ = pathtogroupsfile + ".tmp"
					
					with open(pathtogroupsfile, 'r') as inp, open(temp_file_, 'w') as out:
						writer = csv.writer(out)
						for row in csv.reader(inp):
							writer.writerow(row)
							# If the line is the group to copy also make a new entry for the groups copy
							if row[1] == group:
								group_copy_line = ['none', USER_INP, row[2]]
								writer.writerow(group_copy_line)	
					shutil.copy(temp_file_, pathtogroupsfile)
					if os.path.isfile(temp_file_):
						os.remove(temp_file_)
					self.display_group_details('none_selected')
				else:
					tk.messagebox.showinfo('Information', 'The group already exists."')
					self.create_group()
					self.display_group_details(new_group_name)
			else:
				tk.messagebox.showinfo('Information', 'Not possible to add any more groups.')
				self.display_group_details('none_selected')
				
		def delete_group():
			answer = messagebox.askquestion('WARNING!', 'WARNING! You are about to delete a Group! Are you SURE you want to delete it?')
			
			if answer == 'yes':
				temp_file_ = pathtogroupsfile + ".tmp"
				
				if os.path.isfile(pathtogroupsfile):
					with open(pathtogroupsfile, 'r') as inp, open(temp_file_, 'w') as out:
						writer = csv.writer(out)
						for row in csv.reader(inp):
							if row[1] != group:
								writer.writerow(row)	
					shutil.copy(temp_file_, pathtogroupsfile)
					if os.path.isfile(temp_file_):
						os.remove(temp_file_)
				self.display_group_details('_none_selected')
			else:
				self.display_group_details(group)
			
		def add_member():
			global PersonalGPGKey
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = []
			unAdded_public_keys = []
			
			all_members = []
			all_members = self.get_members(group)
			
			public_keys = gpg.list_keys()
			
			List_fingerprints = []

			public_fingerprints_and_aliases = []
			
			for i2 in public_keys:
				if i2['fingerprint'] != PersonalGPGKey:
					List_fingerprints.append(i2['fingerprint'])
					
			for i3 in List_fingerprints:
				if i3 not in all_members:
					unAdded_public_keys.append(i3)
			
			b_Frame = ctk.CTkFrame(my_Frame, 
			width=1176, 
			height=246,
			border_width=2,
			border_color="green",
			fg_color="gray1"
			)
			
			pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
			backgg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 236))
			Label_backgg = ctk.CTkLabel(b_Frame, image=backgg, text = "")
			Label_backgg.place(x=2, y=2)
			b_Frame.place(x=0, y=400, anchor="nw")
			
			my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
	
			Labela = ctk.CTkLabel(b_Frame, text="Select key to add: " + group, text_color="light green", fg_color="black", font=my_font)
			Labela.place(x=25, y=25, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			Label1 = ctk.CTkLabel(b_Frame, text="Add key to group:", text_color="light green", fg_color="black", font=my_font)
			Label1.place(relx=0.25, rely=0.56, anchor="e")
			
			if not unAdded_public_keys:	
				tk.messagebox.showinfo('Information', 'There is no public keys left to add to this group.')
				self.display_group_details(group)
			else:
				public_fingerprints_and_aliases = self.get_Aliases(unAdded_public_keys)
				clicked.set(public_fingerprints_and_aliases[0])
			
				drop = OptionMenu(b_Frame, clicked, *public_fingerprints_and_aliases)
				drop.config(width=45)
				drop.place(relx=0.27, rely=0.55, anchor="w")
			
				create_new_Button = ctk.CTkButton(b_Frame, text="Add to group", text_color="white", fg_color="dark green", border_width=2, border_color="white", height=30, font=my_font, command=do_add_member)
				create_new_Button.place(relx=0.59, rely=0.69, anchor="center")
		
		def do_add_member():
			decoded_fingerprint = self.lookup_fingerprint(clicked.get())
			new_entry = ['none', group, decoded_fingerprint]
			if os.path.isfile(pathtogroupsfile):
				with open(pathtogroupsfile, 'a') as result:
					csvwriter = csv.writer(result)
					csvwriter.writerow(new_entry)
			self.display_group_details(group)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		public_keys = []
		
		public_keys = gpg.list_keys()
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight='bold', slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(top_Frame, text="Show groups", text_color="light green", fg_color="black", font=my_font)
		Label1.place(x=25, y=25, anchor="w")
		
		gLabel = ctk.CTkLabel(my_Frame, text="Group - " + group, text_color="light green", fg_color="black", font=my_font)
		gLabel.place(relx=0.02, rely=0.63, anchor="nw")
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		compact_Button = ctk.CTkButton(top_Frame, text="Show all keys", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=partial(self.get_GnuPGKeys_compact, ['_none__']))
		compact_Button.place(relx=0.81, rely=0.05, anchor="nw")
		new_Button = ctk.CTkButton(top_Frame, text="New group", text_color="white", fg_color="dark green", border_width=2, border_color="white", width=200, height=30, font=my_font, command=self.create_group)
		new_Button.place(relx=0.81, rely=0.14, anchor="nw")
		
		all_members = self.get_members(group)
		if all_members:
			count_i = 0
			for i2 in all_members:
				if self.lookup_Alias_absolut(i2) != "None" and count_i == 0:
					fLabel = ctk.CTkLabel(bottom_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
					fLabel.pack(padx=25, pady=1, anchor="w")
					Label = ctk.CTkLabel(bottom_Frame, text=self.lookup_Alias(i2), text_color="light green", fg_color="black", font=my_font)
					Label.pack(padx=25, pady=1, anchor="w") #side= TOP, 
					count_i += 1
				elif self.lookup_Alias_absolut(i2) != "None" and count_i > 0:
					Label = ctk.CTkLabel(bottom_Frame, text=self.lookup_Alias(i2), text_color="light green", fg_color="black", font=my_font)
					Label.pack(padx=25, pady=1, anchor="w")
					count_i += 1
				elif count_i == 0:
					fLabel = ctk.CTkLabel(bottom_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
					fLabel.pack(padx=25, pady=1, anchor="w")
					Label = ctk.CTkLabel(bottom_Frame, text=i2, text_color="light green", fg_color="black", font=my_font)
					Label.pack(padx=25, pady=1, anchor="w") #side= TOP, 
					count_i += 1
				else:
					Label = ctk.CTkLabel(bottom_Frame, text=i2, text_color="light green", fg_color="black", font=my_font)
					Label.pack(padx=25, pady=1, anchor="w")
					count_i += 1
			add_Button = ctk.CTkButton(my_Frame, text="Add member", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=add_member)
			add_Button.place(relx=0.8, rely=0.64, anchor="nw")
			del_Button = ctk.CTkButton(my_Frame, text="Show details", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=partial(self.show_group_keys, group))
			del_Button.place(relx=0.8, rely=0.7, anchor="nw")
			copy_group_Button = ctk.CTkButton(my_Frame, text="Copy group", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=copy_group)
			copy_group_Button.place(relx=0.8, rely=0.76, anchor="nw")
			del_group_Button = ctk.CTkButton(my_Frame, text="Delete group", text_color="white", fg_color="red", border_width=2, border_color="white", width=200, height=30, font=my_font, command=delete_group)
			del_group_Button.place(relx=0.8, rely=0.82, anchor="nw")
		my_font = ctk.CTkFont(family="Arial", size=18, weight='bold', slant="roman", underline=False, overstrike=False)
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.93, rely=0.95, anchor="center")
		display_groups()
		display_pub()
		
	def create_group(self):
		global GPG_button_color
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		ex_name = "<My group>"	
		
		clicked = StringVar()
		group_name_var = ctk.StringVar(value=ex_name)
		
		def limitSizeGroupname(*args):
			value = group_name_var.get()
			if len(value) > 24: group_name_var.set(value[:24])
		
		def do_create_group():
			# Make a list of the existing groups and check that the new doesnt exist already
			available_groups = []
			new_group_member = clicked.get()
			new_group_name = groupNameEntry.get()
			
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in available_groups:	
							available_groups.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
			
			decoded_fingerprint = self.lookup_fingerprint(new_group_member)
			
			new_entry = ['none', new_group_name, decoded_fingerprint]
			
			number_of_groups = len(available_groups)
			if number_of_groups < 14:
				if new_group_name not in available_groups:
					if os.path.isfile(pathtogroupsfile):
						with open(pathtogroupsfile, 'a') as result:
							csvwriter = csv.writer(result)
							csvwriter.writerow(new_entry)
					else:
						f = open(pathtogroupsfile, 'w')
						writer = csv.writer(f)
						writer.writerow(new_entry)
						f.close()
				else:
					tk.messagebox.showinfo('Information', 'The group already exists."')
					self.create_group()
				self.display_group_details(new_group_name)
			else:
				tk.messagebox.showinfo('Information', 'Not possible to add any more groups.')
				self.display_group_details('none_selected')
		my_Frame = ctk.CTkFrame(self,
		width=1200, 
		height=650,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		top_Frame = ctk.CTkFrame(my_Frame,
		width=1176, 
		height=400,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 396))
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=0, y=0, anchor="nw")
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1176, 
		height=232,
		border_width=2,
		orientation="vertical",
		border_color="green",
		fg_color="gray1"
		)
		
		bottom_Frame._scrollbar.configure(height=0)
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backgg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 230))
		Label_backgg = ctk.CTkLabel(bottom_Frame, image=backgg, text = "")
		Label_backgg.place(x=2, y=2)
		bottom_Frame.place(x=0, y=400, anchor="nw")
		
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=2, y=2, anchor="nw")
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
	
		Label1 = ctk.CTkLabel(top_Frame, text="Groups:", text_color="light green", fg_color="black", font=my_font)
		Label1.place(x=25, y=25, anchor="w")
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		public_keys = []
		
		public_keys = gpg.list_keys()
		
		List_fingerprints = []

		public_fingerprints_and_aliases = []
		
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i2['fingerprint'])
		
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No public keys."')
		else:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		nameLabel = ctk.CTkLabel(top_Frame, text="New group name:", text_color="light green", fg_color="black", font=my_font)
		nameLabel.place(relx=0.26, rely=0.44, anchor="e")
		
		compact_Button = ctk.CTkButton(top_Frame, text="Show all keys", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=200, height=30, font=my_font, command=partial(self.get_GnuPGKeys_compact, ['_none__']))
		compact_Button.place(relx=0.81, rely=0.05, anchor="nw")
		
		group_name_var.trace('w', limitSizeGroupname)
	
		groupNameEntry = ctk.CTkEntry(top_Frame, placeholder_text=ex_name, textvariable=group_name_var, width=400, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		groupNameEntry.place(relx=0.27, rely=0.44, anchor="w")
		
		Label1 = ctk.CTkLabel(top_Frame, text="Add key to new group:", text_color="light green", fg_color="black", font=my_font)
		Label1.place(relx=0.26, rely=0.55, anchor="e")
		
		drop = OptionMenu(top_Frame, clicked, *public_fingerprints_and_aliases)
		drop.config(width=45)
		drop.place(relx=0.27, rely=0.55, anchor="w")
		
		create_new_Button = ctk.CTkButton(top_Frame, text="Create new group", text_color="white", fg_color="dark green", border_width=2, border_color="white", height=30, font=my_font, command=do_create_group)
		create_new_Button.place(relx=0.58, rely=0.65, anchor="center")
							
	def export_subkey(self):
		global clicked_privateKey
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		def do_export_subkey():
			global clicked_privateKey
			
			clicked_privateKey = str(clicked.get())

			result = tk.messagebox.askokcancel("Information", "Connect the USB-device and then click \"OK\".")
			if not result:
				self.import_or_export()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the directory where you want to save the subkey that will be exported from the local keychain.')
			if not result:
				self.import_or_export()
				return
			time.sleep(2)
			
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			command= 'gpg -a -o ' + outputdir + '/privatesubkey' + clicked_privateKey + '.gpg --export-secret-subkeys ' + clicked_privateKey
			os.system(command) 
			tk.messagebox.showinfo('Information', 'Key has been exported.')
			new_record = [clicked_privateKey, "Subkeys exported.", '']
			self.add_record(new_record)
			self.add_history("Subkeys exported: " + clicked_privateKey)
			self.create_GPGmeny()
		
		private_keys = []
		
		my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=True, overstrike=False)
		Label1 = ctk.CTkLabel(my_Frame, text="Export a subkey from a private key", text_color="light green", fg_color="black", font=my_font)
		Label1.place(relx=0.1, rely=0.1, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="The subkeys will be exported as a ASCII armored file.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.1, rely=0.18, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Select the subkey that you want to export.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.1, rely=0.27, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Then select where to place the file containing the exported subkey", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.1, rely=0.36, anchor="w")

		private_keys = gpg.list_keys(True)
				
		clicked = StringVar()
			
		List_fingerprints = []
		
		privatekeysavailable = False
			
		for i in private_keys:
			List_fingerprints.append(i['fingerprint'])
		if List_fingerprints:	
			privatekeysavailable = True
			
		list_subkeyfingerprints = []
		subavail = False
		if private_keys:	 
			for i in private_keys:
				if i['subkeys']: 
					listoflistindict = i['subkeys']
					dictofsubkeyinfo = i['subkey_info']
					for ii in listoflistindict:
						if ii:
							list_subkeyfingerprints.append(ii[2])
					clicked.set(list_subkeyfingerprints[0])
					subavail = True
		else:
			Label = ctk.CTkLabel(my_Frame, text='<empty>', text_color="light green", fg_color="black", font=my_font)
			Label.place(relx=0.1, rely=0.36, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if subavail:
			Label1 = ctk.CTkLabel(my_Frame, text="Select the subkey to export:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.4, rely=0.45, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *list_subkeyfingerprints)
			drop.place(relx=0.41, rely=0.45, anchor="w")
			
			Button2 = ctk.CTkButton(my_Frame, text="Export key", text_color="white", fg_color="dark green", font=my_font, border_width=2, border_color="white", command=do_export_subkey)
			Button2.place(relx=0.63, rely=0.54, anchor="w")
		else:
			Label1 = ctk.CTkLabel(my_Frame, text="There are no subkey's to export.", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.4, rely=0.47, anchor="e")
						
	def backupGPG_Keys(self):
		global filepathdestinationfolder
		global GPG_button_color
		global PersonalGPGKey
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
		def do_backupGPG_Keys():
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			my_Frame = ctk.CTkScrollableFrame(self, 
			width=1176, 
			height=634,
			border_width=2,
			border_color="green",
			fg_color="gray1"
			)
			
			pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_Frame.place(relx=0.5, rely=0.6, anchor="center")
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = gpg.list_keys() 
			List_fingerprints = []
			
			Label5 = ctk.CTkLabel(my_Frame, text="The following public key\'s has been copied from the local keychain and stored in the Secure archive:", text_color="light green", fg_color="black", font=my_font)
			Label5.pack(padx=5, pady=2, side= TOP, anchor="w")
		
			Label6 = ctk.CTkLabel(my_Frame, text="________________________________________________________________________________________________________", text_color="light green", fg_color="black", font=my_font)
			Label6.pack(padx=5, pady=2, side= TOP, anchor="w")
			ii = 0
			#the_y_value = 0.2
			for i in public_keys:
				keyfilename = 'publicKey' + i['fingerprint'] + '.gpg'
				List_fingerprints.append(i['fingerprint'])
				the_alias = self.lookup_Alias(i['fingerprint'])
				Label = ctk.CTkLabel(my_Frame, text=the_alias, text_color="light green", fg_color="black", font=my_font)
				Label.pack(padx=5, pady=2, side= TOP, anchor="w")
				
				ascii_armored_public_key = gpg.export_keys(List_fingerprints[ii]) 
				completeName = filepathdestinationfolder + '/secure/keys/' + keyfilename
				f2 = open(completeName, 'w')
				f2.write(ascii_armored_public_key)
				f2.close()
				ii = ii+1
			
			Label7 = ctk.CTkLabel(my_Frame, text="\nThe following private key has been copied from the local keychain and stored in the Secure archive:", text_color="light green", fg_color="black", font=my_font)
			Label7.pack(padx=8, pady=2, side= TOP, anchor="w")
		
			Label8 = ctk.CTkLabel(my_Frame, text="________________________________________________________________________________________________________", text_color="light green", fg_color="black", font=my_font)
			Label8.pack(padx=5, pady=2, side= TOP, anchor="w")
		
			alias_value = self.lookup_Alias(decoded_fingerprint)
			Label = ctk.CTkLabel(my_Frame, text=alias_value, text_color="light green", fg_color="black", font=my_font)
			Label.pack(padx=5, pady=2, side= TOP, anchor="w")
			
			ascii_armored_private_key = gpg.export_keys(decoded_fingerprint, True, expect_passphrase=False)
			completeName = filepathdestinationfolder + '/secure/keys/' + 'privateKey' + decoded_fingerprint + '.gpg' 
			f2 = open(completeName, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			new_record = [decoded_fingerprint, "Key backed up.", '']
			self.add_record(new_record)
			self.add_history("Made backup for private key: " + decoded_fingerprint)
			if decoded_fingerprint == PersonalGPGKey:
				shutil.copy(completeName, filepathdestinationfolder)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')	
		private_keys = gpg.list_keys(True)
					
		clicked = StringVar()
			
		List_fingerprints = []
		private_fingerprints_and_aliases = []
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
	
		if path_to_USB_secure == 'Secure USB folder is available' and List_fingerprints:					
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			
			clicked.set(private_fingerprints_and_aliases[0])
			
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
			
			Label1 = ctk.CTkLabel(my_Frame, text="Backup a private key and all public keys on the local keychain to the Secure archive.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.11, anchor="center")	
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			
			Label1 = ctk.CTkLabel(my_Frame, text="Each private key needs to be backup-up separately.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.24, anchor="center")	
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
			Label1 = ctk.CTkLabel(my_Frame, text="Select what private key to backup:", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.42, rely=0.48, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.43, rely=0.48, anchor="w")
			
			Button = ctk.CTkButton(my_Frame, text="Backup key\'s to the secure archive", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_backupGPG_Keys)
			Button.place(relx=0.52, rely=0.54, anchor="w")
		else:
			Button8 = ctk.CTkButton(self, text="There are no privat keys available. Backup not possible. Add a private key now?", text_color="white", fg_color="green", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.newGPGFull_Key, "none"))
			Button8.place(relx=0.5, rely=0.5, anchor="center")
	
	def import_or_export(self):
		global GPG_button_color
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)

		Button6 = ctk.CTkButton(my_Frame, text="Export public key(s) from local keychain to file", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=465, height=40, font=my_font, command=self.exportGPGmypublic)
		Button6.place(relx=0.25, rely=0.2, anchor="center")
		Button7 = ctk.CTkButton(my_Frame, text="Export private key from local keychain to file", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=465, height=40, font=my_font, command=self.exportGPG)
		Button7.place(relx=0.25, rely=0.37, anchor="center")
		Button8 = ctk.CTkButton(my_Frame, text="Export private subkey from local keychain to file", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=465, height=40, font=my_font, command=self.export_subkey)
		Button8.place(relx=0.25, rely=0.54, anchor="center")
		
		Button9 = ctk.CTkButton(my_Frame, text="Import key(s) from file", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=465, height=40, font=my_font, command=self.importGPG_Key)
		Button9.place(relx=0.75, rely=0.2, anchor="center")
		Button10 = ctk.CTkButton(my_Frame, text="Restore key(s) from the Secure archive, e.g\nafter recovering an account from backup", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=465, height=70, font=my_font, command=self.importGPG_Key_from_archive)
		Button10.place(relx=0.75, rely=0.37, anchor="center")
		
	def newGPGFull_Key(self, combinedValueBase58):
		global PersonalGPGKey
		global diceFunction
		global stored_name, stored_email
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		more_info_text = "Creating and deleting GPG-keys:\n\nFor creating a key to use with an ID state the name and add \"(ID)\" or similar to the end. This will help both you and the receiver of the public part of the key to identify what key from you should be assigned \"Owner trust\" (if any..). Under \"Email:\" for an ID-key use name@lastname or similar (you don't want to be stuck with a specific email associated to it.\n\nEvery time you create a new key there will automatically be a backup stored in the Secure archive (under \"\\keys\\\").\n\nFor new keys that you are NOT intending to use as an \"ID-key\" you can add a two year validity using the GPG-menu and then clicking the \"+\"-sign infront of the key. The validity can also be extended later."
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
			
		def limitSizePassphrase_text(*args):
			value = strong_password_var.get()
			if len(value) > 99: strong_password_var.set(value[:99])
		
		def limitSizeName_text(*args):
			value = stored_name_var.get()
			if len(value) > 28: stored_name_var.set(value[:28])	
		
		def limitSizeEmail_text(*args):
			value = stored_email_var.get()
			if len(value) > 50: stored_email_var.set(value[:50])
				
		def tPassphrase():
			if Secret_passphrase.cget('show') == '':
				Secret_passphrase.configure(show='*')
			else:
				Secret_passphrase.configure(show='')
		
		def show_progress(_value):
			my_font = ctk.CTkFont(family="Helvetica", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
			LLabel3 = ctk.CTkLabel(my_Frame, text="Progress......... " + _value + " %", text_color="white", fg_color="black", font=my_font)
			LLabel3.place(relx=0.5, rely=0.88, anchor="center")
		
		def do_newGPGFull():
			global stored_name, stored_email
			time.sleep(0.3)
			show_progress('7')
			self.update()
			time.sleep(1)
			show_progress('21')
			self.update()
			time.sleep(1.4)
			show_progress('37')
			self.update()
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			N_ = Real_name.get()
			E_ = Name_email.get()
			P_ = Secret_passphrase.get()

			stored_name = Real_name.get()
			stored_email = Name_email.get()
			
			if  len(N_) < 2 or len(E_) < 2 or len(P_) < 6:
				tk.messagebox.showinfo('Information', "Use min 2 characters in name fields and min six in password field!")
				self.newGPGFull_Key(combinedValueBase58)
			else:
				if checkbox.get() == "on":
					input_data = gpg.gen_key_input(key_type='rsa', name_real=Real_name.get(), expire_date='0', key_length='4096', key_usage='cert', name_email=Name_email.get(), passphrase=Secret_passphrase.get())
					key = gpg.gen_key(input_data)
					self.new_Alias_real_name(key.fingerprint, Real_name.get())
				else:
					input_data = gpg.gen_key_input(key_type='rsa', name_real=Real_name.get(), expire_date='0', key_length='4096', name_email=Name_email.get(), passphrase=Secret_passphrase.get())
					key = gpg.gen_key(input_data)
					self.new_Alias_real_name(key.fingerprint, Real_name.get())
				
				try:
					gpg.trust_keys(key.fingerprint, trustlevel='TRUST_ULTIMATE')
				except Exception:
					tk.messagebox.showinfo('Error', 'Could not set trust level to ULTIMATE.')
				
				show_progress('78')
				self.update()
				keyfilename = 'publicKey' + key.fingerprint + '.gpg'
				ascii_armored_public_key = gpg.export_keys(key.fingerprint) 
				completeName = filepathdestinationfolder + '/secure/keys/' + keyfilename
				f2 = open(completeName, 'w')
				f2.write(ascii_armored_public_key)
				f2.close()
				ascii_armored_private_key = gpg.export_keys(key.fingerprint, True, expect_passphrase=False)
				privateKeyName = filepathdestinationfolder + '/secure/keys/' + 'privateKey' + key.fingerprint + '.gpg' 
				f3 = open(privateKeyName, 'w')
				f3.write(ascii_armored_private_key)
				f3.close()
				
				completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
				f2 = open(completeName, 'a')
				
				if checkbox.get() == "on":
					f2.write("\nGPG Private key: " + Real_name.get() + "\n\nFingerprint: " + key.fingerprint + "\n\n   E-mail: " + Name_email.get() + "\n\n   Password: " + Secret_passphrase.get() + "\n\n   Comment: Only Certify capability.\n___________________________________\n")
				else:
					f2.write("\nGPG Private key: " + Real_name.get() + "\n\nFingerprint: " + key.fingerprint + "\n\n   E-mail: " + Name_email.get() + "\n\n   Password: " + Secret_passphrase.get() + "\n\n   Comment: \n___________________________________\n")
				
				f2.close()
			
				new_record = [key.fingerprint, "Key created.", Real_name.get()]
				self.add_record(new_record)
				self.add_history("Added new key: " + Real_name.get() + ", " + key.fingerprint)
				show_progress('100')
				self.update()
				tk.messagebox.showinfo('Information', "Private key has been created!\n\nA backup has been stored in the Secure archive!\n\nRemember to make a backup for your entire account after each major addition or change!")
				stored_name = ''
				stored_email =''
			
				self.get_GnuPGKeys_compact(['_none__'])
			
		def do_deleteGPGkey():
			global clicked_privateKey
			global GPG_button_color
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			clicked_privateKey = clicked.get()
			answer = messagebox.askquestion('WARNING!', 'WARNING! You are about to delete a private key! Are you SURE you want to delete it?')
			
			# Get back from Alias if needed
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			if answer == 'yes':
				try:
					key = gpg.delete_keys(decoded_fingerprint, True, expect_passphrase=False) 
				except ValueError as ve:
					messagebox.showinfo('Information', 'Something went wrong.')

				messagebox.showinfo('Information', 'Private key has been removed.')
				self.add_history("Deleted private key: " + decoded_fingerprint)
				self.get_GnuPGKeys_compact(['_none__'])
			else:
				messagebox.showinfo("Information", "OK. Keeping the private key.")
				self.get_GnuPGKeys_compact(['_none__'])
		
		def do_deletepublicGPGkey():			
			clicked_publicKey = str(clicked2.get())
			# Get back from Alias if needed
			decoded_fingerprint = self.lookup_fingerprint(clicked_publicKey)
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			key = gpg.delete_keys(decoded_fingerprint)
			
			self.remove_Alias(decoded_fingerprint)
			tk.messagebox.showinfo('Information', 'Public key has been removed.')
			self.add_history("Deleted public key: " + decoded_fingerprint)
			self.get_GnuPGKeys_compact(['_none__'])
		
		def dice_password_pre():
			global stored_name, stored_email
			stored_name = Real_name.get()
			stored_email = Name_email.get()
			self.dicePassword("1")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
			
		Label1 = ctk.CTkLabel(my_Frame, text="Add a private key to the local keychain, or remove a private and/or public key", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.06, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="The \"Only certify\"-checkbox for a new key should only be checked if you intend to use it with a Yubikey*.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.13, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Remember to make a backup of the Offline device if any new private key is added to the local keychain!", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.18, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="* This will require you to add subkeys afterwards (adding subkeys are found under the \"GPG\"-menu).", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.46, rely=0.94, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
		check_var = ctk.StringVar(value="off")
	
		List_fingerprints = []
		List_fingerprint_info = []
		List_publicfingerprints = []
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False
		publickeysavailable = False		
		
		# Extract a list of fingerprints from list from GPG.list keys 
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
					
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i2['fingerprint'])
		
		if List_publicfingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True		
		
		Label2 = ctk.CTkLabel(my_Frame, text="Full name:", font=my_font, text_color="white", fg_color="black")
		Label2.place(relx=0.34, rely=0.3, anchor="e")
		stored_name_var = ctk.StringVar(value=stored_name)
		stored_name_var.trace('w', limitSizeName_text)
		if stored_name != '':
			Real_name = ctk.CTkEntry(my_Frame, placeholder_text=stored_name, textvariable=stored_name_var, font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		else:
			Real_name = ctk.CTkEntry(my_Frame, placeholder_text="Bob Smith", textvariable=stored_name_var, font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		Real_name.place(relx=0.35, rely=0.3, anchor="w")
		Label5 = ctk.CTkLabel(my_Frame, text="Email:", font=my_font, text_color="white", fg_color="black")
		Label5.place(relx=0.34, rely=0.35, anchor="e")
		stored_email_var = ctk.StringVar(value=stored_email)
		stored_email_var.trace('w', limitSizeEmail_text)
		if stored_email != '':
			Name_email = ctk.CTkEntry(my_Frame, placeholder_text=stored_email, textvariable=stored_email_var, font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		else:
			Name_email = ctk.CTkEntry(my_Frame, placeholder_text="bob.smaith@cyb.org", textvariable=stored_email_var, font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
		Name_email.place(relx=0.35, rely=0.35, anchor="w")
		Label6 = ctk.CTkLabel(my_Frame, text="Secret passphrase:", font=my_font, text_color="white", fg_color="black")
		Label6.place(relx=0.34, rely=0.4, anchor="e")
		
		if combinedValueBase58 != "none":
			strong_password_var = ctk.StringVar(value=combinedValueBase58)
			strong_password_var.trace('w', limitSizePassphrase_text)
			Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text=combinedValueBase58, textvariable=strong_password_var, show='*', font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
			Secret_passphrase.place(relx=0.35, rely=0.4, anchor="w")
		else:
			Secret_passphrase = ctk.CTkEntry(my_Frame, placeholder_text="*********************", show='*', font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
			Secret_passphrase.place(relx=0.35, rely=0.4, anchor="w")
		tButton = ctk.CTkButton(my_Frame, text="Show/hide", font=my_font, text_color="black", fg_color="pink", border_width=2, border_color="white", command=tPassphrase)
		tButton.place(relx=0.68, rely=0.4, anchor="center")
		diceFunction = "newGPG"
		doButton = ctk.CTkButton(my_Frame, text="Create a strong password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=dice_password_pre) 
		doButton.place(relx=0.75, rely=0.4, anchor="w")
		
		checkbox = ctk.CTkCheckBox(my_Frame, text="Only certify *", font=my_font, variable=check_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox.place(relx=0.35, rely=0.46, anchor="w")
		Button = ctk.CTkButton(my_Frame, text="Create new GPG key", font=my_font, text_color="white", fg_color="dark green", border_width=2, border_color="white", command=do_newGPGFull)
		Button.place(relx=0.45, rely=0.51, anchor="w")
		if privatekeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to remove:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.34, rely=0.58, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.35, rely=0.58, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Remove private key**", font=my_font, text_color="white", fg_color="red4", border_width=2, border_color="white", command=do_deleteGPGkey)
			Button2.place(relx=0.54, rely=0.63, anchor="w")
			Label1 = ctk.CTkLabel(my_Frame, text="**Always remove the private key first in a private/public keypair", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.5, rely=0.69, anchor="center")
		if publickeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select public key to remove:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.34, rely=0.76, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.35, rely=0.76, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Remove public key**", font=my_font, text_color="white", fg_color="red4", border_width=2, border_color="white", command=do_deletepublicGPGkey)
			Button2.place(relx=0.55, rely=0.81, anchor="w")
		
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.94, rely=0.95, anchor="center")
	
	def Nostr_showQR(self, info):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
		# Generate QR-code and display on screen
		QR_pic = qrcode.make(info, version=1)
		resize_QR_pic = QR_pic.resize((300, 300))
		pathtoQR_pic = str(filepathdestinationfolder) + "/secure/ID/nostr.png"
		resize_QR_pic.save(pathtoQR_pic)
		loadimg = ctk.CTkImage(light_image=Image.open(pathtoQR_pic), dark_image=Image.open(pathtoQR_pic), size=(300, 300))
		
		Label_info = ctk.CTkLabel(my_Frame, text=info, text_color="white", fg_color="black", font=my_font)
		Label_info.place(relx=0.5, rely=0.1, anchor="center")
		
		Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
		Labelpublicimg.place(relx=0.5, rely=0.4, anchor="center")
		
		copy_button = ctk.CTkButton(my_Frame, text="Copy to clipboard", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, info))
		copy_button.place(relx=0.5, rely=0.68, anchor="center")
			
		back_button = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="blue", border_width=2, border_color="white", font=my_font, command=self.Nostr_main)
		back_button.place(relx=0.5, rely=0.88, anchor="center")
	
	def Nostr_Export_Key(self, info):
		global filepathdestinationfolder
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
		# Export to USB
		Label_info = ctk.CTkLabel(my_Frame, text="The selected Nostr key will be exported to a file named \"" + info + ".txt\" on the USB-device.", text_color="white", fg_color="black", font=my_font)
		Label_info.place(relx=0.5, rely=0.12, anchor="center")
		
		path_Pri = filepathdestinationfolder + "/secure/ID/" + info + ".txt"
		
		tk.messagebox.showinfo('Information', 'Insert the USB-device and then click \"OK\"."')
		time.sleep(2)
		tk.messagebox.showinfo('Information', 'Select the folder where you want to save the key. MAKE SURE TO DOUBLE CLICK ON THE CONNECTED USB DEVICE."')
		time.sleep(2)
		outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
		shutil.copy(path_Pri, outputdir)
		
		self.add_history("Exported Nostr key: " + info)
		
		back_button = ctk.CTkButton(my_Frame, text="Done!", text_color="white", fg_color="blue", border_width=2, border_color="white", font=my_font, command=self.Nostr_main)
		back_button.place(relx=0.5, rely=0.88, anchor="center")
	
	def Export_text_to_file(self, info):
		tk.messagebox.showinfo('Information', 'Insert the USB-device and then click \"OK\"."')
		time.sleep(2)
		tk.messagebox.showinfo('Information', 'Select the folder where you want to save the file. Make sure to double click on the USB-device to select it. Then press \"OK\""')
		time.sleep(2)
		outputdir = filedialog.askdirectory(initialdir='/media/user1')
		full_path = outputdir + '/ChromeExtensionLink.txt'
		
		with open(full_path, 'w') as file:
			file.write(info)
		
		self.Nostr_main()	
		
	def Nostr_New_Pri_Key(self):
		global filepathdestinationfolder
		
		# Generate a new key pair
		nsec = PrivateKey()
		nsec_hex = nsec.hex()
		nsec_bech32 = nsec.bech32()
		npub = nsec.public_key
		
		npub_bech32 = npub.bech32()
		
		def search_and_replace(file_path, search_word, replace_word):
			originals_file_path_device = filepathdestinationfolder + "/Documents/NSD_Nostr_Signing_Device_v2.html"
			originals_file_path_user = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_v2.html"
			originals_dir_path_device = filepathdestinationfolder + "/Documents/NSD Nostr Signing Device v2_files"
			user_dir = filepathdestinationfolder + "/secure/ID/NSD Nostr Signing Device v2_files" 
			
			# First check if this is really the first Nostr key and relevant files needs to be copied to the users secure-folder
			if not os.path.isfile(originals_file_path_user):
				shutil.copy(originals_file_path_device, originals_file_path_user)
				shutil.copytree(originals_dir_path_device, user_dir, dirs_exist_ok=True)
			
			shutil.copy(originals_file_path_user, file_path)
			with open(file_path, 'r') as file:
				file_contents = file.read()

				updated_contents = file_contents.replace(search_word, replace_word)
			with open(file_path, 'w') as file:
				file.write(updated_contents)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
		# Ask for keypair description (optional).
		USER_INP = simpledialog.askstring(title="Optional!", prompt="Enter a description for the public/private keypair:")
		input_size = len(USER_INP)
		if input_size > 42:
			messagebox.showinfo("Information", "The description can be max 42 characters.")
			self.Nostr_New_Pri_Key()
		else:
			c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key_desciption.txt", 'w')
			c.write(USER_INP)
			c.close()	

		# Create new key pair
		Label_info = ctk.CTkLabel(my_Frame, text="A new primary Nostr key has been created. \nThe key consists of a public key (Npub) and a private key (Nsec):", text_color="white", fg_color="black", font=my_font)
		Label_info.place(relx=0.5, rely=0.12, anchor="center")
		Label_info2 = ctk.CTkLabel(my_Frame, text="The new public key (npub) is:", text_color="white", fg_color="black", font=my_font)
		Label_info2.place(relx=0.5, rely=0.24, anchor="center")
		Label_info3 = ctk.CTkLabel(my_Frame, text=npub_bech32, text_color="white", fg_color="black", font=my_font)
		Label_info3.place(relx=0.5, rely=0.28, anchor="center")
		Label_info4 = ctk.CTkLabel(my_Frame, text="The new private key (nsec) is:", text_color="white", fg_color="black", font=my_font)
		Label_info4.place(relx=0.5, rely=0.36, anchor="center")
		Label_info5 = ctk.CTkLabel(my_Frame, text=nsec_bech32, text_color="white", fg_color="black", font=my_font)
		Label_info5.place(relx=0.5, rely=0.4, anchor="center")
		
		npub_data = str(npub_bech32)
		c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key.txt", 'w')
		c.write(npub_data)
		c.close()
		nsec_data = str(nsec_hex) + '\n' + str(nsec_bech32)
		c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Nsec_Key.txt", 'w')
		c.write(nsec_data)
		c.close()
		completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
		f2 = open(completeName, 'a')
		
		f2.write("\nNostr key: " + USER_INP + "\n\n   Private key (Nsec):\n   " + nsec_bech32 + "\n\n   Public key (Npub):\n   " + npub_bech32 + "\n\n___________________________________\n")
		
		f2.close()
		self.add_history("New Nostr key created: " + npub_data)
		# Make a new NSD file from template (so it is with correct private HEX-key)
			
		file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_pri_v2.html"
		search_and_replace(file_path, "hex_key", str(nsec_hex))
			
		back_button = ctk.CTkButton(my_Frame, text="Next", text_color="white", fg_color="blue", border_width=2, border_color="white", font=my_font, command=self.Nostr_main)
		back_button.place(relx=0.5, rely=0.88, anchor="center")

	def Nostr_New_Sec_Key(self):
		global filepathdestinationfolder
		
		# Generate a new key pair
		nsec = PrivateKey()
		nsec_hex = nsec.hex()
		nsec_bech32 = nsec.bech32()
		npub = nsec.public_key
		npub_bech32 = npub.bech32()
		
		def search_and_replace(file_path, search_word, replace_word):
			originals_file_path_device = filepathdestinationfolder + "/Documents/NSD_Nostr_Signing_Device_v2.html"
			originals_file_path_user = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_v2.html"
			originals_dir_path_device = filepathdestinationfolder + "/Documents/NSD Nostr Signing Device v2_files"
			user_dir = filepathdestinationfolder + "/secure/ID/NSD Nostr Signing Device v2_files" 
			
			# First check if this is really the first Nostr key and relevant files needs to be copied to the users secure-folder
			if not os.path.isfile(originals_file_path_user):
				shutil.copy(originals_file_path_device, originals_file_path_user)
				shutil.copytree(originals_dir_path_device, user_dir, dirs_exist_ok=True)
			
			shutil.copy(originals_file_path_user, file_path)
			with open(file_path, 'r') as file:
				file_contents = file.read()

				updated_contents = file_contents.replace(search_word, replace_word)
			with open(file_path, 'w') as file:
				file.write(updated_contents)
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
		# Ask for keypair description (optional).
		USER_INP = simpledialog.askstring(title="Optional!", prompt="Enter a description for the public/private keypair:")
		input_size = len(USER_INP)
		if input_size > 42:
			messagebox.showinfo("Information", "The description can be max 42 characters.")
			self.Nostr_New_Pri_Key()
		else:
			c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key_desciption.txt", 'w')
			c.write(USER_INP)
			c.close()
			
		# Create new key pair
		Label_info = ctk.CTkLabel(my_Frame, text="A new Secondary Nostr key has been created. \nThe key consists of a public key (Npub) and a private key (Nsec):", text_color="white", fg_color="black", font=my_font)
		Label_info.place(relx=0.5, rely=0.12, anchor="center")
		Label_info2 = ctk.CTkLabel(my_Frame, text="The new public key (npub) is:", text_color="white", fg_color="black", font=my_font)
		Label_info2.place(relx=0.5, rely=0.24, anchor="center")
		Label_info3 = ctk.CTkLabel(my_Frame, text=npub_bech32, text_color="white", fg_color="black", font=my_font)
		Label_info3.place(relx=0.5, rely=0.28, anchor="center")
		Label_info4 = ctk.CTkLabel(my_Frame, text="The new private key (nsec) is:", text_color="white", fg_color="black", font=my_font)
		Label_info4.place(relx=0.5, rely=0.36, anchor="center")
		Label_info5 = ctk.CTkLabel(my_Frame, text=nsec_bech32, text_color="white", fg_color="black", font=my_font)
		Label_info5.place(relx=0.5, rely=0.4, anchor="center")
		
		npub_data = str(npub_bech32)
		c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key.txt", 'w')
		c.write(npub_data)
		c.close()
		nsec_data = str(nsec_hex) + '\n' + str(nsec_bech32)
		c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Nsec_Key.txt", 'w')
		c.write(nsec_data)
		c.close()
		completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
		f2 = open(completeName, 'a')
		
		f2.write("\nNostr key: " + USER_INP + "\n\n   Private key (Nsec):\n   " + nsec_bech32 + "\n\n   Public key (Npub):\n   " + npub_bech32 + "\n\n___________________________________\n")
		
		f2.close()
		self.add_history("New Nostr key created: " + npub_data)
		# Make a new NSD file from template (so it is with correct private HEX-key)
			
		file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_sec_v2.html"
		search_and_replace(file_path, "hex_key", str(nsec_hex))
		
		back_button = ctk.CTkButton(my_Frame, text="Next", text_color="white", fg_color="blue", border_width=2, border_color="white", font=my_font, command=self.Nostr_main)
		back_button.place(relx=0.5, rely=0.88, anchor="center")
	
	def Import_Nostr_key(self, key):
		global filepathdestinationfolder
		hex_value = "0x40"
		
		def search_and_replace(file_path, search_word, replace_word):
			originals_file_path_device = filepathdestinationfolder + "/Documents/NSD_Nostr_Signing_Device_v2.html"
			originals_file_path_user = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_v2.html"
			originals_dir_path_device = filepathdestinationfolder + "/Documents/NSD Nostr Signing Device v2_files"
			user_dir = filepathdestinationfolder + "/secure/ID/NSD Nostr Signing Device v2_files" 
			
			# First check if this is really the first Nostr key and relevant files needs to be copied to the users secure-folder
			if not os.path.isfile(originals_file_path_user):
				shutil.copy(originals_file_path_device, originals_file_path_user)
				shutil.copytree(originals_dir_path_device, user_dir, dirs_exist_ok=True)
			
			shutil.copy(originals_file_path_user, file_path)
			with open(file_path, 'r') as file:
				file_contents = file.read()

				updated_contents = file_contents.replace(search_word, replace_word)
			with open(file_path, 'w') as file:
				file.write(updated_contents)
				
		messagebox.showinfo("Information", "Connect the USB-device with the Nostr key.")
		time.sleep(3)
		messagebox.showinfo("Information", "Select key file. It has to be a text file with exactly two lines:\n\nLine 1: the Public key (Npub).\nLine 2: the Private key (Nsec).")
		time.sleep(3)
		filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			
		try:
			lines = open(filepathSourcefile).read().splitlines()
		except IOError:
			messagebox.showinfo("Information", "There was a problem reading the file!")
		if len(lines) == 2:
			npub_value = lines[0]
			nsec_value = lines[1]
			try:
				hex_value = PrivateKey.from_nsec(nsec_value).hex()
			except Exception:
				messagebox.showinfo("Alert", "This not valid Nostr keys!")
				return
			# Ask for keypair description (optional).
			USER_INP = simpledialog.askstring(title="Optional!", prompt="Enter a description for the public/private keypair:")
			input_size = len(USER_INP)
			if input_size > 42:
				messagebox.showinfo("Information", "The description can be max 42 characters.")
				self.Import_Nostr_key(key)

			if key == "Primary":
				# Also include the Hex code to the Nsec (for NSD device)
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key.txt", 'w')
				c.write(npub_value)
				c.close()
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Nsec_Key.txt", 'w')
				c.write(str(hex_value) + '\n' + nsec_value)
				c.close()
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key_desciption.txt", 'w')
				c.write(USER_INP)
				c.close()
				# Make a new NSD file from template (so it is with correct private HEX-key)
				file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_pri_v2.html"
				search_and_replace(file_path, "hex_key", str(hex_value))
				completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
				f2 = open(completeName, 'a')
				
				f2.write("\nNostr key (imported): " + USER_INP + "\n\n   Private key (Nsec):\n   " + nsec_value + "\n\n   Public key (Npub):\n   " + npub_value + "\n\n___________________________________\n")
				
				f2.close()
				self.add_history("Imported Nostr key: " + npub_value)
		
			if key == "Secondary":
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key.txt", 'w')
				c.write(npub_value)
				c.close()
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Nsec_Key.txt", 'w')
				c.write(str(hex_value) + '\n' + nsec_value)
				c.close()
				c = open(filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key_desciption.txt", 'w')
				c.write(USER_INP)
				c.close()
				# Make a new NSD file from template (so it is with correct private HEX-key)
				file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_sec_v2.html"
				search_and_replace(file_path, "hex_key", str(hex_value))
				completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
				f2 = open(completeName, 'a')
				
				f2.write("\nNostr key (imported): " + USER_INP + "\n\n   Private key (Nsec):\n   " + nsec_value + "\n\n   Public key (Npub):\n   " + npub_value + "\n\n___________________________________\n")
				
				f2.close()
				self.add_history("Imported Nostr key: " + npub_value)
		else:
			messagebox.showinfo("Information", "There was a problem reading the file!")
		self.Nostr_main()
	
	def open_webpage_pri(self):
		global filepathdestinationfolder
		file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_pri_v2.html"
		webbrowser.open_new_tab(file_path)
						
	def open_webpage_sec(self):
		global filepathdestinationfolder
		file_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_sec_v2.html"
		webbrowser.open_new_tab(file_path)
		
	def Nostr_main(self):
		global filepathdestinationfolder
		
		# Read in the value (if any)
		Pri_npub_value = "< Missing >"
		Pri_nsec_value = "< Missing >"
		Sec_npub_value = "< Missing >"
		Sec_nsec_value = "< Missing >"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
			
		def do_deleteNostrPriKeys():
			answer = messagebox.askquestion('WARNING!', 'WARNING! You are about to delete the Nostr Primary key! Are you SURE you want to delete it?')
			
			if answer == 'yes':
				pri_path = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key.txt"
				os.remove(pri_path) 
				pri_path = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Nsec_Key.txt"
				os.remove(pri_path)
				pri_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_pri_v2.html"
				os.remove(pri_path)
				pri_path = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key_desciption.txt"
				if os.path.isfile(pri_path):
					os.remove(pri_path)
				messagebox.showinfo('Information', 'Primary Nostr key has been removed.')
				self.Nostr_main()
			else:
				messagebox.showinfo("Information", "OK. Keeping the private key.")
				self.Nostr_main()
		
		def do_deleteNostrSecKeys():
			answer = messagebox.askquestion('WARNING!', 'WARNING! You are about to delete the Nostr Secondary key! Are you SURE you want to delete it?')
			 
			if answer == 'yes':
				sec_path = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key.txt"
				os.remove(sec_path) 
				sec_path = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Nsec_Key.txt"
				os.remove(sec_path)
				sec_path = filepathdestinationfolder + "/secure/ID/NSD_Nostr_Signing_Device_sec_v2.html"
				os.remove(sec_path)
				sec_path = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key_desciption.txt"
				if os.path.isfile(sec_path):
					os.remove(sec_path)
				messagebox.showinfo('Information', 'Secondary Nostr key has been removed.')
				self.Nostr_main()
			else:
				messagebox.showinfo("Information", "OK. Keeping the private key.")
				self.Nostr_main()
				
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		Label1 = ctk.CTkLabel(my_Frame, text="Create, import or export Nostr public/private keys.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.07, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="Store two seperate Nostr key pairs.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.12, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Exporting the public/private key can be done using QR-code or a USB-device. The private key can also be exported to a NSD *.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.17, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="!!! Use caution when handling the private key !!!", text_color="red", fg_color="black", font=my_font)
		Label4.place(relx=0.05, rely=0.22, anchor="w")
		
		Label_footer = ctk.CTkLabel(my_Frame, text="* NSD = Nostr Signing Device. A hardware key that can sign Nostr events. See www.github.com/lnbits/nostr-signing-device.", text_color="white", fg_color="black", font=my_font)
		Label_footer.place(relx=0.1, rely=0.72, anchor="w")
		Label_footer2 = ctk.CTkLabel(my_Frame, text=" Works with Chrome browser running Nostr web clients such as www.Iris.to, www.coracle.social or www.snort.social etc.", text_color="white", fg_color="black", font=my_font)
		Label_footer2.place(relx=0.1, rely=0.78, anchor="w")
		Label_footer3 = ctk.CTkLabel(my_Frame, text=" Browser needs to have the following plugin installed:", text_color="white", fg_color="black", font=my_font)
		Label_footer3.place(relx=0.1, rely=0.84, anchor="w")
		Label_footer4 = ctk.CTkLabel(my_Frame, text="https://chromewebstore.google.com/detail/horse/ogdjeglchjlenflecdcoonkngmmipcoe.", text_color="white", fg_color="black", font=my_font)
		Label_footer4.place(relx=0.14, rely=0.91, anchor="w")
		Export_file_Button = ctk.CTkButton(my_Frame, text="Export Link", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Export_text_to_file, "https://chromewebstore.google.com/detail/horse/ogdjeglchjlenflecdcoonkngmmipcoe"))
		Export_file_Button.place(relx=0.8, rely=0.9, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Pri_Label = ctk.CTkLabel(my_Frame, text="Key description:", font=my_font, text_color="white", fg_color="black")
		Pri_Label.place(relx=0.19, rely=0.29, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
		Pri_Label2 = ctk.CTkLabel(my_Frame, text="Primary Nostr key (npub):", font=my_font, text_color="white", fg_color="black")
		Pri_Label2.place(relx=0.2, rely=0.35, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Sec_Label = ctk.CTkLabel(my_Frame, text="Key description:", font=my_font, text_color="white", fg_color="black")
		Sec_Label.place(relx=0.19, rely=0.49, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
		
		Sec_Label2 = ctk.CTkLabel(my_Frame, text="Secondary Nostr key (npub):", font=my_font, text_color="white", fg_color="black")
		Sec_Label2.place(relx=0.2, rely=0.55, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
		
		# If Nostr primary file is available
		pathtopri_Npub = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key.txt"
		pathtopri_Npub_description = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Npub_Key_desciption.txt"
		pathtopri_Nsec = filepathdestinationfolder + "/secure/ID/Nostr_Primary_Nsec_Key.txt"
		if os.path.isfile(pathtopri_Npub):
			Pri_npub_description = ' '
			try:
				lines = open(pathtopri_Npub_description).read().splitlines()
				if len(lines) == 1:
					Pri_npub_description = lines[0]
				else:
					print("There was a problem reading the Nostr key description file!")
			except IOError:
				print("There was a problem reading the Nostr key description file!")
			
			try:
				lines = open(pathtopri_Npub).read().splitlines()
				if len(lines) == 1:
					Pri_npub_value = lines[0]
				else:
					messagebox.showinfo("Information", "There was a problem reading the file!")	
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
			
			try:
				lines = open(pathtopri_Nsec).read().splitlines()
				if len(lines) == 2:
					Pri_nsec_hexvalue = lines[0]
					Pri_nsec_value = lines[1]
				else:
					messagebox.showinfo("Information", "There was a problem reading the file!")
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
			
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)		
			Pri_npub_button_descr = ctk.CTkButton(my_Frame, text=Pri_npub_description, font=my_font, anchor="w", width=580, height=25, text_color="white", fg_color="black", border_color="black", border_width=3, command=partial(self.Nostr_showQR, Pri_npub_value))
			Pri_npub_button_descr.place(relx=0.2, rely=0.29, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
			Pri_npub_button = ctk.CTkButton(my_Frame, text=Pri_npub_value, font=my_font, width=580, height=25, text_color="white", fg_color="navy blue", border_color="white", border_width=3, command=partial(self.Nostr_showQR, Pri_npub_value))
			Pri_npub_button.place(relx=0.21, rely=0.35, anchor="w")
			
			QR_Button_pri = ctk.CTkButton(my_Frame, text="QR", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=partial(self.Nostr_showQR, Pri_npub_value))
			QR_Button_pri.place(relx=0.75, rely=0.35, anchor="center")
			Export_Button_pri = ctk.CTkButton(my_Frame, text="Export", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Nostr_Export_Key, "Nostr_Primary_Npub_Key"))
			Export_Button_pri.place(relx=0.83, rely=0.35, anchor="center")
			Delete_Button_pri = ctk.CTkButton(my_Frame, text="Delete", font=my_font, text_color="white", fg_color="red", width=85, border_width=2, border_color="white", command=do_deleteNostrPriKeys)
			Delete_Button_pri.place(relx=0.91, rely=0.35, anchor="center")
			
			Label = ctk.CTkLabel(my_Frame, text="Secret key (nsec):", font=my_font, text_color="white", fg_color="black")
			Label.place(relx=0.2, rely=0.4, anchor="e")
			Pri_npub_button = ctk.CTkButton(my_Frame, text=Pri_nsec_value, font=my_font, width=580, height=25, text_color="light grey", fg_color="navy blue", border_color="white", border_width=3, command=partial(self.Nostr_showQR, Pri_nsec_value))
			Pri_npub_button.place(relx=0.21, rely=0.4, anchor="w")
			QR_Button_pri_nsec = ctk.CTkButton(my_Frame, text="QR", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=partial(self.Nostr_showQR, Pri_nsec_value))
			QR_Button_pri_nsec.place(relx=0.75, rely=0.4, anchor="center")
			Export_Button_pri_nsec = ctk.CTkButton(my_Frame, text="Export", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Nostr_Export_Key, "Nostr_Primary_Nsec_Key"))
			Export_Button_pri_nsec.place(relx=0.83, rely=0.4, anchor="center")
			if Pri_nsec_hexvalue != "missing":
				NSD_Button_pri = ctk.CTkButton(my_Frame, text="NSD *", font=my_font, text_color="white", fg_color="red", width=85, border_width=2, border_color="white", command=self.open_webpage_pri)
				NSD_Button_pri.place(relx=0.91, rely=0.4, anchor="center")
		else:	
			# If Nostr Primary files are not available
			Pri_npub_button = ctk.CTkButton(my_Frame, text=Pri_npub_value, font=my_font, width=580, height=25, text_color="white", fg_color="blue", border_color="white", border_width=3, command=self.Nostr_New_Pri_Key)
			Pri_npub_button.place(relx=0.21, rely=0.35, anchor="w")
			Export_Button_pri = ctk.CTkButton(my_Frame, text="Create new", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=self.Nostr_New_Pri_Key)
			Export_Button_pri.place(relx=0.75, rely=0.35, anchor="center")
			Delete_Button_pri = ctk.CTkButton(my_Frame, text="Import", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Import_Nostr_key, "Primary"))
			Delete_Button_pri.place(relx=0.83, rely=0.35, anchor="center")
		
		pathtosec_Npub = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key.txt"
		pathtosec_Npub_description = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Npub_Key_desciption.txt"
		pathtosec_Nsec = filepathdestinationfolder + "/secure/ID/Nostr_Secondary_Nsec_Key.txt"
		
		if os.path.isfile(pathtosec_Npub):
			Sec_npub_description = ''
			try:
				lines = open(pathtosec_Npub_description).read().splitlines()
				if len(lines) == 1:
					Sec_npub_description = lines[0]
				else:
					print("There was a problem reading the Nostr key description file!")
			except IOError:
				print("There was a problem reading the Nostr key description file!")
			try:
				lines = open(pathtosec_Npub).read().splitlines()
				if len(lines) == 1:
					Sec_npub_value = lines[0]
				else:
					messagebox.showinfo("Information", "There was a problem reading the file!")
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
			try:
				lines = open(pathtosec_Nsec).read().splitlines()
				if len(lines) == 2:
					Sec_nsec_hexvalue = lines[0]
					Sec_nsec_value = lines[1]
				else:
					messagebox.showinfo("Information", "There was a problem reading the file!")
			except IOError:
				messagebox.showinfo("Information", "There was a problem reading the file!")
			
			my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=True, overstrike=False)	
			Sec_npub_button_descr = ctk.CTkButton(my_Frame, text=Sec_npub_description, font=my_font, anchor="w", width=580, height=25, text_color="white", fg_color="black", border_color="black", border_width=3, command=partial(self.Nostr_showQR, Sec_npub_value))
			Sec_npub_button_descr.place(relx=0.2, rely=0.49, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=16, weight="normal", slant="roman", underline=False, overstrike=False)
			Sec_npub_button = ctk.CTkButton(my_Frame, text=Sec_npub_value, font=my_font, width=580, height=25, text_color="white", fg_color="navy blue", border_color="white", border_width=3, command=partial(self.Nostr_showQR, Sec_npub_value))
			Sec_npub_button.place(relx=0.21, rely=0.55, anchor="w")
			
			QR_Button_sec = ctk.CTkButton(my_Frame, text="QR", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=partial(self.Nostr_showQR, Sec_npub_value))
			QR_Button_sec.place(relx=0.75, rely=0.55, anchor="center")
			Export_Button_sec = ctk.CTkButton(my_Frame, text="Export", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Nostr_Export_Key, "Nostr_Secondary_Npub_Key"))
			Export_Button_sec.place(relx=0.83, rely=0.55, anchor="center")
			Delete_Button_sec = ctk.CTkButton(my_Frame, text="Delete", font=my_font, text_color="white", fg_color="red", width=85, border_width=2, border_color="white", command=do_deleteNostrSecKeys)
			Delete_Button_sec.place(relx=0.91, rely=0.55, anchor="center")
			
			Label = ctk.CTkLabel(my_Frame, text="Secret key (nsec):", font=my_font, text_color="white", fg_color="black")
			Label.place(relx=0.2, rely=0.6, anchor="e")
			Sec_npub_button = ctk.CTkButton(my_Frame, text=Sec_nsec_value, font=my_font, width=580, height=25, text_color="white", fg_color="navy blue", border_color="white", border_width=3, command=partial(self.Nostr_showQR, Sec_nsec_value))
			Sec_npub_button.place(relx=0.21, rely=0.6, anchor="w")
			QR_Button_sec_nsec = ctk.CTkButton(my_Frame, text="QR", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=partial(self.Nostr_showQR, Sec_nsec_value))
			QR_Button_sec_nsec.place(relx=0.75, rely=0.6, anchor="center")
			Export_Button_sec_nsec = ctk.CTkButton(my_Frame, text="Export", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Nostr_Export_Key, "Nostr_Secondary_Nsec_Key"))
			Export_Button_sec_nsec.place(relx=0.83, rely=0.6, anchor="center")
			if Sec_nsec_hexvalue != "missing":
				NSD_Button_sec = ctk.CTkButton(my_Frame, text="NSD *", font=my_font, text_color="white", fg_color="red", width=85, border_width=2, border_color="white", command=self.open_webpage_sec)
				NSD_Button_sec.place(relx=0.91, rely=0.6, anchor="center")	
		else:	
			# If Nostr Secondary files are not available
			Sec_npub_button = ctk.CTkButton(my_Frame, text=Sec_npub_value, font=my_font, width=580, height=25, text_color="white", fg_color="navy blue", border_color="white", border_width=3, command=self.Nostr_New_Pri_Key)
			Sec_npub_button.place(relx=0.21, rely=0.55, anchor="w")
			Export_Button_sec = ctk.CTkButton(my_Frame, text="Create new", font=my_font, text_color="white", fg_color="green", width=85, border_width=2, border_color="white", command=self.Nostr_New_Sec_Key)
			Export_Button_sec.place(relx=0.75, rely=0.55, anchor="center")
			Delete_Button_sec = ctk.CTkButton(my_Frame, text="Import", font=my_font, text_color="white", fg_color="navy blue", width=85, border_width=2, border_color="white", command=partial(self.Import_Nostr_key, "Secondary"))
			Delete_Button_sec.place(relx=0.83, rely=0.55, anchor="center")	
			
	def setup_Yubikey(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		autPolicy = ctk.StringVar(value="off")
		encPolicy = ctk.StringVar(value="off")
		sigPolicy = ctk.StringVar(value="off")
		
		def resetFIDOYubikey():
			# Reset the FIDO on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			command= 'ykman fido reset'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
		
		def changePINsopenpgpYubikey():
			# Reset the FIDO on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"passwd\" hit enter.\nSelect \"3\" and hit enter.\n        Enter current admin PIN (default admin PIN is 12345678).\n      Add new admin PIN (min 8 digits).\n        Confirm the new admin PIN.\n3. Select \"1\" and hit enter.\n      Enter current PIN (default PIN is 123456).\n      Add new PIN (min 6 digits).\n        Confirm new PIN.\n4. Type \"q\" and hit enter.\n5. Type \"quit\" and hit enter.\n6. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.4, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=changePINsopenpgpYubikey_step2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def changePINsopenpgpYubikey_step2():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"passwd\" hit enter.\nSelect \"3\" and hit enter.\n        Enter current admin PIN (default admin PIN is 12345678).\n      Add new admin PIN (min 8 digits).\n        Confirm the new admin PIN.\n3. Select \"1\" and hit enter.\n      Enter current PIN (default PIN is 123456).\n      Add new PIN (min 6 digits).\n        Confirm new PIN.\n4. Type \"q\" and hit enter.\n5. Type \"quit\" and hit enter.\n6. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.4, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			command= 'gpg --card-edit'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			goButton = ctk.CTkButton(my_Frame, text="Finish", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=self.create_Yubikeymeny)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
				
		def resetOpenPGPYubikey():
			# Reset the FIDO on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=resetOpenPGPYubikey_step2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def resetOpenPGPYubikey_step2():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			command= 'ykman openpgp reset'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			goButton = ctk.CTkButton(my_Frame, text="Finish", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=self.create_Yubikeymeny)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
			
		def setautTouchYubikey():
			# Set aut touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.')
			if autPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch aut on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch aut off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
			
		def setencTouchYubikey():
			# Set enc touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			if encPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch enc on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch enc off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
			
		def setsigTouchYubikey():
			# Set sig touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			if sigPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch sig on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch sig off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
				
		def changeNameYubikey():
			# Set the PINs, name and email on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"name\" hit enter.\n3. Enter name details.\n4. Type \"quit\" and hit enter.\n5. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=changeNameYubikey2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def changeNameYubikey2():
			command= 'gpg --card-edit'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"name\" hit enter.\n3. Enter name details.\n4. Type \"quit\" and hit enter.\n5. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			goButton = ctk.CTkButton(my_Frame, text="Next", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=changeNameYubikey3)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
			
		def changeNameYubikey3():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)

			# Output what has been done from getStarted
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="italic", underline=True, overstrike=False)
			Label2 = ctk.CTkLabel(my_Frame, text="Finished!", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.35, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			Label23 = ctk.CTkLabel(my_Frame, text="You have sucessfully changed name credentials on the Yubikey.", text_color="white", fg_color="black", font=my_font)
			Label23.place(relx=0.5, rely=0.42, anchor="center")
			
			Button3 = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=self.setup_Yubikey_v2)
			Button3.place(relx=0.5, rely=0.55, anchor="center")
			
		def newPINFIDOYubikey():
			# Reset the FIDO on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			command= 'ykman fido access change-pin --new-pin ' +  newFIDOPIN.get()
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
			
		def changePINFIDOYubikey():
			# Reset the FIDO on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'See terminal window for information.')
			
			command= 'ykman fido access change-pin --pin ' +  currentFIDOPIN.get() + ' --new-pin ' + changedFIDOPIN.get()
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.create_Yubikeymeny()
		
		Label1 = ctk.CTkLabel(my_Frame, text="Setup Yubikey.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.07, anchor="w")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Make sure that your Yubikey 5 NFC is connected.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.12, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Button1 = ctk.CTkButton(my_Frame, text="Reset OpenPGP", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=resetOpenPGPYubikey)
		Button1.place(relx=0.5, rely=0.25, anchor="center")
		
		Button2 = ctk.CTkButton(my_Frame, text="Reset Passkey", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=resetFIDOYubikey)
		Button2.place(relx=0.5, rely=0.3, anchor="center")
		
		Button3 = ctk.CTkButton(my_Frame, text="Change name", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changeNameYubikey)
		Button3.place(relx=0.5, rely=0.35, anchor="center")
		
		Button4 = ctk.CTkButton(my_Frame, text="Change PINs OpenPGP", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changePINsopenpgpYubikey)
		Button4.place(relx=0.5, rely=0.4, anchor="center")
		
		FIDOLabel = ctk.CTkLabel(my_Frame, text="New Passkey PIN (min 6 digits):", text_color="white", fg_color="black", font=my_font)
		FIDOLabel.place(relx=0.15, rely=0.45, anchor="w")
		
		NEWPINLabel = ctk.CTkLabel(my_Frame, text="New PIN:", text_color="white", fg_color="black", font=my_font)
		NEWPINLabel.place(relx=0.35, rely=0.5, anchor="e")
		
		newFIDOPIN = ctk.CTkEntry(my_Frame, placeholder_text="******", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8,font=my_font)
		newFIDOPIN.place(relx=0.35, rely=0.5, anchor="w")
		
		newPINButton = ctk.CTkButton(my_Frame, text="New Passkey PIN", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=newPINFIDOYubikey)
		newPINButton.place(relx=0.55, rely=0.55, anchor="center")

		FIDOLabel_ = ctk.CTkLabel(my_Frame, text="Change Passkey PIN (min 6 digits, default PIN 123456):", text_color="white", fg_color="black", font=my_font)
		FIDOLabel_.place(relx=0.15, rely=0.6, anchor="w")
		
		FIDOLabel2 = ctk.CTkLabel(my_Frame, text="Current PIN:", text_color="white", fg_color="black", font=my_font)
		FIDOLabel2.place(relx=0.34, rely=0.65, anchor="e")
		
		currentFIDOPIN = ctk.CTkEntry(my_Frame, placeholder_text="******", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		currentFIDOPIN.place(relx=0.35, rely=0.65, anchor="w")
		
		CHANGEDPINLabel = ctk.CTkLabel(my_Frame, text="New PIN:", text_color="white", fg_color="black", font=my_font)
		CHANGEDPINLabel.place(relx=0.34, rely=0.7, anchor="e")
		
		changedFIDOPIN = ctk.CTkEntry(my_Frame, placeholder_text="******", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		changedFIDOPIN.place(relx=0.35, rely=0.7, anchor="w")
		
		tPINButton = ctk.CTkButton(my_Frame, text="Change Passkey PIN", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changePINFIDOYubikey)
		tPINButton.place(relx=0.55, rely=0.75, anchor="center")
		
		autPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Set Touch policy for Auth on (uncheck sets the poilcy to Off):", variable=autPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		autPolicyCheckBox.place(relx=0.2, rely=0.8, anchor="w")
		
		autButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setautTouchYubikey)
		autButton.place(relx=0.7, rely=0.8, anchor="center")
		
		encPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Set Touch policy for Encr on (uncheck sets the poilcy to Off):", variable=encPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		encPolicyCheckBox.place(relx=0.2, rely=0.84, anchor="w")
		encButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setencTouchYubikey)
		encButton.place(relx=0.7, rely=0.84, anchor="center")
		
		sigPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Set Touch policy for Sign on (uncheck sets the poilcy to Off):", variable=sigPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		sigPolicyCheckBox.place(relx=0.2, rely=0.88, anchor="w")
		sigButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setencTouchYubikey)
		sigButton.place(relx=0.7, rely=0.88, anchor="center")
	
	def setup_Yubikey_v2(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		autPolicy = ctk.StringVar(value="off")
		encPolicy = ctk.StringVar(value="off")
		sigPolicy = ctk.StringVar(value="off")
		
		config_data_textbox = ctk.CTkTextbox(my_Frame, width=500, height=160, corner_radius=1, border_width=3, border_color="red", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
		OpenPGP_configuration_data_textbox = ctk.CTkTextbox(my_Frame, width=500, height=160, corner_radius=1, border_width=3, border_color="red", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
		OpenPGP_credential_data_textbox = ctk.CTkTextbox(my_Frame, width=800, height=190, corner_radius=1, border_width=3, border_color="red", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")

		def resetFIDOYubikey():
			# Reset the FIDO on the Yubikey
			tk.messagebox.showinfo('Information', 'Warning! A Passkey cant be restored. Make sure you have another Passkey registered at relevant services in order to not be locked out of accounts.\n\nConnect the Yubikey and then press "OK"')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			command= 'ykman fido reset'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
		
		def changePINsopenpgpYubikey():
			# Reset the FIDO on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"passwd\" hit enter.\nSelect \"3\" and hit enter.\n        Enter current admin PIN (default admin PIN is 12345678).\n      Add new admin PIN (min 8 digits).\n        Confirm the new admin PIN.\n3. Select \"1\" and hit enter.\n      Enter current PIN (default PIN is 123456).\n      Add new PIN (min 6 digits).\n        Confirm new PIN.\n4. Type \"q\" and hit enter.\n5. Type \"quit\" and hit enter.\n6. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.4, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=changePINsopenpgpYubikey_step2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def changePINsopenpgpYubikey_step2():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"passwd\" hit enter.\nSelect \"3\" and hit enter.\n        Enter current admin PIN (default admin PIN is 12345678).\n      Add new admin PIN (min 8 digits).\n        Confirm the new admin PIN.\n3. Select \"1\" and hit enter.\n      Enter current PIN (default PIN is 123456).\n      Add new PIN (min 6 digits).\n        Confirm new PIN.\n4. Type \"q\" and hit enter.\n5. Type \"quit\" and hit enter.\n6. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.4, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			command= 'gpg --card-edit'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			goButton = ctk.CTkButton(my_Frame, text="Finish", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=self.setup_Yubikey_v2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
				
		def resetOpenPGPYubikey():
			# Reset the FIDO on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=resetOpenPGPYubikey_step2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def resetOpenPGPYubikey_step2():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			command= 'ykman openpgp reset'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			goButton = ctk.CTkButton(my_Frame, text="Finish", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=self.setup_Yubikey_v2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
			
		def setautTouchYubikey():
			# Set aut touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window that will open.\n\nAfter resetting the OpenPGP on the Yubikey type "exit" and hit enter to close the terminal window.')
			if autPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch aut on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch aut off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
			
		def setencTouchYubikey():
			# Set enc touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			if encPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch enc on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch enc off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
			
		def setsigTouchYubikey():
			# Set sig touch policy on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'Follow the instructions in the terminal window.\n\nType "exit" and hit enter to close the terminal window.')
			if sigPolicyCheckBox.get() == 'on':
				command= 'ykman openpgp keys set-touch sig on'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			else:
				command= 'ykman openpgp keys set-touch sig off'
				os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
				
		def changeNameYubikey():
			# Set the PINs, name and email on the Yubikey
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"name\" hit enter.\n3. Enter name details.\n4. Type \"quit\" and hit enter.\n5. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=changeNameYubikey2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def changeNameYubikey2():
			command= 'gpg --card-edit'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In the terminal window that will open: \n1. Type \"admin\" and hit enter to toggle until it says \"admin commands are allowed\"\n2. Type \"name\" hit enter.\n3. Enter name details.\n4. Type \"quit\" and hit enter.\n5. Exit the terminal by typing \"exit\" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			goButton = ctk.CTkButton(my_Frame, text="Next", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=changeNameYubikey3)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
			
		def changeNameYubikey3():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)

			# Output what has been done from getStarted
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="italic", underline=True, overstrike=False)
			Label2 = ctk.CTkLabel(my_Frame, text="Finished!", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.35, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			Label23 = ctk.CTkLabel(my_Frame, text="You have sucessfully changed name credentials on the Yubikey.", text_color="white", fg_color="black", font=my_font)
			Label23.place(relx=0.5, rely=0.42, anchor="center")
			
			Button3 = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", font=my_font, command=self.setup_Yubikey_v2)
			Button3.place(relx=0.5, rely=0.55, anchor="center")
		
		def enableUSB():
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'See terminal window for information.\n\nType "exit" and hit enter to close the terminal window.')
			
			command= 'ykman config usb --enable-all'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
			
		def enableNFC():
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'See terminal window for information.\n\nType "exit" and hit enter to close the terminal window.')
			
			command= 'ykman config nfc --enable-all'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
			
		def disableNFC():
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'See terminal window for information.\n\nType "exit" and hit enter to close the terminal window.')
			
			command= 'ykman config nfc --disable-all'
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
			
		def changePINFIDOYubikey():
			# Reset the FIDO on the Yubikey
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK". If already connected, first remove and re-connect the Yubikey.')
			time.sleep(3)
			tk.messagebox.showinfo('Information', 'See terminal window for information.\n\nType "exit" and hit enter to close the terminal window.')
			
			command= 'ykman fido access change-pin --pin ' +  currentFIDOPIN.get() + ' --new-pin ' + changedFIDOPIN.get()
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			self.setup_Yubikey_v2()
		
		def get_config_data():
			try:
				backend = usb.backend.libusb1.get_backend(find_library=lambda x: "/usr/lib/libusb-1.0.so")
				dev = usb.core.find(..., backend=backend)
				yubikey = yubico.find_yubikey(debug=False)
				config_data = subprocess.getoutput("ykman info")
				return config_data
			except yubico.yubico_exception.YubicoError as e:
				return e.reason
				
		def get_OpenPGP_configuration_data():
			try:
				backend = usb.backend.libusb1.get_backend(find_library=lambda x: "/usr/lib/libusb-1.0.so")
				dev = usb.core.find(..., backend=backend)
				yubikey = yubico.find_yubikey(debug=False)
				OpenPGP_configuration_data = subprocess.getoutput("ykman openpgp info")
				return OpenPGP_configuration_data
			except yubico.yubico_exception.YubicoError as e:
				return e.reason
				
		def get_OpenPGP_credential_data():
			try:
				backend = usb.backend.libusb1.get_backend(find_library=lambda x: "/usr/lib/libusb-1.0.so")
				dev = usb.core.find(..., backend=backend)
				yubikey = yubico.find_yubikey(debug=False)
				OpenPGP_credential_data = subprocess.getoutput("gpg --card-status")
				return OpenPGP_credential_data
			except yubico.yubico_exception.YubicoError as e:
				return e.reason
				
		def refreshData():
			config_data_textbox.configure(state="normal")
			OpenPGP_configuration_data_textbox.configure(state="normal")
			OpenPGP_credential_data_textbox.configure(state="normal")
			config_data_textbox.delete('1.0', END)
			config_data_textbox.insert('end', get_config_data())
			OpenPGP_configuration_data_textbox.delete('1.0', END)
			OpenPGP_configuration_data_textbox.insert('end', get_OpenPGP_configuration_data())
			OpenPGP_credential_data_textbox.delete('1.0', END)
			OpenPGP_credential_data_textbox.insert('end', get_OpenPGP_credential_data())
			config_data_textbox.configure(state="disabled")
			OpenPGP_configuration_data_textbox.configure(state="disabled")
			OpenPGP_credential_data_textbox.configure(state="disabled")
			
			config_data_textbox.place(relx=0.94, rely=0.1, anchor="ne")
			OpenPGP_configuration_data_textbox.place(relx=0.94, rely=0.4, anchor="ne")
			OpenPGP_credential_data_textbox.place(relx=0.94, rely=0.7, anchor="ne")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
				
		Label1 = ctk.CTkLabel(my_Frame, text="Setup Yubikey.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.04, rely=0.04, anchor="w")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Make sure that your Yubikey 5 NFC is connected.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.04, rely=0.09, anchor="w")
		
		refreshButton = ctk.CTkButton(my_Frame, text="Refresh", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=self.setup_Yubikey_v2)
		refreshButton.place(relx=0.88, rely=0.05, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		usbButton = ctk.CTkButton(my_Frame, text="Enable USB", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=enableUSB)
		usbButton.place(relx=0.26, rely=0.14, anchor="center")
		nfcEnableButton = ctk.CTkButton(my_Frame, text="Enable NFC", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=enableNFC)
		nfcEnableButton.place(relx=0.35, rely=0.14, anchor="w")
		nfcDisableButton = ctk.CTkButton(my_Frame, text="Disable NFC", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=disableNFC)
		nfcDisableButton.place(relx=0.35, rely=0.19, anchor="w")
		
		Labelconfig = ctk.CTkLabel(my_Frame, text="Yubikey config.:", text_color="white", fg_color="black", font=my_font)
		Labelconfig.place(relx=0.52, rely=0.05, anchor="nw")
		LabelOpenPGPconfig = ctk.CTkLabel(my_Frame, text="OpenPGP config.:", text_color="white", fg_color="black", font=my_font)
		LabelOpenPGPconfig.place(relx=0.52, rely=0.35, anchor="nw")
		Labelconfig = ctk.CTkLabel(my_Frame, text="Credentials for OpenPGP:", text_color="white", fg_color="black", font=my_font)
		Labelconfig.place(relx=0.52, rely=0.65, anchor="nw")
		
		refreshData()
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
		OpenPGPLabel = ctk.CTkLabel(my_Frame, text="Passkey:", text_color="white", fg_color="black", font=my_font)
		OpenPGPLabel.place(relx=0.05, rely=0.23, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		FIDOLabel_ = ctk.CTkLabel(my_Frame, text="Passkey PIN (min 6 digits, default PIN 123456):", text_color="white", fg_color="black", font=my_font)
		FIDOLabel_.place(relx=0.05, rely=0.28, anchor="w")
		
		FIDOLabel2 = ctk.CTkLabel(my_Frame, text="Current PIN:", text_color="white", fg_color="black", font=my_font)
		FIDOLabel2.place(relx=0.2, rely=0.32, anchor="e")
		
		currentFIDOPIN = ctk.CTkEntry(my_Frame, placeholder_text="******", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		currentFIDOPIN.place(relx=0.21, rely=0.32, anchor="w")
		
		CHANGEDPINLabel = ctk.CTkLabel(my_Frame, text="New PIN:", text_color="white", fg_color="black", font=my_font)
		CHANGEDPINLabel.place(relx=0.2, rely=0.37, anchor="e")
		
		changedFIDOPIN = ctk.CTkEntry(my_Frame, placeholder_text="******", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		changedFIDOPIN.place(relx=0.21, rely=0.37, anchor="w")
		
		Button2 = ctk.CTkButton(my_Frame, text="Reset Passkey", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=resetFIDOYubikey)
		Button2.place(relx=0.26, rely=0.43, anchor="center")
		
		tPINButton = ctk.CTkButton(my_Frame, text="Change Passkey PIN", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changePINFIDOYubikey)
		tPINButton.place(relx=0.48, rely=0.43, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
		OpenPGPLabel = ctk.CTkLabel(my_Frame, text="OpenPGP:", text_color="white", fg_color="black", font=my_font)
		OpenPGPLabel.place(relx=0.05, rely=0.51, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		autPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Touch policy for Auth (uncheck = policy Off):", variable=autPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		autPolicyCheckBox.place(relx=0.05, rely=0.56, anchor="w")
		autButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setautTouchYubikey)
		autButton.place(relx=0.48, rely=0.56, anchor="e")
		
		encPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Touch policy for Encr (uncheck = policy Off):", variable=encPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		encPolicyCheckBox.place(relx=0.05, rely=0.6, anchor="w")
		encButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setencTouchYubikey)
		encButton.place(relx=0.48, rely=0.6, anchor="e")
		
		sigPolicyCheckBox = ctk.CTkCheckBox(my_Frame, text="Touch policy for Sign (uncheck = policy Off):", variable=sigPolicy, onvalue="on", offvalue="off", text_color="white", fg_color="black", font=my_font)
		sigPolicyCheckBox.place(relx=0.05, rely=0.64, anchor="w")
		sigButton = ctk.CTkButton(my_Frame, text="Set policy", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=setsigTouchYubikey)
		sigButton.place(relx=0.48, rely=0.64, anchor="e")
		
		Button3 = ctk.CTkButton(my_Frame, text="Change OpenPGP name", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changeNameYubikey)
		Button3.place(relx=0.06, rely=0.77, anchor="w")
		
		Button4 = ctk.CTkButton(my_Frame, text="Change PINs OpenPGP", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=changePINsopenpgpYubikey)
		Button4.place(relx=0.06, rely=0.83, anchor="w")
		
		Button1 = ctk.CTkButton(my_Frame, text="Reset OpenPGP appli.", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=resetOpenPGPYubikey)
		Button1.place(relx=0.06, rely=0.89, anchor="w")
			
	def add_subkey_Yubikey(self):
		global clicked_privateSubKey
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/Yubikey5CBackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_font = ctk.CTkFont(family="Times", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
		def do_add_subkey_Yubikey():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In terminal that will open, type "toggle" and hit enter.\n2.Type "key 1" and "key 2" etc to toggle select/deselect subkey.\n        Selected subkey will be marked with "*"\n        Make sure only ONE subkey is selected before moving on to next step.\n3. Type "keytocard" to move the selected subkey to the Yubikey.\nIf the subkey is marked with \"usage: S\" then select \"(1) Signature key\".\nDeselect the \"Key 1\" by typing \"Key 1\" one more time.\n4. Repeat with all three subkeys.\n5. Type "save" and hit enter.\n6. Type "exit" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			# Make a backup of the key before moving the subkeys			
			# Export the private key and write to file in /home/user1/secure/keys
			key_file_path = filepathdestinationfolder + '/secure/keys/privateKey' + decoded_fingerprint + '.gpg'
			ascii_armored_private_key = gpg.export_keys(decoded_fingerprint, True, expect_passphrase=False)
			f2 = open(key_file_path, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			
			tk.messagebox.showinfo('Information', 'Connect the Yubikey and then press "OK"')
			time.sleep(3)
			
			goButton = ctk.CTkButton(my_Frame, text="Start", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=do_add_subkey_Yubikey_step2)
			goButton.place(relx=0.5, rely=0.8, anchor="center")
		
		def do_add_subkey_Yubikey_step2():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			my_font = ctk.CTkFont(family="Tahoma", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label = ctk.CTkLabel(my_Frame, text='In terminal that will open, type "toggle" and hit enter.\n2.Type "key 1" and "key 2" etc to toggle select/deselect subkey.\n        Selected subkey will be marked with "*"\n        Make sure only ONE subkey is selected before moving on to next step.\n3. Type "keytocard" to move the selected subkey to the Yubikey.\nIf the subkey is marked with \"usage: S\" then select \"(1) Signature key\".\nDeselect the \"Key 1\" by typing \"Key 1\" one more time.\n4. Repeat with all three subkeys.\n5. Type "save" and hit enter.\n6. Type "exit" and hit enter.', text_color="white", fg_color="black", font=my_font)
			Label.place(relx=0.5, rely=0.2, anchor="center")

			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			command= 'gpg --edit-key ' + decoded_fingerprint
			os.system("lxterminal -e 'bash -c \""+command+";bash\"'")
			
			goButton = ctk.CTkButton(my_Frame, text="Finish", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=do_add_subkey_Yubikey_step3)
			goButton.place(relx=0.5, rely=0.8, anchor="center")	
			
		def do_add_subkey_Yubikey_step3():
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			my_Frame.focus_set()
			my_Frame.focus_force()
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			# Delete the secret key with snubbed (moved) subkeys from the local keychain
			key = gpg.delete_keys(decoded_fingerprint, True, expect_passphrase=False)
			file_path = filepathdestinationfolder + '/secure/keys/privateKey' + decoded_fingerprint + '.gpg'
			# Import back the secret key from backup (with subkeys still intact)
			import_result = gpg.import_keys_file(file_path)
			gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_ULTIMATE')
			new_record = [decoded_fingerprint, "Transferred subkeys to Yubikey.", '']
			self.add_record(new_record)
			self.create_Yubikeymeny()
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		if path_to_USB_secure == 'Secure USB folder is not available':
			Button8 = ctk.CTkButton(self, text="Log in", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			Button8.place(relx=0.5, rely=0.5, anchor="center")
			Label = ctk.CTkLabel(self, text="Or", text_color="white", font=("Helvetica", 18), fg_color="black")
			Label.place(relx=0.5, rely=0.55, anchor="center")
			Button7 = ctk.CTkButton(self, text="Create a new user account", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.new_secureUSB_Pre)
			Button7.place(relx=0.5, rely=0.6, anchor="center")
		else:	
			Label1 = ctk.CTkLabel(my_Frame, text="Add subkeys to a Yubikey. IMPORTANT. Make sure there is a backup available for the secret key before moving the subkeys.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.05, rely=0.07, anchor="w")
			
			Label2 = ctk.CTkLabel(my_Frame, text="Select from what key to move subkey's.", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.05, rely=0.12, anchor="w")
			
			Label2 = ctk.CTkLabel(my_Frame, text="There are three subkeys that will be moved to the Yubikey. Password is needed for each.", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.05, rely=0.17, anchor="w")
			
			Label2 = ctk.CTkLabel(my_Frame, text="Toggle a key on (and off) with command \"Key 1\" and \"Key 2\" etc and then \"Encryption\", \"Signature\" and \"Authentication\".", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.05, rely=0.22, anchor="w")
			
			private_keys = gpg.list_keys(True)
					
			clicked = StringVar()
				
			List_fingerprints = []
			private_fingerprints_and_aliases = []
				
			for i in private_keys:
				List_fingerprints.append(i['fingerprint'])
				
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)	
			
			clicked.set(private_fingerprints_and_aliases[0])
			
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
			
			Label1 = ctk.CTkLabel(my_Frame, text="Make sure your Yubikey is connected.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.38, anchor="center")	
			
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			Label1 = ctk.CTkLabel(my_Frame, text="Select what key to move subkey\'s from:", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.42, rely=0.48, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.43, rely=0.48, anchor="w")
			
			Button = ctk.CTkButton(my_Frame, text="Move subkey\'s to Yubikey", text_color="white", fg_color="brown", border_width=2, border_color="white", font=my_font, command=do_add_subkey_Yubikey)
			Button.place(relx=0.63, rely=0.54, anchor="w")
							
	def newGPG_Subkey(self):		
		global PersonalGPGKey
		global GPG_button_color
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_newGPGSubkey():
			global clicked_privateSubKey
			
			clicked_privateSubKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateSubKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			key = gpg.add_subkey(decoded_fingerprint, algorithm='rsa4096', usage='sign', expire=combo.get())
			key = gpg.add_subkey(decoded_fingerprint, algorithm='rsa4096', usage='encrypt', expire=combo.get())
			key = gpg.add_subkey(decoded_fingerprint, algorithm='rsa4096', usage='auth', expire=combo.get())
			
			# Make a backup with the new supkeys
			privatekeyfilename = 'privateKey' + clicked_privateSubKey + ".gpg"
			full_path_private = "/home/user1/secure/keys/" + privatekeyfilename
			
			ascii_armored_private_key = gpg.export_keys(clicked_privateSubKey, True, expect_passphrase=False)
			
			f2 = open(full_path_private, 'w')
			f2.write(ascii_armored_private_key)
			f2.close()
			
			tk.messagebox.showinfo('Information', 'Subkey\'s has been added to local keychain.\nA new backup of the key has been placed in the secure archive.')
			new_record = [decoded_fingerprint, "Added new subkeys.", '']
			self.add_record(new_record)
			self.add_history("Added new subkeys to key: " + decoded_fingerprint)
			self.get_GnuPGKeys_compact(['_none__'])
		
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Create subkeys and add them to a private key", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.07, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="\"Encryption\", \"Signature\" and \"Authentication\"- subkeys will be created all at once.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.07, rely=0.19, anchor="w")
		Label3 = ctk.CTkLabel(my_Frame, text="The subkey's will be 4096 bits in length. Three years (\"3y\") is a good validity period for a subkey.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.07, rely=0.26, anchor="w")

		private_keys = gpg.list_keys(True)
				
		clicked = StringVar()
			
		List_fingerprints = []
		private_fingerprints_and_aliases = []
		
		privatekeysavailable = False
			
		for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					List_fingerprints.append(nkey['fingerprint'])
		
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)	
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
		my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
			
		if privatekeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select a key to add subkey\'s to:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.43, rely=0.43, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.44, rely=0.43, anchor="w")

			Label5 = ctk.CTkLabel(my_Frame, text="Select expiry date for subkey\'s:", font=my_font, text_color="white", fg_color="black")
			Label5.place(relx=0.43, rely=0.51, anchor="e")
			combo = ttk.Combobox(my_Frame, values = ["1y","3y"], justify='right')
			combo.current(1)
			combo.place(relx=0.65, rely=0.51, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Add subkeys", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_newGPGSubkey)
			Button2.place(relx=0.7, rely=0.57, anchor="w")
		else:
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the keychain. Create one now?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.5, anchor="center")
			Button = ctk.CTkButton(my_Frame, text="Or, import one?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=self.importGPG_Key)
			Button.place(relx=0.5, rely=0.58, anchor="center")
			
	def create_Yubikeymeny(self):
		global Yubikey_button_color
		self.setup_Yubikey_v2()
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		AddkeysYubikeyButton = ctk.CTkButton(self, text="My Yubikey", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.setup_Yubikey_v2)
		AddkeysYubikeyButton.place(relx=0.1, rely=0.2, anchor="center")
		
		RemovekeysYubikeyButton = ctk.CTkButton(self, text="Transfer subkeys", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.add_subkey_Yubikey)
		RemovekeysYubikeyButton.place(relx=0.25, rely=0.2, anchor="center")
		
		ImportkeyButton = ctk.CTkButton(self, text="Passkeys", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_FIDOmeny)
		ImportkeyButton.place(relx=0.4, rely=0.2, anchor="center")
		
		CheckYubikeyButton = ctk.CTkButton(self, text="", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Yubikeymeny)
		CheckYubikeyButton.place(relx=0.55, rely=0.2, anchor="center")
		
		EditYubikeyButton = ctk.CTkButton(self, text="", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Yubikeymeny)
		EditYubikeyButton.place(relx=0.7, rely=0.2, anchor="center")
		
		SetupYubikeyButton = ctk.CTkButton(self, text="", text_color="white", fg_color=Yubikey_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.create_Yubikeymeny)
		SetupYubikeyButton.place(relx=0.85, rely=0.2, anchor="center")
		
	def create_abouthelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		try:
			f = open("/home/user1/help/getstartedHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
		
	def create_gpghelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		try:
			f = open("/home/user1/help/gpgHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
		
	def create_yubikeyhelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		try:
			f = open("/home/user1/help/yubikeyHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
		
	def create_secusbhelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		try:
			f = open("/home/user1/help/securearchiveHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
	
	def create_digitalIDhelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		try:
			f = open("/home/user1/help/digitalIDHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
		
	def create_boltcardhelptextbox(self):
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="dark orange"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		try:
			f = open("/home/user1/help/boltcardHelp.txt", "r")
			file_content = f.read()
			f.close()
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', file_content)
		except OSError:
			my_text = ctk.CTkTextbox(my_Frame, width=1194, height=644, corner_radius=1, border_width=0, border_color="dark orange", border_spacing=2, fg_color="black", text_color="white", font=("Arial", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey75", scrollbar_button_hover_color="white")
			my_text.insert('end', '\n\n\nThere was a problem opening the helpfile')
		my_text.configure(state="disabled")
		my_text.place(relx=0.5, rely=0.5, anchor="center")
			
	def create_secusbtextbox(self):
		global path_to_USB_secure
		global filepathdestinationfolder
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		
		pathInheritanceMessage = str(filepathdestinationfolder) + "/secure/inheritanceMessage.txt"
		if os.path.isfile(pathInheritanceMessage):
			pathtobackg = str(filepathdestinationfolder) + '/images/Inheritance_background.JPG'
		else:
			pathtobackg = self.get_background_image()	
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if path_to_USB_secure == 'Secure USB folder is available':
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
			
			Label1 = ctk.CTkLabel(my_Frame, text="Passwords and accounts", text_color="white", font=("Helvetica", 24), fg_color="black")
			Label1.place(relx=0.27, rely=0.05, anchor="center")
			
			if color_setting == 'Dark':
				my_passwords = ctk.CTkTextbox(my_Frame, width=500, height=500, corner_radius=1, border_width=3, border_color="black", border_spacing=10, fg_color="black", text_color="white", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
			else:
				my_passwords = ctk.CTkTextbox(my_Frame, width=500, height=500, corner_radius=1, border_width=3, border_color="purple", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
			
			completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"

			f1 = open(completeName, "r")
			my_passwordContent = f1.read()
			f1.close()
			my_passwords.insert('end', my_passwordContent)
			my_font = ctk.CTkFont(family="Arial", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Button1 = ctk.CTkButton(my_Frame, text="Edit", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.create_editpasswordssecusbtextbox)
			Button1.place(relx=0.25, rely=0.92, anchor="center")
			my_passwords.configure(state="disabled")
			my_passwords.place(relx=0.48, rely=0.48, anchor="e")

			Label2 = ctk.CTkLabel(my_Frame, text="Wallets", text_color="white", font=("Helvetica", 24), fg_color="black")
			Label2.place(relx=0.75, rely=0.05, anchor="center")
			
			if color_setting == 'Dark':
				my_wallets = ctk.CTkTextbox(my_Frame, width=500, height=500, corner_radius=1, border_width=3, border_color="black", border_spacing=10, fg_color="black", text_color="white", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
			else:
				my_wallets = ctk.CTkTextbox(my_Frame, width=500, height=500, corner_radius=1, border_width=3, border_color="purple", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 18), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")

			completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"

			f2 = open(completeName, "r")
			my_walletsContent = f2.read()
			f2.close()
			my_wallets.insert('end', my_walletsContent)
			my_font = ctk.CTkFont(family="Arial", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Button1 = ctk.CTkButton(my_Frame, text="Edit", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.create_editwalletssecusbtextbox)
			Button1.place(relx=0.75, rely=0.92, anchor="center")
			my_wallets.configure(state="disabled")
			my_wallets.place(relx=0.52, rely=0.48, anchor="w")
	
	def easy_create_secusbtextbox(self):
		global path_to_USB_secure
		global filepathdestinationfolder
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="black"
		)
		
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathInheritanceMessage = str(filepathdestinationfolder) + "/secure/inheritanceMessage.txt"
		if os.path.isfile(pathInheritanceMessage):
			pathtobackg = str(filepathdestinationfolder) + '/images/Inheritance_background.JPG'
		else:
			pathtobackg = self.get_background_image()	
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		if path_to_USB_secure == 'Secure USB folder is available':
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
				
			Label1 = ctk.CTkLabel(my_Frame, text="Passwords", text_color="white", font=("Helvetica", 36), fg_color="black")
			Label1.place(relx=0.5, rely=0.05, anchor="center")
			
			if color_setting == 'Dark':
				my_passwords = ctk.CTkTextbox(my_Frame, width=1000, height=500, corner_radius=1, border_width=3, border_color="black", border_spacing=10, fg_color="black", text_color="white", font=("Helvetica", 25), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
			else:
				my_passwords = ctk.CTkTextbox(my_Frame, width=1000, height=500, corner_radius=1, border_width=3, border_color="purple", border_spacing=10, fg_color="white", text_color="black", font=("Helvetica", 25), wrap="word", activate_scrollbars = True, scrollbar_button_color="purple", scrollbar_button_hover_color="red")
			
			completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"

			f1 = open(completeName, "r")
			my_passwordContent = f1.read()
			f1.close()
			my_passwords.insert('end', my_passwordContent)
			my_font = ctk.CTkFont(family="Arial", size=32, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Button1 = ctk.CTkButton(my_Frame, text="Edit", text_color="white", corner_radius=5, font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.easy_create_editpasswordssecusbtextbox)
			Button1.place(relx=0.5, rely=0.92, anchor="center")
			my_passwords.configure(state="disabled")
			my_passwords.place(relx=0.5, rely=0.48, anchor="center")
			
	def create_historytextbox(self):
		global path_to_USB_secure
		global filepathdestinationfolder
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="blue"
		)
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		my_font = ctk.CTkFont(family="Courier", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if path_to_USB_secure == 'Secure USB folder is available':
			my_historyTextbox = ctk.CTkTextbox(my_Frame, width=1170, height=550, corner_radius=1, border_width=3, border_color="blue", border_spacing=10, fg_color="black", text_color="white", font=("Helvetica", 22), wrap="word", activate_scrollbars = True, scrollbar_button_color="grey", scrollbar_button_hover_color="navy blue")
		
			completeName = str(filepathdestinationfolder) + "/secure/log.txt"
			
			# Check if there is a log file. If not create one.
			if not os.path.isfile(completeName):
				f = open(completeName, 'w')
				f.write("Activity log:\n\n")
				f.close()
				
			f1 = open(completeName, "r")
			my_historyContent = f1.read()
			f1.close()
			my_historyTextbox.insert('end', my_historyContent)
			my_font = ctk.CTkFont(family="Arial", size=20, weight="normal", slant="roman", underline=False, overstrike=False)
			
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=System_button_color, border_width=2, border_color="white", font=my_font, command=self.create_meny) 
			backButton.place(relx=0.5, rely=0.93, anchor="center")
		
			deleteButton = ctk.CTkButton(my_Frame, text="Delete log", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.delete_history)
			deleteButton.place(relx=0.86, rely=0.93, anchor="w")
			my_historyTextbox.configure(state="disabled")
			my_historyTextbox.place(relx=0.01, rely=0.02, anchor="nw")
	
	def add_history(self, newEntry):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/log.txt"
		
		# Check if there is a log file. If not create one.
		if not os.path.isfile(completeName):
			f = open(completeName, 'w')
			f.write("Activity log:\n\n")
			f.close()
			
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%m/%d/%Y %H:%M")
		fullEntry = timeStamp + ': ' + newEntry + '\n'
		f2 = open(completeName, 'a')
		f2.write(fullEntry)
		return True
	
	def add_record(self, newEntryList):
		global filepathdestinationfolder
		completeName = filepathdestinationfolder + "/secure/keys/records/record" + newEntryList[0] + ".csv"
		st_path = filepathdestinationfolder + '/secure/keys/records/'
		if not os.path.isdir(st_path):
			os.makedirs(st_path)
		now = datetime.now() # current date and time
		timeStamp = now.strftime("%Y-%m-%d-%H:%M")
		
		new_entry = [timeStamp, newEntryList[1], newEntryList[2]]
		# Check if there is a record file for the specific key. If not create one.
		if not os.path.isfile(completeName):
			with open(completeName, 'w') as result:
				csvwriter = csv.writer(result)
				csvwriter.writerow(new_entry)
		else:
			with open(completeName, 'a') as result:
				csvwriter = csv.writer(result)
				csvwriter.writerow(new_entry)
		return True
			
	def delete_history(self):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/log.txt"
			
		answer = messagebox.askquestion('WARNING!', 'WARNING! Are you sure you want to delete the activity log?')
		if answer == 'yes':
			os.remove(completeName)
		self.create_historytextbox()
					
	def create_editpasswordssecusbtextbox(self):
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		# Read the content of the password fle and place it in a Text field (to be able to "get" it after edited
		if path_to_USB_secure == 'Secure USB folder is available':
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
				
			completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
			f1 = open(completeName, "r")
			my_passwordContent = f1.read()
			f1.close()
			if color_setting == 'Dark':
				self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
				self.textBox.config(insertbackground='white')
			else:
				self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
			self.textBox.insert("1.0", my_passwordContent)
			self.textBox.place(relx=0.5, rely=0.48, anchor="center")
			self.textBox.focus_set()
			self.textBox.focus_force()
			theinput = self.textBox.get("1.0",'end-1c')
			my_font = ctk.CTkFont(family="Arial", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Button22 = ctk.CTkButton(my_Frame, text="Save", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.do_edit_passwords)
			Button22.place(relx=0.5, rely=0.92, anchor="center")
		else:
			my_textbox.insert('end', 'You are not logged in. Passwords can\'t be displayed.')
	
	def easy_create_editpasswordssecusbtextbox(self):
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		# Read the content of the password fle and place it in a Text field (to be able to "get" it after edited
		if path_to_USB_secure == 'Secure USB folder is available':
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			#my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
			my_font = ctk.CTkFont(family="Arial", size=34, weight="normal", slant="roman", underline=False, overstrike=False)	
			Label1 = ctk.CTkLabel(my_Frame, text="Passwords", text_color="white", font=("Helvetica", 36), fg_color="black")
			Label1.place(relx=0.5, rely=0.05, anchor="center")
			
			completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"

			f1 = open(completeName, "r")
			my_passwordContent = f1.read()
			f1.close()
			my_font = ctk.CTkFont(family="Arial", size=28, weight="normal", slant="roman", underline=False, overstrike=False)
			
			if color_setting == 'Dark':
				self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
				self.textBox.config(insertbackground='white')
			else:
				self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
			self.textBox.insert("1.0", my_passwordContent)
			self.textBox.place(relx=0.5, rely=0.48, width=1000, height=500, anchor="center")
			self.textBox.focus_set()
			self.textBox.focus_force()
			theinput = self.textBox.get("1.0",'end-1c')
			
			my_font = ctk.CTkFont(family="Arial", size=32, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Button22 = ctk.CTkButton(my_Frame, text="Save", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.easy_do_edit_passwords)
			Button22.place(relx=0.5, rely=0.92, anchor="center")
		else:
			my_textbox.insert('end', 'You are not logged in. Passwords can\'t be displayed.')
				
	def do_edit_passwords(self):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
		f2 = open(completeName, 'w')
		f2.write(self.textBox.get('1.0', 'end'))
		f2.close()
		tk.messagebox.showinfo('Information', 'Passwords updated.')
		self.create_secusbtextbox()
	
	def easy_do_edit_passwords(self):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/passwords.txt"
		f2 = open(completeName, 'w')
		f2.write(self.textBox.get('1.0', 'end'))
		f2.close()
		self.create_meny()
		
	def decrypt_from_SecUSB(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()	
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			Label1 = ctk.CTkLabel(my_Frame, text="Decrypt a textfile from a USB-device", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.14, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			Labelinf = ctk.CTkLabel(my_Frame, text="Connect a USB-device with the encrypted file.", text_color="white", fg_color="black", font=my_font)
			Labelinf.place(relx=0.5, rely=0.24, anchor="center") 

			Label2inf = ctk.CTkLabel(my_Frame, text="If the file is signed and you have his/her public key the signature will be also be checked.", text_color="white", fg_color="black", font=my_font)
			Label2inf.place(relx=0.5, rely=0.32, anchor="center")
			
			ButtonRestore= ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.decrypt_message, 'none'))
			ButtonRestore.place(relx=0.5, rely=0.44, anchor="center")
			
	def decrypt_message(self, full_path):
		global filepathdestinationfolder
		global path_to_USB_secure
		global SecUSB_button_color
		global theinput 
		global clicked_publicKey
		global PersonalGPGKey
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
				
		def save_to_archive():
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			theinput = self.textBox.get('1.0','end-1c')
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(str(theinput))
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the Secure archive')
			self.create_SecUSBmeny()
		
		def scan_message():
			ans = ['none', 'none']
			theinput = self.textBox.get('1.0','end-1c')
			lines = theinput.splitlines()
			for i in range(0, len(lines)):
				line = lines[i]
				if line == '__Seed:':
					ans[0] = lines[i+1]
				if line == '__Password:':
					ans[1] = lines[i+1]
			return ans
		
		def add_icon(walletname):
			pathtopicture = "/home/user1/images/defaultWalletIcon.jpg"
			pathtopicturearchivelocation = filepathdestinationfolder + "/secure/wallets/" + walletname + ".jpg"
			if os.path.isfile(pathtopicture):
				img_open = Image.open(pathtopicture)
				img_open.save(pathtopicturearchivelocation)
			return True
			
		def add_bitcoinwallet(walletdata):
			USER_INP = simpledialog.askstring(title="Name required!", prompt="Name for wallet (max 30 characters:")
				
			if USER_INP == "" or USER_INP == " ":
				USER_INP = "Wallet" + timeStamp
			
			USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
			
			USER_INP2 = simpledialog.askstring(title="Description.", prompt="Description for the new Bitcoin wallet (optional):")
			
			if USER_INP2 == "" or USER_INP2 == " ":
				USER_INP2 = "-"
			
			USER_INP2_tr = USER_INP2[:100] if len(USER_INP2) > 100 else USER_INP2
			
			password_bool = False
			password = "none"
			
			if walletdata[1] != 'none':
				password = walletdata[1]
				password_bool = True
							
			completeName = filepathdestinationfolder + "/secure/wallets/bitconwallets.csv"
			# Generate mnemonic from bitconlib.mnemonic module 
			mnemgenerator = bitcoinlibMnemonic()
			seed_words = bitcoinlibMnemonic().generate()
				
			thedate = str(date.today())
			new_bitcoinwallet = [USER_INP_tr, USER_INP2_tr, thedate, walletdata[0], len(walletdata[0].split()), password_bool, password]
			
			if not os.path.isfile(completeName):
				f = open(completeName, 'w')
				writer = csv.writer(f)
				writer.writerow(new_bitcoinwallet)
				f.close()
			else:
				f = open(completeName, 'a')
				writer = csv.writer(f)
				writer.writerow(new_bitcoinwallet)
				f.close()
			
			completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
			f2 = open(completeName, 'a')
			
			if password_bool:
				f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + walletdata[0] + "\n\n   Password: " + password + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
			else:
				f2.write("\nName: " + USER_INP_tr + "\n\n   Seed words/key: " + walletdata[0] + "\n\n   Comment: " + USER_INP2_tr + "\n___________________________________\n")
			
			f2.close()
			add_icon(USER_INP_tr)
			self.add_history("Created new Bitcoin wallet " + USER_INP_tr + " (" + USER_INP2_tr + ")")
			
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			theinput = self.textBox.get('1.0','end-1c')
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(str(theinput))
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the USB-device')
			self.create_SecUSBmeny()
				
		def do_new_encrypt_message():
			global clicked_privateKey
			global clicked_publicKey
			decoded_publicfingerprint = ['N/A']
			encr_pass = False
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			if validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
				encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
				
				USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type will be added automatically):")
				
				# Write the encrypted file to disk
				c = open(outputdir + '/' + USER_INP + '.txt.asc', 'w')
				c.write(str(encrypted_data))
				c.close()
				if encrypted_data.ok:
					messagebox.showinfo('Information', 'Message has been encrypted and stored at '+ outputdir)
				else:
					messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")	
				self.create_SecUSBmeny()
		
		def do_insert_from_QR_code():
			self.textBox.insert(INSERT, QR_get())
		
		def QR_get():
			global filepathdestinationfolder
			completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
			if os.path.isfile(completeNameQRfile):
				os.remove(completeNameQRfile)
			subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
			link_to_signature_data = "/home/user1/secure/QRsignaturefile.txt"
				
			if os.path.isfile(link_to_signature_data):
				try:
					f = open(link_to_signature_data, "r")
					file_content = f.read()
					f.close()
					return file_content
				except OSError:
					return f"Unable to read QR with camera"
			return f"Something went wrong, try again"
			
		def do_insert_from_clipboard():
			self.textBox.insert(INSERT, self.clipboard_get())
				
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		if path_to_USB_secure == 'Secure USB folder is available':
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			# Select file with message to decrypt
			if full_path == 'none':
				result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
				if not result:
					self.decrypt_from_SecUSB()
					return
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select file to decrypt.')
				time.sleep(2)
				filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			else:
				filepathSourcefile = full_path
				
			stream = open(filepathSourcefile, 'rb')
			
			try:
				data_ = gpg.decrypt_file(stream)

				if data_.ok:
					gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')

					private_keys = gpg.list_keys(True)
					public_keys = gpg.list_keys()
							
					clicked = StringVar()
					clicked2 = StringVar()
				
					List_fingerprints = []
					List_publicfingerprints = []
					private_fingerprints_and_aliases = []
					public_fingerprints_and_aliases = []
					
					privatekeysavailable = False
					publickeysavailable = False
					
					# Dont display the private key that is only intended for Offline device encryption/decryption
					for nkey in private_keys:
						if nkey['fingerprint'] != PersonalGPGKey:
							List_fingerprints.append(nkey['fingerprint'])
						
					if private_keys:
						private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
						clicked.set(private_fingerprints_and_aliases[0])
						privatekeysavailable = True
								
					for i2 in public_keys:
						if i2['fingerprint'] != PersonalGPGKey:
							List_publicfingerprints.append(i2['fingerprint'])
						
					if List_publicfingerprints:
						public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
						clicked2.set(public_fingerprints_and_aliases[0])
						publickeysavailable = True
					
					if not List_fingerprints:	
						Button = ctk.CTkButton(my_Frame, text="There are no public keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
						Button.place(relx=0.5, rely=0.5, anchor="center")
					else:
						Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign message (FROM):", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.58, rely=0.82, anchor="e")

						drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
						drop1.config(width=42)
						drop1.place(relx=0.59, rely=0.82, anchor="w")

						Label2 = ctk.CTkLabel(my_Frame, text="Select public key to encrypt message (TO):", text_color="white", fg_color="black", font=my_font)
						Label2.place(relx=0.58, rely=0.87, anchor="e")

						drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
						drop2.config(width=42)
						drop2.place(relx=0.59, rely=0.87, anchor="w")
						
						color_setting = 'none'
						completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
						my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
					
						try:
							with open(completeName, 'r') as file:
								csvfile = csv.reader(file)
								for lines in csvfile:
									if lines:	
										color_setting = lines[1]
						except FileNotFoundError:
							logged_in_user = '<no settings file found>'
					
						# Type content in textbox and select key before encrypting
						if color_setting == 'Dark':
							self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
							self.textBox.config(insertbackground='white')
						else:
							self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
						
						self.textBox.insert("1.0", data_.data)
						self.textBox.place(relx=0.5, rely=0.39, height=500, width=1050, anchor="center")
						
						Button44 = ctk.CTkButton(my_Frame, text="Paste from QR-code ", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_insert_from_QR_code)
						Button44.place(relx=0.33, rely=0.94, anchor="w")
						
						Button11 = ctk.CTkButton(my_Frame, text="Save to Secure archive", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_archive)
						Button11.place(relx=0.56, rely=0.94, anchor="center")
						
						Button11 = ctk.CTkButton(my_Frame, text="Save to USB-device", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_USB)
						Button11.place(relx=0.73, rely=0.94, anchor="center")
	
						Button22 = ctk.CTkButton(my_Frame, text="Encrypt and Sign", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_new_encrypt_message)
						Button22.place(relx=0.88, rely=0.94, anchor="center")
						
						Button33 = ctk.CTkButton(my_Frame, text="Paste from clipboard", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_insert_from_clipboard)
						Button33.place(relx=0.06, rely=0.81, anchor="w")
						
						my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", weight="bold", underline=False, overstrike=False)
						
						if data_.trust_level is not None and data_.trust_level >= 1 and self.lookup_Alias_absolut(data_.fingerprint) != "None":
							Labelv = ctk.CTkLabel(my_Frame, text="Signed by: " + self.lookup_Alias(data_.fingerprint), text_color="light green", fg_color="black", font=my_font)
							Labelv.place(relx=0.06, rely=0.86, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="bold", underline=False, overstrike=False)
							Labelv = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
							Labelv.place(relx=0.06, rely=0.90, anchor="w")
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", weight="bold", underline=False, overstrike=False)
							Labelv2 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
							Labelv2.place(relx=0.06, rely=0.96, anchor="w")
						elif data_.trust_level is not None and data_.trust_level >= 1:
							Labelv = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
							Labelv.place(relx=0.06, rely=0.87, anchor="w")
							Labelv2 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
							Labelv2.place(relx=0.06, rely=0.92, anchor="w")
						else:
							Labelv = ctk.CTkLabel(my_Frame, text="Signature could not be verified!", text_color="pink", fg_color="black", font=my_font)
							Labelv.place(relx=0.05, rely=0.92, anchor="w")
						
						ifwallet = scan_message()
						if ifwallet[0] != 'none':
							answer = messagebox.askquestion('Information!', 'This looks like it contains a Bitcoin wallets secret seed. Do you want to import it?')
							if answer == 'yes':
								add_bitcoinwallet(ifwallet)
								messagebox.showinfo('Information', "Bitcoin wallet has been imported")
						theinput = self.textBox.get("1.0",'end-1c')
				else:
					messagebox.showinfo('Information', data_.status)
					self.create_SecUSBmeny()
			except FileNotFoundError:
					messagebox.showinfo("Information", "No settings file found.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
				
	def encrypt_message(self, messagedata):
		global filepathdestinationfolder
		global path_to_USB_secure
		global SecUSB_button_color
		global theinput 
		global clicked_privateKey
		global clicked_publicKey
		
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		logged_in_user = ''
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		now = datetime.now() # current date and time
		
		def date():
			global timeDateString
			dayofmonth = now.strftime("%d")
			month = now.strftime("%B")
			year = now.strftime("%Y")
			
			hour = now.strftime("%H")
			minute = now.strftime("%M")
			timeDateString = dayofmonth + " of " + month + ' ' + year + ' at ' + hour + ':' + minute
			return timeDateString
			
		def load_message_to_encrypt():
			messagebox.showinfo("Information", "Select the file to load text from.")
			filepathSourcefile = filedialog.askopenfilename(initialdir='/home/user1/secure')
			try:
				f = open(filepathSourcefile, 'r', encoding='utf-8')
				file_content = f.read()
				f.close()
				self.textBox.delete('1.0', END)
				self.textBox.insert('1.0', file_content)
				self.textBox.place(relx=0.5, rely=0.39, height=500, width=1050, anchor="center")
				theinput = self.textBox.get('1.0','end-1c')
				self.textBox.focus_set()
				self.textBox.focus_force()
			except OSError:
				messagebox.showinfo('Information', 'There was a problem reading the file.')
		
		def load_wallet_messagedata():
			# Insert data from messagedata
			if messagedata[2] != '_none_':
				theinput = '\n\n\n############ SYSTEM DATA BLOCK ### DO NOT EDIT ####################\n\n__Seed:\n' + messagedata[1] +'\n\n__Password:\n' + messagedata[2] + "\n\nDerivation path: 84'/0'/0'\n\n####################### DO NOT EDIT BLOCK ##########################\n"
			else:
				theinput = '\n\n\n############ SYSTEM DATA BLOCK ### DO NOT EDIT ####################\n\n__Seed:\n' + messagedata[1] + "\n\nDerivation path: 84'/0'/0'\n\n####################### DO NOT EDIT BLOCK ##########################\n"
				
			self.textBox.insert(INSERT, theinput)
			
		def load_message_to_encrypt_USB():
			result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
			if not result:
				self.encrypt_message(['none', 'none', '_none_'])
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel("Information", "Select the file to load text from.")
			if not result:
				self.encrypt_message(['none', 'none', '_none_'])
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			try:
				f = open(filepathSourcefile, 'r', encoding='utf-8')
				file_content = f.read()
				f.close()
				self.textBox.delete('1.0', END)
				self.textBox.insert('1.0', file_content)
				self.textBox.place(relx=0.5, rely=0.39, height=500, width=1050, anchor="center")
				theinput = self.textBox.get('1.0','end-1c')
				self.textBox.focus_set()
				self.textBox.focus_force()
			except OSError:
				messagebox.showinfo('Information', 'There was a problem reading the file.')
				
		def do_encrypt_message():
			global clicked_privateKey
			global clicked_publicKey
			encr_pass = False
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			decoded_publicfingerprint = ['N/A']
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encrypted_data = gpg.encrypt(self.textBox.get('1.0', 'end'), decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the directory where you want to save the signed and encrypted file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
				
				USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".asc\" will be added automatically):")
				
				# Write the encrypted file to disk
				c = open(outputdir + '/' + USER_INP + '.txt.asc', 'w')
				c.write(str(encrypted_data))
				c.close()
				if encrypted_data.ok:
					messagebox.showinfo('Information', 'Message has been encrypted and stored at '+ outputdir)
				else:
					messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")	
				self.create_SecUSBmeny()
		
		def save_to_archive():
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			theinput = self.textBox.get('1.0','end-1c')
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(str(theinput))
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the Secure archive')
			self.create_SecUSBmeny()
		
		def do_insert_from_QR_code():
			self.textBox.insert(INSERT, QR_get())
		
		def do_insert_from_messagedata():
			self.textBox.delete('1.0', END)
			self.textBox.insert('1.0', messagedata[1])
			
		def QR_get():
			global filepathdestinationfolder
			completeNameQRfile = str(filepathdestinationfolder) + "/secure/QRsignaturefile.txt"
			if os.path.isfile(completeNameQRfile):
				os.remove(completeNameQRfile)
			subprocess.run(['/home/user1/myenv/bin/python /home/user1/scanQRforSigning.py'], shell=True)
			link_to_signature_data = "/home/user1/secure/QRsignaturefile.txt"
				
			if os.path.isfile(link_to_signature_data):
				try:
					f = open(link_to_signature_data, "r")
					file_content = f.read()
					f.close()
					return file_content
				except OSError:
					return f"Unable to read QR with camera"
			return f"Something went wrong, try again"
			
		def do_insert_from_clipboard():
			self.textBox.insert(INSERT, self.clipboard_get())
			
		pathtobackg = self.get_background_image()	
		
		if path_to_USB_secure == 'Secure USB folder is available':
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				
			private_keys = gpg.list_keys(True)
			public_keys = gpg.list_keys()
					
			clicked = StringVar()
			clicked2 = StringVar()
		
			List_fingerprints = []
			List_publicfingerprints = []
			# Add groups first in list of public keys
			self.cleanupgroups()
			
			if os.path.isfile(pathtogroupsfile):
				try:
					with open(pathtogroupsfile, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines[1] not in List_publicfingerprints:	
								List_publicfingerprints.append(lines[1])
				except FileNotFoundError:
					print("Could not open groups file")
				
			private_fingerprints_and_aliases = []
			public_fingerprints_and_aliases = []
			
			privatekeysavailable = False
			publickeysavailable = False
			
			for nkey in private_keys:
				if nkey['fingerprint'] != PersonalGPGKey:
					List_fingerprints.append(nkey['fingerprint'])
				
			if private_keys:
				private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
				clicked.set(private_fingerprints_and_aliases[0])
				privatekeysavailable = True
						
			for i2 in public_keys:
				if i2['fingerprint'] != PersonalGPGKey:
					List_publicfingerprints.append(i2['fingerprint'])
				
			if List_publicfingerprints:
				public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
				clicked2.set(public_fingerprints_and_aliases[0])
				publickeysavailable = True
			
			if not List_fingerprints:	
				Button = ctk.CTkButton(my_Frame, text="There are no private keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
				Button.place(relx=0.5, rely=0.5, anchor="center")
			else:
				clicked.set(private_fingerprints_and_aliases[0])
				
				Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign message (FROM):", text_color="white", fg_color="black", font=my_font)
				Label1.place(relx=0.59, rely=0.82, anchor="e")

				drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
				drop1.config(width=42)
				drop1.place(relx=0.6, rely=0.82, anchor="w")
				
				Label2 = ctk.CTkLabel(my_Frame, text="Select key to encrypt message (TO):", text_color="white", fg_color="black", font=my_font)
				Label2.place(relx=0.59, rely=0.87, anchor="e")

				drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
				drop2.config(width=42)
				drop2.place(relx=0.6, rely=0.87, anchor="w")
				
				completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:	
								logged_in_user = lines[0]
				except FileNotFoundError:
					logged_in_user = '<no settings file found>'
				
				color_setting = 'none'
				completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			
				try:
					with open(completeName, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines:	
								color_setting = lines[1]
				except FileNotFoundError:
					logged_in_user = '<no settings file found>'
					
				# Type content in textbox and select key before encrypting
				if color_setting == 'Dark':
					self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
					self.textBox.config(insertbackground='white')
				else:
					self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 16), wrap = 'word', undo = True)
				
				self.textBox.insert("1.0", '\nFrom: ' + logged_in_user + '\nTo: \nDate: ' + date() + '\n\nMessage: \n-------------------------------------------------------\n')
				self.textBox.place(relx=0.5, rely=0.39, height=500, width=1050, anchor="center")
				# Check if there is a message to include
				if messagedata[0] == "wallet":
					load_wallet_messagedata()
				elif messagedata[0] == "text":
					do_insert_from_messagedata()
				else:
					theinput = self.textBox.get("1.0",'end-1c')
				self.textBox.focus_set()
				self.textBox.focus_force()
				Button10 = ctk.CTkButton(my_Frame, text="Save to Secure archive", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_archive)
				Button10.place(relx=0.38, rely=0.94, anchor="center")	
				Button11 = ctk.CTkButton(my_Frame, text="Load from Secure archive", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=load_message_to_encrypt)
				Button11.place(relx=0.56, rely=0.94, anchor="center")	
				Button11 = ctk.CTkButton(my_Frame, text="Load from USB-file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=load_message_to_encrypt_USB)
				Button11.place(relx=0.73, rely=0.94, anchor="center")	
				Button22 = ctk.CTkButton(my_Frame, text="Encrypt and Sign", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_encrypt_message)
				Button22.place(relx=0.88, rely=0.94, anchor="center")
				Button33 = ctk.CTkButton(my_Frame, text="Paste from clipboard", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_insert_from_clipboard)
				Button33.place(relx=0.06, rely=0.81, anchor="w")
				Button44 = ctk.CTkButton(my_Frame, text="Paste from QR-code ", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_insert_from_QR_code)
				Button44.place(relx=0.06, rely=0.86, anchor="w")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
		
	def create_editwalletssecusbtextbox(self):
		global filepathdestinationfolder
		global path_to_USB_secure
		global SecUSB_button_color
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		# Read the content of the password fle and place it in a Text field (to be able to "get" it after edited
		if path_to_USB_secure == 'Secure USB folder is available':
			color_setting = 'none'
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							color_setting = lines[1]
			except FileNotFoundError:
				logged_in_user = '<no settings file found>'
				
			completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
			f1 = open(completeName, "r")
			my_passwordContent = f1.read()
			f1.close()
			if color_setting == 'Dark':
				self.textBox = Text(my_Frame, bg = "black", fg = "white", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
				self.textBox.config(insertbackground='white')
			else:
				self.textBox = Text(my_Frame, bg = "white", fg = "black", bd = 4, font=("Helvetica", 15), wrap = 'word', undo = True)
			self.textBox.insert("1.0", my_passwordContent)
			self.textBox.place(relx=0.5, rely=0.48, anchor="center")
			self.textBox.focus_set()
			self.textBox.focus_force()
			theinput = self.textBox.get("1.0",'end-1c')
			my_font = ctk.CTkFont(family="Arial", size=18, weight="normal", slant="roman", underline=False, overstrike=False)
			Button22 = ctk.CTkButton(my_Frame, text="Save", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.do_edit_wallets)
			Button22.place(relx=0.5, rely=0.92, anchor="center")
		else:
			my_textbox.insert('end', 'You are not logged in. Passwords can\'t be displayed.')
	
	def do_edit_wallets(self):
		global filepathdestinationfolder
		completeName = str(filepathdestinationfolder) + "/secure/wallets/wallets.txt"
		f2 = open(completeName, 'w')
		f2.write(self.textBox.get('1.0', 'end'))
		f2.close()
		tk.messagebox.showinfo('Information', 'Wallets file updated.')
		self.create_secusbtextbox()
		
	def importGPG_Key(self):
		global path_to_USB_secure
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Importing a private or public key (or a group of keys) from a USB-device.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select a file with the key to import. For importing a private key a password might be required.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.24, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="(A private key will be imported in two instances, as a public and a private key, to backup both.)", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.32, anchor="center")
		
		startButton = ctk.CTkButton(self, text="Start", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=self.importGPG_Key_step2)
		startButton.place(relx=0.5, rely=0.55, anchor="center")
	
	def importGPG_Key_step2(self):
		answer = messagebox.askquestion('Information!', 'Are the key(s) to import on an external USB-device?')
		if answer == 'yes':
			result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
			if not result:
				self.importGPG_Key()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel("Information", "Select the file with the key(s).")
			if not result:
				self.importGPG_Key()
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
		else:
			messagebox.showinfo("Information", "Select the file with the key(s).")	
			filepathSourcefile = filedialog.askopenfilename(initialdir='/home/user1/secure')
		
		self.importGPG_Key_step3(filepathSourcefile, 1, [])
	
	def get_key_validity(self, key_fingerprint):
			web_level_judgement = ['u', 'N/A']
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			public_keys = gpg.list_keys()
			# key_fingerprint could be more than one. Loop through and aggregate if all are fullt validated
			if len(key_fingerprint) > 1:
				web_level_judgement = ['f', 'N/A']
				for i in key_fingerprint:
					for ii in public_keys:
						if i == ii['fingerprint']:
							if ii['trust'] == 'q' or ii['trust'] == '-' or ii['trust'] == ' ' or ii['trust'] == 'n' or ii['trust'] == 'm':
								web_level_judgement[0] = 'g'
			else:
				for iii in public_keys:
					if iii['fingerprint'] == key_fingerprint[0]:
						web_level = iii['trust'] 
						if web_level == 'q' or  web_level == '-' or  web_level == ' ':
							web_level_judgement[0] = 'u'
							web_level_judgement[1] = 'Not enough information to calculate.'
						elif web_level == 'n':
							web_level_judgement[0] = 'n'
							web_level_judgement[1] = 'Never trust this key.'
						elif web_level == 'm':
							web_level_judgement[0] = 'm'
							web_level_judgement[1] = 'Marginally trusted.'
						elif web_level == 'f' or web_level == 'u':
							web_level_judgement[0] = 'f'
							web_level_judgement[1] = 'Fully trusted.'				 	
			return web_level_judgement
				
	def importGPG_Key_step3(self, filepathSourcefile, this_key_count, all_fingerprints):
		global path_to_USB_secure
		global filepathdestinationfolder
		global key_email, key_alias, fingerprint
		global list_of_fingerprints
		number_of_keys = 0
		list_of_fingerprints = []
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		List_Levels = ['TRUST_UNDEFINED', 'TRUST_NEVER', 'TRUST_MARGINAL', 'TRUST_FULLY']
		no_group = '----------------'
		trust_level = 'TRUST_UNDEFINED'
		key_alias = ''
		
		more_info_text = "Trust levels:\nThe trust level is how responsible this key owner is in signing other keys.\nExample.\nIf you set trust level on \"Key 1\" to \"TRUST_FULLY\" it means that when you import \"Key 2\" and that key is signed by \"Key 1\", the web-of-trust will tell you that the KEY is \"Fully trusted\".\nNOTE: This has nothing to do with whether the owner for \"Key 2\" is trustworthy (in also signing keys). The level \"TRUST_FULLY\" is only for those key owners that you KNOW always first check a persons PASSPORT or PHOTO ID etc before signing ANYTHING. It could be the HR-department of your company or the President of the chess club etc.\nIf you fully or marginally trust the owner you also need to sign the key after you import it (for the Web-of-trust calculations to work)!"
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
			
		def get_data_for_key(key_fingerprint):
			global key_email, key_alias
			trust_level_marginal = False
			trust_level_Full = False
			recommended_trust_level = 'TRUST_UNDEFINED'
			key_email = '<Undefined>'
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			
			public_keys = gpg.list_keys()
				
			# Also grab the key owner full name from the key ID
			for iii in public_keys:	
				if iii['fingerprint'] == key_fingerprint:
					key_email_list = iii['uids']
					key_email = key_email_list[0]
					key_alias_list = key_email.split("<")
					key_alias = key_alias_list[0][:42]
			
			# Get the (GPG calculated) validity for the key, we might need to go into subkeys here to find web-of-trust validity!?!
			key_fingerprint_list = ['N/A']
			key_fingerprint_list[0] = key_fingerprint
			key_validity = self.get_key_validity(key_fingerprint_list)
							 	
			return key_validity
		
		def limitSizeAliasname(*args):
			value = users_alias_name_var.get()
			if len(value) > 42: users_alias_name_var.set(value[:42])
			
		def do_importGPG_Key():
			global filepathdestinationfolder
			global fingerprint
			global list_of_fingerprints
			pathtogroupsfile = "/home/user1/secure/groups.csv"
			already_there = False
			the_alias = aliasEntry.get()
			new_Alias = [fingerprint, the_alias]
			the_trust = clicked.get()
			file_ = filepathdestinationfolder + "/secure/Alias.csv"	
			
			# Add to any groups if requested
			# Check if fingerprint is already in selected group
			if clicked2.get() != no_group:
				already_added = self.check_if_already_in_group(clicked2.get(), fingerprint)
				if not already_added:
					new_entry = ['none', clicked2.get(), fingerprint]
					if os.path.isfile(pathtogroupsfile):
						with open(pathtogroupsfile, 'a') as result:
							csvwriter = csv.writer(result)
							csvwriter.writerow(new_entry)
					
			if clicked3.get() != no_group:
				already_added = self.check_if_already_in_group(clicked3.get(), fingerprint)
				if not already_added:
					new_entry = ['none', clicked3.get(), fingerprint]
					if os.path.isfile(pathtogroupsfile):
						with open(pathtogroupsfile, 'a') as result:
							csvwriter = csv.writer(result)
							csvwriter.writerow(new_entry)
					
			if clicked4.get() != no_group:
				already_added = self.check_if_already_in_group(clicked4.get(), fingerprint)
				if not already_added:
					new_entry = ['none', clicked4.get(), fingerprint]
					if os.path.isfile(pathtogroupsfile):
						with open(pathtogroupsfile, 'a') as result:
							csvwriter = csv.writer(result)
							csvwriter.writerow(new_entry)
					
			# Check if alias file exists. If not create it
			if not os.path.isfile(file_):
				f = open(file_, 'w')
				writer = csv.writer(f)
				writer.writerow(new_Alias)
				f.close()
			else:
				try:
					f = open(file_, 'r')
					for row in csv.reader(f):
						if row[1] == aliasEntry.get() and row[0] != fingerprint: # Only mod the new alias suggested if its not for the row getting replaceed anyway
							the_alias = the_alias[:36] + ' (dup)'
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
				new_Alias = [fingerprint, the_alias]
				try:
					# Remove row for fingerprint if it already exists in Alias-file
					self.remove_Alias(fingerprint)
					f = open(file_, 'a')
					writer = csv.writer(f)
					writer.writerow(new_Alias)
					f.close()
				except FileNotFoundError:
					messagebox.showinfo("Information", "No Alias file found.")
			
			# Check if it was a private or public key that was imported and make backup accordingly
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			gpg.trust_keys(list_of_fingerprints[this_key_count-1], trustlevel=the_trust)
			
			private_keys = gpg.list_keys(True)
			public_keys = gpg.list_keys()
			
			k_found = False
			for i in private_keys:
				if i['fingerprint'] == list_of_fingerprints[this_key_count-1]:
					k_found = True
					ascii_armored_private_key = gpg.export_keys(i['fingerprint'], True, expect_passphrase=False)
					privateKeyName = filepathdestinationfolder + '/secure/keys/privateKey' + i['fingerprint'] + '.gpg' 
					f3 = open(privateKeyName, 'w')
					f3.write(ascii_armored_private_key)
					f3.close()
			
			if not k_found:
				for i2 in public_keys:
					if i2['fingerprint'] == list_of_fingerprints[this_key_count-1]:
						ascii_armored_public_key = gpg.export_keys(i2['fingerprint']) 
						completeName = filepathdestinationfolder + '/secure/keys/publicKey' + i2['fingerprint'] + '.gpg'
						f2 = open(completeName, 'w')
						f2.write(ascii_armored_public_key)
						f2.close()
					
			new_record = [str(list_of_fingerprints[this_key_count-1]), "Imported key.", "Trust level: " + the_trust]
			self.add_record(new_record)
			self.add_history("Imported:" + list_of_fingerprints[this_key_count-1] + ". Trust lvl: " + the_trust)
			tk.messagebox.showinfo('Information', "Key sucessfully imported.\n\nKey ownertrust:\n  " + the_trust + ".")
			if this_key_count >= len(list_of_fingerprints):
				self.get_GnuPGKeys_compact(['_none__'])
			else:
				self.importGPG_Key_step3(" ", this_key_count + 1, list_of_fingerprints)
							 					
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		# Do import of one or more keys (only done once)
		if this_key_count == 1:
			private_keys_fingerprints = []
			scanned_keys_fingerprints = []
			private_keys = gpg.list_keys(True)
			scanned_keys = gpg.scan_keys(filepathSourcefile)
			
			for nkey in private_keys:
				private_keys_fingerprints.append(nkey['fingerprint'])
			
			for skey in scanned_keys:
				scanned_keys_fingerprints.append(skey['fingerprint'])
			tmp_list = ['none']
			string_found_private_keys = ''
			_found = False
			for i in private_keys_fingerprints:
				tmp_list[0] = i
				if set(tmp_list).issubset(scanned_keys_fingerprints):
					alias_or_fingerprint = self.get_Aliases(tmp_list)
					string_found_private_keys = string_found_private_keys + alias_or_fingerprint[0] + '\n'
					_found = True
			if _found: 
				answer = messagebox.askquestion('WARNING!', 'SECURITY WARNING.\nKey(s) intended for import is duplicate/part for existing PRIVATE key(s). If you are trying to import a private key it will replace your current one. If you are importing a public part of the private key it will merge any new signatures to existing one. Affected keys are:\n\n' + string_found_private_keys + '\n\nDo you want to import anyway?')
				if answer == 'yes':
					import_result = gpg.import_keys_file(filepathSourcefile)
					list_of_fingerprints = import_result.fingerprints
					number_of_keys = import_result.count
				else:
					_found = True
					self.import_or_export()
			else:
				import_result = gpg.import_keys_file(filepathSourcefile)
				list_of_fingerprints = import_result.fingerprints
				number_of_keys = import_result.count
		else:
			list_of_fingerprints = all_fingerprints
			number_of_keys = len(all_fingerprints)
			
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Assign alias, trust in the owners ability to sign keys and group belongings (if any).", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.08, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		# If there was a valid import and this was the first
		if number_of_keys == 0:
			tk.messagebox.showinfo('Information', "That didn't work! Maybe the file don't contain any valid key(s)!?!")
			self.import_or_export()
		else:
			fingerprint = list_of_fingerprints[this_key_count-1]
			
			key_trust_level_and_text = get_data_for_key(fingerprint)
			
			webTrustLabel = ctk.CTkLabel(my_Frame, text="Web-of-trust judgement for key:", text_color="white", fg_color="black", font=my_font)
			webTrustLabel.place(relx=0.49, rely=0.14, anchor="e")
			
			if key_trust_level_and_text[0] == 'f':
				webTrustLabel2 = ctk.CTkLabel(my_Frame, text="Valid (" + key_trust_level_and_text[1] + ")", text_color="light green", fg_color="black", font=my_font)
				webTrustLabel2.place(relx=0.5, rely=0.14, anchor="w")
			elif key_trust_level_and_text[0] == 'm':
				webTrustLabel2 = ctk.CTkLabel(my_Frame, text="Marginally valid (" + key_trust_level_and_text[1] + ")", text_color="orange", fg_color="black", font=my_font)
				webTrustLabel2.place(relx=0.5, rely=0.14, anchor="w")
			else:
				webTrustLabel2 = ctk.CTkLabel(my_Frame, text=key_trust_level_and_text[1], text_color="white", fg_color="black", font=my_font)
				webTrustLabel2.place(relx=0.5, rely=0.14, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=26, weight="normal", slant="roman", underline=False, overstrike=False)
			Label2 = ctk.CTkLabel(my_Frame, text="Key: " + key_email, text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.21, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
			
			Label2 = ctk.CTkLabel(my_Frame, text="Fingerprint: " + fingerprint, text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.28, anchor="center")
			
			Label3 = ctk.CTkLabel(my_Frame, text="Select trust level in owner*:", font=my_font, text_color="white", fg_color="black")
			Label3.place(relx=0.49, rely=0.38, anchor="e")
			
			clicked = StringVar()
			
			clicked.set(trust_level)
			
			drop = OptionMenu(my_Frame, clicked, *List_Levels)
			drop.place(relx=0.51, rely=0.38, anchor="w")
			
			aliasLabel = ctk.CTkLabel(my_Frame, text="Alias (for key):", text_color="white", fg_color="black", font=my_font)
			aliasLabel.place(relx=0.49, rely=0.46, anchor="e")
			
			if key_alias != '':
				short_alias = key_alias
			else:
				short_alias_pre = list_of_fingerprints[this_key_count -1]
				short_alias = short_alias_pre[-5:]
			users_alias_name_var = ctk.StringVar(value=short_alias)
			users_alias_name_var.trace('w', limitSizeAliasname)
							
			aliasEntry = ctk.CTkEntry(my_Frame, placeholder_text=short_alias, textvariable=users_alias_name_var, width=250, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			aliasEntry.place(relx=0.51, rely=0.46, anchor="w")
			list_of_groups = []
			clicked2 = StringVar()
			clicked2.set(no_group)
			clicked3 = StringVar()
			clicked3.set(no_group)
			clicked4 = StringVar()
			clicked4.set(no_group)
			self.cleanupgroups()
			if os.path.isfile(pathtogroupsfile):
				try:
					with open(pathtogroupsfile, 'r') as file:
						csvfile = csv.reader(file)
						for lines in csvfile:
							if lines[1] not in list_of_groups:	
								list_of_groups.append(lines[1])
				except FileNotFoundError:
					print("Could not open groups file")
			
			if len(list_of_groups) > 0:
				Label4 = ctk.CTkLabel(my_Frame, text="Assign to group:", font=my_font, text_color="white", fg_color="black")
				Label4.place(relx=0.49, rely=0.54, anchor="e")
				
				drop2 = OptionMenu(my_Frame, clicked2, *list_of_groups)
				drop2.place(relx=0.51, rely=0.54, anchor="w")
			if len(list_of_groups) > 1:
				Label5 = ctk.CTkLabel(my_Frame, text="Assign to group:", font=my_font, text_color="white", fg_color="black")
				Label5.place(relx=0.49, rely=0.62, anchor="e")
				
				drop3 = OptionMenu(my_Frame, clicked3, *list_of_groups)
				drop3.place(relx=0.51, rely=0.62, anchor="w")
			if len(list_of_groups) > 2:
				Label5 = ctk.CTkLabel(my_Frame, text="Assign to group:", font=my_font, text_color="white", fg_color="black")
				Label5.place(relx=0.49, rely=0.7, anchor="e")
				
				drop4 = OptionMenu(my_Frame, clicked4, *list_of_groups)
				drop4.place(relx=0.51, rely=0.7, anchor="w")
			if number_of_keys > 1:
				my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
			
				Labeli = ctk.CTkLabel(my_Frame, text="Key number: " + str(this_key_count) + ' of ' + str(len(list_of_fingerprints)), text_color="white", fg_color="black", font=my_font)
				Labeli.place(relx=0.5, rely=0.8, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=22, weight="normal", slant="roman", underline=False, overstrike=False)
				goButton22 = ctk.CTkButton(my_Frame, text="Apply for key!", text_color="white", font=my_font, fg_color='dark green', border_width=2, border_color="white", command=do_importGPG_Key)
				goButton22.place(relx=0.5, rely=0.92, anchor="center")
			else:
				goButton22 = ctk.CTkButton(my_Frame, text="Apply for imported key!", text_color="white", font=my_font, fg_color='dark green', border_width=2, border_color="white", command=do_importGPG_Key)
				goButton22.place(relx=0.5, rely=0.82, anchor="center")
			Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
			Buttonmoreinfo.place(relx=0.92, rely=0.95, anchor="center")
			
	def do_all_keys(self):
		global filepathdestinationfolder
		my_S_Frame = ctk.CTkScrollableFrame(self, 
		width=1176, 
		height=634,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)

		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_S_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_S_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_S_Frame.focus_set()
		my_S_Frame.focus_force()
			
		listoffiles = glob.glob('/home/user1/secure/keys/*')
		listofimportedfingerprints = []
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		for i in listoffiles:
			try:
				import_result = gpg.import_keys_file(i)
				listofimportedfingerprints.append(import_result.fingerprints)
				gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_UNDEFINED')
			except:
				continue
		return
			
	def importGPG_Key_from_archive(self):
		global path_to_USB_secure
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			
		def do_one_key():
			tk.messagebox.showinfo('Information', 'Select the GPG-key you like to import from the secure archive to the local keychain.')
			time.sleep(2)
			
			filepathSourcefile = filedialog.askopenfilename(initialdir='/home/user1/secure/keys')
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			import_result = gpg.import_keys_file(filepathSourcefile)
			
			try:
				gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_UNDEFINED')
			except Exception:
				tk.messagebox.showinfo('Error', 'Could not set trust level to UNDEFINED.')
			self.create_meny()
		
		Label_backg.place(x=0, y=0)
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Importing key's from the secure archive to the local keychain.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.06, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="This could be needed when restoring a backup to a new or different hardware device.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.16, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Import all the key's found in directory /home/user1/secure/keys (the default location)?", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.3, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		Button = ctk.CTkButton(my_Frame, text="Yes, start!", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.do_all_keys)
		Button.place(relx=0.5, rely=0.38, anchor="center")
		Button2 = ctk.CTkButton(my_Frame, text="No! I want to select a specific file!", text_color="white", font=my_font, fg_color=SecUSB_button_color, border_width=2, border_color="white", command=do_one_key)
		Button2.place(relx=0.5, rely=0.5, anchor="center")
		
	def exportGPGmypublic(self):
		global clicked_publicKey
		global PersonalGPGKey
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_exportGPGmypublic():
			global clicked_publicKey
			global GPG_button_color
			decoded_fingerprint = ['N/A']
			clicked_publicKey = str(clicked.get())
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_fingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_fingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			ascii_armoured_public_key = gpg.export_keys(decoded_fingerprint)
			answer = messagebox.askquestion('Information!', 'Do you want to save the exported keys in the Secure archive (if not it will be saved to an external USB-device)?')
			if answer == 'yes':
				tk.messagebox.showinfo('Information', 'Select the directory for the file.')
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			else:
				result = tk.messagebox.askokcancel("Information", "Connect the USB-device and then click \"OK\".")
				if not result:
					self.import_or_export()
					return
				time.sleep(2)
				
				result = tk.messagebox.askokcancel('Information', 'Select folder where to place the public key by double clicking on it.')
				if not result:
					self.self.import_or_export()
					return
				time.sleep(2)
				
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			# Ask for name for file (optional).
			USER_INP = simpledialog.askstring(title="Information!", prompt="Enter a name for the public key file:")
			input_size = len(USER_INP)
			if input_size > 42:
				messagebox.showinfo("Information", "The filename can be max 42 characters.")
				self.exportGPGmypublic()
			else:
				if USER_INP != '':
					c = open(outputdir + '/' + USER_INP + '.asc', 'w')
					c.write(ascii_armoured_public_key)
					c.close()
					for i in decoded_fingerprint:
						new_record = [i, "Exported public key", '']
						self.add_record(new_record)
					tk.messagebox.showinfo('Information', 'Key(s) has been exported to file\n' + USER_INP + '.asc')
						
				else:
					c = open(outputdir + '/publickey' + clicked_publicKey + '.asc', 'w')
					c.write(ascii_armoured_public_key)
					c.close()
					for i in decoded_fingerprint:
						new_record = [i, "Exported public key", '']
						self.add_record(new_record)
					tk.messagebox.showinfo('Information', 'Key(s) has been exported to file\n' + '/publickey' + decoded_fingerprint + '.asc')
			self.create_GPGmeny()
		
		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Export a public key or a group of keys to a file/archive.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.07, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="The public key(s) can be shared to others so that they can encrypt emails, files or messages with it.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.14, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Only the corresponding private key is then able to decrypt it.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.19, anchor="w")
		
		Label4 = ctk.CTkLabel(my_Frame, text="Public keys can also be signed by others, see \"Web of trust\" online for more information.", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.05, rely=0.24, anchor="w")

		public_keys = gpg.list_keys()
				
		clicked = StringVar()
			
		List_publicfingerprints = []
		
		# Add groups first in list of public keys
		self.cleanupgroups()
		
		if os.path.isfile(pathtogroupsfile):
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in List_publicfingerprints:	
							List_publicfingerprints.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
					
		public_fingerprints_and_aliases = []
		
		publickeysavailable = False
			
		for i in public_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i['fingerprint'])
				
		if List_publicfingerprints:	
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True

		my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
			
		if publickeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select the public key(s) to export:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.34, rely=0.4, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *public_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.35, rely=0.4, anchor="w")
			
			Button2 = ctk.CTkButton(my_Frame, text="Export key(s)", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_exportGPGmypublic)
			Button2.place(relx=0.61, rely=0.47, anchor="w")
		else:
			print("No public key")
	
	def exportGPG(self):
		global GPG_button_color
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_exportGPG():
			global clicked_privateKey
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
			if not result:
				self.import_or_export()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the directory where you want to save the signed and encrypted private keys file.')
			if not result:
				self.import_or_export()
				return
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			ascii_armoured_private_key = gpg.export_keys(decoded_fingerprint, True, expect_passphrase=False) 
			c = open(outputdir + '/privatekey' + decoded_fingerprint + '.gpg', 'w')
			c.write(ascii_armoured_private_key)
			c.close()
			tk.messagebox.showinfo('Information', 'Key has been exported.')
			new_record = [decoded_fingerprint, "Exported the public key.", '']
			self.add_record(new_record)
			self.create_GPGmeny()
		
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Export a private key from the local keychain to a file.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.14, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="The private key should be handled and stored in a safe manner.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.24, anchor="w")
		
		Label3 = ctk.CTkLabel(my_Frame, text="The private key's can be backed up in the secure archive where they will be encrypted.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.05, rely=0.32, anchor="w")

		private_keys = gpg.list_keys(True)
				
		clicked = StringVar()
			
		List_fingerprints = []
		private_fingerprints_and_aliases = []
		
		privatekeysavailable = False
			
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
		
		if List_fingerprints:	
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
			
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if privatekeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to export:", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.34, rely=0.5, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.35, rely=0.5, anchor="w")
			
			Button2 = ctk.CTkButton(my_Frame, text="Export key", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_exportGPG)
			Button2.place(relx=0.61, rely=0.57, anchor="w")
		else:
			print("No private key")
		
	def select_what_to_sign(self):
		global GPG_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Button = ctk.CTkButton(my_Frame, text="Encrypt a document", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.encrypt_file)
		Button.place(relx=0.25, rely=0.1, anchor="center")
		
		Button4 = ctk.CTkButton(my_Frame, text="Encrypt and sign a document", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=partial(self.encrypt_and_sign_file, ' '))
		Button4.place(relx=0.75, rely=0.1, anchor="center")
		
		Button7 = ctk.CTkButton(my_Frame, text="Decrypt a document on a USB-device", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.decrypt_file)
		Button7.place(relx=0.25, rely=0.25, anchor="center")
		
		Button5 = ctk.CTkButton(my_Frame, text="Check a signed document on a USB-device *", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.check_document)
		Button5.place(relx=0.75, rely=0.25, anchor="center")
		
		Button2 = ctk.CTkButton(my_Frame, text="Sign a document on a USB-device **", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.sign_document)
		Button2.place(relx=0.25, rely=0.4, anchor="center")
		
		Button3 = ctk.CTkButton(my_Frame, text="Sign/validate a public key on the local keychain", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.sign_key_on_keychain)
		Button3.place(relx=0.75, rely=0.4, anchor="center")
		
		Button12 = ctk.CTkButton(my_Frame, text="Sign QR-code data with camera ***", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.sign_QR)
		Button12.place(relx=0.25, rely=0.55, anchor="center")
		
		Button16 = ctk.CTkButton(my_Frame, text="List signatures for a key on the local keychain", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.list_sigs_on_key)
		Button16.place(relx=0.75, rely=0.55, anchor="center")
		
		Button8 = ctk.CTkButton(my_Frame, text="Check/make Timestamp address for a file on USB-device", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", width=460, height=42, font=my_font, command=self.BTC_timestamp)
		Button8.place(relx=0.5, rely=0.68, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="normal", slant="roman", underline=False, overstrike=False)
		LabelaboutQR = ctk.CTkLabel(my_Frame, text="*** The output will be a detached signature (.sig) that can be saved or scanned as a QR-code.)", text_color="white", fg_color="black", font=my_font)
		LabelaboutQR.place(relx=0.03, rely=0.91, anchor="w")
		
		Labelinfo = ctk.CTkLabel(my_Frame, text="* Checking a document with a detached signature. For checking an encrypted document you need to do decrypt instead.", text_color="white", fg_color="black", font=my_font)
		Labelinfo.place(relx=0.02, rely=0.79, anchor="w")
		Labelinfo2 = ctk.CTkLabel(my_Frame, text="** Signing a document by creating a detached signature using a private key on the local keychain.", text_color="white", fg_color="black", font=my_font)
		Labelinfo2.place(relx=0.02, rely=0.85, anchor="w")
	
	def BTC_timestamp(self):
		global filepathdestinationfolder
		global path_to_data_file
		global path_to_sig
		
		the_blockchain_link = ' '
		
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(the_blockchain_link)
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the USB-device')
			self.select_what_to_sign()
			
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
		
		result = tk.messagebox.askokcancel('Information', 'Insert USB-device and then click \"OK\".')
		if not result:
			self.select_what_to_sign()
			return
		time.sleep(2)
		result = tk.messagebox.askokcancel('Information', 'Select the file to make BTC Timestamp address for.')
		if not result:
			self.select_what_to_sign()
			return
		time.sleep(2)
		filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		path_to_data_file = filepathSourcefile
		
		answer = messagebox.askquestion('Information!', 'Do you want to include the signature file when calculating the timestamp address?')
		if answer == 'yes':
			tk.messagebox.showinfo('Information', 'Select the signature file to include in calculating BTC Timestamp address.')
			time.sleep(2)
			filepathSignaturefile = filedialog.askopenfilename(initialdir='/media/user1')
		
			# Make hash for both signature and document
			hashForDocument = sha256Hex(filepathSourcefile)
			
			hashForSignature = sha256Hex(filepathSignaturefile)
			
			# Make combined hash for the combination signature + document
			totalHash = hashForSignature + hashForDocument
		else:		
			# Make hash only for document
			totalHash = sha256Hex(filepathSourcefile)
		
		# Hash a Bitcoin address from the hash
		addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
		
		btcAddress = addr.address
		
		# Generate QR-codes for bitcoin address 
		qr_public_address = qrcode.make(btcAddress)
		resize_qr_public_address = qr_public_address.resize((160, 160))
		pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
		resize_qr_public_address.save(pathtopublic)
		publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(160, 160))
		Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = publicimg)
		Labelpublicimg.place(relx=0.2, rely=0.68, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Check if a document has been Timestamped on the Bitcoin blockchain", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="The below bitcoin address is derived from the documents unique footpint (hash).", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.2, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="Scan the below QR with a Blockchain link to check if there are any sats sent to it (bech32, Native Segwit).\nOr, make a Timestamp yourself by sending 1100 sats to a pay-link.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.29, anchor="center")
		
		pubLabel = ctk.CTkLabel(my_Frame, text="BTC address", text_color="white", font=my_font, fg_color="black")
		pubLabel.place(relx=0.2, rely=0.52, anchor="center")
		
		# Generate QR-codes for Blockchain search 
		the_blockchain_link = "www.mempool.space/address/" + str(btcAddress)
		qr_blockchain_address = qrcode.make(the_blockchain_link)
		resize_qr_blockchain_address = qr_blockchain_address.resize((200, 200))
		pathtoblockchain = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
		resize_qr_blockchain_address.save(pathtoblockchain)
		blockchainimg = ctk.CTkImage(light_image=Image.open(pathtoblockchain), dark_image=Image.open(pathtoblockchain), size=(200, 200))
		Labelblockchainimg = ctk.CTkLabel(my_Frame,  text = "", image = blockchainimg)
		Labelblockchainimg.place(relx=0.8, rely=0.63, anchor="center")
		
		pubLabel = ctk.CTkLabel(my_Frame, text="Blockchain link *:", text_color="white", font=my_font, fg_color="black")
		pubLabel.place(relx=0.8, rely=0.44, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		saveButton = ctk.CTkButton(my_Frame, text="Save to USB-device", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_USB)
		saveButton.place(relx=0.8, rely=0.82, anchor="center")
		
		timestampbutton = ctk.CTkButton(my_Frame, text="Create pay-link (1100 sats)", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=partial(self.create_paylink, my_Frame))
		timestampbutton.place(relx=0.5, rely=0.38, anchor="center")
								
		infoLabel = ctk.CTkLabel(my_Frame, text="* Use Blockchain link to check if a timestamped transaction has been made to the BTC address.", text_color="white", font=my_font, fg_color="black")
		infoLabel.place(relx=0.18, rely=0.88, anchor="w")
		back_button = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="blue", border_width=2, border_color="white", font=my_font, command=self.select_what_to_sign)
		back_button.place(relx=0.5, rely=0.94, anchor="center")
	
	def create_paylink(self, frame_):
		global filepathdestinationfolder
		global path_to_data_file
		global path_to_sig
		
		transaction_payload = ' '
		
		def do_new_Bitcoinwallet(TimestampAddress, totalHash, outputfilesname, filename):
		
			path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
			
			now = datetime.now()
			dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
			dt_string_short = now.strftime("%Y-%m-%d")
					
			new_paperwallet = [
								"Timestamp",
								dt_string_short,
								TimestampAddress,
								totalHash,
								filename,
								outputfilesname,
								"Not payed"]

			with open(path_to_wallets, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_paperwallet)
				
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(transaction_payload)
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the USB-device')
			self.select_what_to_sign()
			
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
			
		# Make hash for document
		totalHash = sha256Hex(path_to_data_file)
		
		# Hash a Bitcoin address from the hash
		addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
		
		btcAddress = addr.address
		
		transaction_payload = "bitcoin:" + btcAddress + '?amount=0.00001100'
		
		filename_list = path_to_data_file.split("/")
		filename_ = str(filename_list[-1])
			
		do_new_Bitcoinwallet(btcAddress, totalHash, "None", filename_)
					
		# Generate QR-codes for bitcoin payment 
		qr_public_address = qrcode.make(transaction_payload)
		resize_qr_public_address = qr_public_address.resize((160, 160))
		pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
		resize_qr_public_address.save(pathtopublic)
		publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(160, 160))
		Labelpublicimg = ctk.CTkLabel(frame_,  text = "", image = publicimg)
		Labelpublicimg.place(relx=0.5, rely=0.61, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
	
		pubLabel = ctk.CTkLabel(frame_, text="Paylink:", text_color="white", font=my_font, fg_color="black")
		pubLabel.place(relx=0.5, rely=0.45, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		detailsButton = ctk.CTkButton(frame_, text="Details", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.do_edit_Bitcoinwallets, btcAddress))
		detailsButton.place(relx=0.5, rely=0.77, anchor="center")
		saveButton = ctk.CTkButton(frame_, text="Save Pay-link to USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_USB)
		saveButton.place(relx=0.5, rely=0.82, anchor="center")
	
	def decrypt_file(self):
		global filepathdestinationfolder
		global path_to_USB_secure
		global SecUSB_button_color
		global theinput 
		global clicked_publicKey
		global PersonalGPGKey
		main_fingerprint = ' '
		
		def get_main_fingerprint_from_subkeyID(key_ID_tag):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			found_ = "no"
			# Get list of public keys
			public_keys = gpg.list_keys()

			# Loop through and display look for any containing a sign subkey
			if public_keys:
				for i in public_keys:
					subkey_lists = i['subkeys']
					# Loop though the subkeys lists 
					for ii in subkey_lists:
						if ii[1] == 's' and ii[0] == key_ID_tag: # If the subkey is signing key and the key ID match
							found_ = i['fingerprint']
				return found_
								
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
				
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Decrypt and check signature for a file on a USB-device", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Output file can be placed on the USB-device or in the secure archive (best practice).", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.16, anchor="w")
		
		if path_to_USB_secure == 'Secure USB folder is available':
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			# Select file with message to decrypt
			result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
			if not result:
				self.select_what_to_sign()
				return
				
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the file to decrypt.')
			if not result:
				self.select_what_to_sign()
				return
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			stream = open(filepathSourcefile, 'rb')
			
			answer = messagebox.askquestion('Information!', 'Do you want to save the decrypted file in the Secure archive (if answer \"No\" it will be stored on an USB-device)?')
			if answer == 'yes':
				tk.messagebox.showinfo('Information', 'Select the directory for the output file.')
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			else:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the decrypted file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
						
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (with correct extension):")
			output_path = outputdir + '/' + USER_INP		
			try:
				data_ = gpg.decrypt_file(stream, output=output_path)
				if data_.ok:
					if get_main_fingerprint_from_subkeyID(data_.key_id) != "no":
						main_fingerprint = get_main_fingerprint_from_subkeyID(data_.key_id)
					else:
						main_fingerprint = data_.fingerprint
					
					if data_.trust_level is not None and data_.trust_level >= 1 and self.lookup_Alias_absolut(main_fingerprint) != "None":
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=self.lookup_Alias(main_fingerprint), text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
					elif data_.trust_level is not None and data_.trust_level >= 1 :
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=main_fingerprint, text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
					else:
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signature could not be verified!", text_color="pink", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
				else:
					messagebox.showinfo('Information', data_.status)
					self.select_what_to_sign()
			except FileNotFoundError:
					messagebox.showinfo("Information", "No settings file found.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def decrypt_file_direct(self, full_path):
		global filepathdestinationfolder
		global path_to_USB_secure
		global SecUSB_button_color
		global theinput, use_filter 
		global clicked_publicKey
		global PersonalGPGKey
		main_fingerprint = ' '
		
		def get_main_fingerprint_from_subkeyID(key_ID_tag):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			found_ = "no"
			# Get list of public keys
			public_keys = gpg.list_keys()

			# Loop through and display look for any containing a sign subkey
			if public_keys:
				for i in public_keys:
					subkey_lists = i['subkeys']
					# Loop though the subkeys lists 
					for ii in subkey_lists:
						if ii[1] == 's' and ii[0] == key_ID_tag: # If the subkey is signing key and the key ID match
							found_ = i['fingerprint']
				return found_
								
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		filename_list = full_path.split("/")
		filename_ = str(filename_list[-1])
				
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Decrypt and check signature for a file in the Secure archive", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Output file can be placed in the secure archive (best practice) or on a USB-device.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.16, anchor="w")
		nameLabel = ctk.CTkLabel(my_Frame, text="Decrypting file: " + filename_, text_color="white", fg_color="black", font=my_font)
		nameLabel.place(relx=0.05, rely=0.23, anchor="w")
		
		if path_to_USB_secure == 'Secure USB folder is available':
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			# Select file with message to decrypt
			stream = open(full_path, 'rb')
			answer = messagebox.askquestion('Information!', 'Do you want to save the decrypted file in the Secure archive (if \"No\" you need to save it on a USB-device)?')
			if answer == 'yes':
				tk.messagebox.showinfo('Information', 'Select the directory for the output file.')
				outputdir = filedialog.askdirectory(initialdir='/home/user1/secure')
			else:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the decrypted file.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
						
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (with correct extension):")
			output_path = outputdir + '/' + USER_INP		
			try:
				data_ = gpg.decrypt_file(stream, output=output_path)
				if data_.ok:
					if get_main_fingerprint_from_subkeyID(data_.key_id) != "no":
						main_fingerprint = get_main_fingerprint_from_subkeyID(data_.key_id)
					else:
						main_fingerprint = data_.fingerprint
					
					if data_.trust_level is not None and data_.trust_level >= 1 and self.lookup_Alias_absolut(main_fingerprint) != "None":
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=self.lookup_Alias(main_fingerprint), text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
					elif data_.trust_level is not None and data_.trust_level >= 1 :
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=main_fingerprint, text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
					else:
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signature could not be verified!", text_color="pink", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.52, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv4 = ctk.CTkLabel(my_Frame, text="Decrypted file has been saved as:", text_color="white", fg_color="black", font=my_font)
						Labelv4.place(relx=0.5, rely=0.62, anchor="center")
						Labelv5 = ctk.CTkLabel(my_Frame, text=output_path, text_color="white", fg_color="black", font=my_font)
						Labelv5.place(relx=0.5, rely=0.7, anchor="center")
				else:
					messagebox.showinfo('Information', data_.status)
					use_filter = ' '
					self.check_SecUSB("none")
			except FileNotFoundError:
					messagebox.showinfo("Information", "No settings file found.")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
					
	def encrypt_and_sign_file(self, full_path):
		global clicked_publicKey
		global clicked_privateKey
		global PersonalGPGKey
		global GPG_button_color
		
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_encrypt_and_sign_full_path_file():
			global clicked_publicKey
			global clicked_privateKey
			decoded_publicfingerprint = ['N/A']
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			encr_pass = False
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				completeName = full_path + '.asc'
				
				filename_list = full_path.split("/")
				filename_ = str(filename_list[-1])
				encsigfilename = filename_ + '.asc'
				
				# Read the file
				stream = open(full_path, 'rb')
					
				# Encrypt the file
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				encrypted_data = gpg.encrypt_file(stream, decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(completeName, 'w') as f:
							f.write(str(encrypted_data))
							new_record = [decoded_fingerprint, "Encrypted and signed file.", "File:" + encsigfilename]
							self.add_record(new_record)
							messagebox.showinfo('Information', 'File has been signed, encrypted and saved in the same directory.\n\n'+ encsigfilename)
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
				else:
					messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

				self.check_SecUSB("none")
				
		def do_encrypt_and_sign_file_on_USB():
			global clicked_publicKey
			global clicked_privateKey
			decoded_publicfingerprint = ['N/A']
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			encr_pass = False
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the file you want to encrypt and sign.')
				time.sleep(2)
				file_path = filedialog.askopenfilename(initialdir='/media/user1')
				
				completeName = file_path + '.asc'
				
				filename_list = file_path.split("/")
				filename_ = str(filename_list[-1])
				encsigfilename = filename_ + '.asc'
				
				# Read the file
				stream = open(file_path, 'rb')
					
				# Encrypt the file
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				encrypted_data = gpg.encrypt_file(stream, decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				write_ok = False
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(completeName, 'w') as f:
							f.write(str(encrypted_data))
							f.flush()
							os.fsync(f.fileno())
							write_ok = True
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
					os.system("sync")
					time.sleep(1)
					if write_ok:
						new_record = [decoded_fingerprint, "Encrypted and signed file.", "File:" + encsigfilename]
						self.add_record(new_record)
						statusText = 'File has been signed, encrypted and stored:\n\n'+ encsigfilename
						self.unmount_USBs(statusText)
				else:
					messagebox.showinfo('Information', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")
				
				self.select_what_to_sign()
		
		def do_encrypt_and_sign_file_on_OD():
			global clicked_publicKey
			global clicked_privateKey
			decoded_publicfingerprint = ['N/A']
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			encr_pass = False
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Select the file you want to encrypt and sign.')
				file_path = filedialog.askopenfilename(initialdir='/home/user1/secure')
				
				# Read the file
				stream = open(file_path, 'rb')
					
				# Encrypt the file
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				encrypted_data = gpg.encrypt_file(stream, decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				
				filename_list = file_path.split("/")
				filename_ = str(filename_list[-1])
				encsigfilename = filename_ + '.asc'
					
				answer = messagebox.askquestion('Information!', 'Do you want to save the signed and encrypted file on an external USB-device?')
				if answer == 'yes':
					tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
					time.sleep(2)
					tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the signed and encrypted file.')
					time.sleep(2)
					outputdir = filedialog.askdirectory(initialdir='/media/user1')
					outputfilesname = outputdir + "/" + encsigfilename
				else:
					outputfilesname = file_path + '.asc'	
				
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(outputfilesname, 'w') as f:
							f.write(str(encrypted_data))
							new_record = [decoded_fingerprint, "Encrypted and signed file.", "File:" + encsigfilename]
							self.add_record(new_record)
							messagebox.showinfo('Information', 'File has been signed, encrypted and stored as:\n\n  '+ encsigfilename)
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
				else:
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

				self.select_what_to_sign()
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Encrypt and sign a file using keys on the local keychain", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Encrypt with the recipients public key and sign with a private key.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.18, anchor="w")
		
		filename_list = full_path.split("/")
		filename = str(filename_list[-1])
		
		if full_path != ' ':
			Label3 = ctk.CTkLabel(my_Frame, text="File: " + filename, text_color="white", fg_color="black", font=my_font)
			Label3.place(relx=0.1, rely=0.26, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_full_path_file)
			Button2.place(relx=0.87, rely=0.53, anchor="e")
		else:
			Button2 = ctk.CTkButton(my_Frame, text="Select file on a USB-device", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_file_on_USB)
			Button2.place(relx=0.87, rely=0.53, anchor="e")
			Button3 = ctk.CTkButton(my_Frame, text="Select file on Offline device", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_file_on_OD)
			Button3.place(relx=0.87, rely=0.59, anchor="e")
			
		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
	
		List_fingerprints = []
		
		List_publicfingerprints = []
		
		# Add groups first in list of public keys
		self.cleanupgroups()
		
		if os.path.isfile(pathtogroupsfile):
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in List_publicfingerprints:	
							List_publicfingerprints.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
				
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False
		publickeysavailable = False
		
		# Dont display the private key that is only intended for Offline device encryption/decryption
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
					
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i2['fingerprint'])
			
		if List_publicfingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		
		if not List_fingerprints:	
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.5, anchor="center")
		else:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign message with (FROM):", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.48, rely=0.4, anchor="e")

			drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop1.config(width=45)
			drop1.place(relx=0.49, rely=0.4, anchor="w")
						
		if publickeysavailable == True:
			Label11 = ctk.CTkLabel(my_Frame, text="Select public key(s) to encrypt the file with (TO):", font=my_font, text_color="white", fg_color="black")
			Label11.place(relx=0.48, rely=0.46, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.49, rely=0.46, anchor="w")
		else:
			Button4 = ctk.CTkButton(my_Frame, text="There are no public keys on the keychain. Create one now?", font=my_font, text_color="white", fg_color="green", border_width=2, border_color="white", command=self.importGPG_Key)
			Button4.place(relx=0.5, rely=0.55, anchor="center")
	
	def encrypt_and_sign_record(self, fingerprint):
		global clicked_publicKey
		global clicked_privateKey
		global PersonalGPGKey
		global GPG_button_color
		
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		pathtorecord = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
			
		def do_encrypt_and_sign_record():
			global clicked_publicKey
			global clicked_privateKey
			decoded_publicfingerprint = ['N/A']
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				encsigfilename = 'Record_' + fingerprint + '.asc'
				
				# Read the file
				stream = open(pathtorecord, 'rb')
					
				# Encrypt the file
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				encrypted_data = gpg.encrypt_file(stream, decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the signed and encrypted record.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
				outputfilesname = outputdir + "/" + encsigfilename
				
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(outputfilesname, 'w') as f:
							f.write(str(encrypted_data))
							new_record = [decoded_fingerprint, "Encrypted and signed record.", "File:" + encsigfilename]
							self.add_record(new_record)
							messagebox.showinfo('Information', 'File has been signed, encrypted and stored as:\n\n  '+ encsigfilename)
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
				else:
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

				self.get_key_records(fingerprint)
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Encrypt and sign a Private key's history and save to to external USB-device.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.04, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Encrypt with a recipients public key and sign with a selected private key.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.04, rely=0.16, anchor="w")
		
		Label21 = ctk.CTkLabel(my_Frame, text="The data will be in csv-file format. Import can be done with another Offline device to merge the data.", text_color="white", fg_color="black", font=my_font)
		Label21.place(relx=0.04, rely=0.22, anchor="w")
		
		Label22 = ctk.CTkLabel(my_Frame, text="To share in a plain text-format use \"Save\" instead.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.04, rely=0.28, anchor="w")
				
		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
	
		List_fingerprints = []
		List_publicfingerprints = []
		
		# Add groups first in list of public keys
		self.cleanupgroups()
		
		if os.path.isfile(pathtogroupsfile):
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in List_publicfingerprints:	
							List_publicfingerprints.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
		
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False
		publickeysavailable = False
		
		# Dont display the private key that is only intended for Offline device encryption/decryption
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
					
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i2['fingerprint'])
			
		if List_publicfingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		
		if not List_fingerprints:	
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.5, anchor="center")
		else:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign with (FROM):", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.45, rely=0.4, anchor="e")

			drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop1.config(width=45)
			drop1.place(relx=0.46, rely=0.4, anchor="w")
						
		if publickeysavailable == True:
			Label11 = ctk.CTkLabel(my_Frame, text="Select public key(s) to encrypt with (TO):", font=my_font, text_color="white", fg_color="black")
			Label11.place(relx=0.45, rely=0.46, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.46, rely=0.46, anchor="w")

			Button2 = ctk.CTkButton(my_Frame, text="Encrypt and sign", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_record)
			Button2.place(relx=0.84, rely=0.53, anchor="e")
			
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.get_key_records, fingerprint))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
		else:
			Button3 = ctk.CTkButton(my_Frame, text="There are no public keys on the keychain. Create one now?", font=my_font, text_color="white", fg_color="green", border_width=2, border_color="white", command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.55, anchor="center")
			
	def encrypt_and_sign_statement(self, walletname):
		global clicked_publicKey
		global clicked_privateKey
		global PersonalGPGKey
		global GPG_button_color
		
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		pathtostatement = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
			
		def do_encrypt_and_sign_statement():
			global clicked_publicKey
			global clicked_privateKey
			decoded_publicfingerprint = ['N/A']
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_publicfingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_publicfingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			validity_for_key = self.get_key_validity(decoded_publicfingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				encsigfilename = 'Data_' + walletname + '.asc'
				
				# Read the file
				stream = open(pathtostatement, 'rb')
					
				# Encrypt the file
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				encrypted_data = gpg.encrypt_file(stream, decoded_publicfingerprint, sign=decoded_fingerprint, always_trust=True) 
				
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the signed and encrypted statement.')
				time.sleep(2)
				outputdir = filedialog.askdirectory(initialdir='/media/user1')
				outputfilesname = outputdir + "/" + encsigfilename
				
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(outputfilesname, 'w') as f:
							f.write(str(encrypted_data))
							new_record = [decoded_fingerprint, "Encrypted and signed statement.", "File:" + encsigfilename]
							self.add_record(new_record)
							messagebox.showinfo('Information', 'File has been signed, encrypted and stored as:\n\n  '+ encsigfilename)
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
				else:
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

				self.create_BitcoinWalletmeny()
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Encrypt and sign a Statement and save to to an external USB-device.", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.04, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Encrypt with a recipients public key and sign with a selected private key.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.04, rely=0.16, anchor="w")
		
		Label21 = ctk.CTkLabel(my_Frame, text="The data will be in csv-file format. Import can be done with another Offline device to merge the data.", text_color="white", fg_color="black", font=my_font)
		Label21.place(relx=0.04, rely=0.22, anchor="w")
		
		Label22 = ctk.CTkLabel(my_Frame, text="To share in a plain text-format use \"Save\" instead.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.04, rely=0.28, anchor="w")
				
		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
	
		List_fingerprints = []
		List_publicfingerprints = []
		
		# Add groups first in list of public keys
		self.cleanupgroups()
		
		if os.path.isfile(pathtogroupsfile):
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in List_publicfingerprints:	
							List_publicfingerprints.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
		
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False
		publickeysavailable = False
		
		# Dont display the private key that is only intended for Offline device encryption/decryption
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
					
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_publicfingerprints.append(i2['fingerprint'])
			
		if List_publicfingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_publicfingerprints)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		
		if not List_fingerprints:	
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the device.", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.5, anchor="center")
		else:
			Label1 = ctk.CTkLabel(my_Frame, text="Select private key to sign with (FROM):", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.45, rely=0.4, anchor="e")

			drop1 = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop1.config(width=45)
			drop1.place(relx=0.46, rely=0.4, anchor="w")
						
		if publickeysavailable == True:
			Label11 = ctk.CTkLabel(my_Frame, text="Select public key(s) to encrypt with (TO):", font=my_font, text_color="white", fg_color="black")
			Label11.place(relx=0.45, rely=0.46, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.46, rely=0.46, anchor="w")

			Button2 = ctk.CTkButton(my_Frame, text="Encrypt and sign", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_and_sign_statement)
			Button2.place(relx=0.84, rely=0.53, anchor="e")
			
			backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.showWalletStatement, walletname))
			backButton.place(relx=0.5, rely=0.94, anchor="center")
		else:
			Button3 = ctk.CTkButton(my_Frame, text="There are no public keys on the keychain. Create one now?", font=my_font, text_color="white", fg_color="green", border_width=2, border_color="white", command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.55, anchor="center")
	
	def import_and_merge_record(self, fingerprint):
		global PersonalGPGKey
		global GPG_button_color
		global content
		
		main_fingerprint = ' '
		content = ''
		
		def get_main_fingerprint_from_subkeyID(key_ID_tag):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			found_ = "no"
			# Get list of public keys
			public_keys = gpg.list_keys()

			# Loop through and display look for any containing a sign subkey
			if public_keys:
				for i in public_keys:
					subkey_lists = i['subkeys']
					# Loop though the subkeys lists 
					for ii in subkey_lists:
						if ii[1] == 's' and ii[0] == key_ID_tag: # If the subkey is signing key and the key ID match
							found_ = i['fingerprint']
				return found_
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		pathtorecord = filepathdestinationfolder + "/secure/keys/records/record" + fingerprint + ".csv"
		pathtoimportedrecord = filepathdestinationfolder + "/secure/keys/records/importedRecord" + fingerprint + ".csv"
		
		def do_import_and_merge_record():
			
			# Open the file
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the file to decrypt.')
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			stream = open(filepathSourcefile, 'rb')
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			try:
				data_ = gpg.decrypt_file(stream, output=pathtoimportedrecord)
				if data_.ok:
					content = data_.data
					if get_main_fingerprint_from_subkeyID(data_.key_id) != "no":
						main_fingerprint = get_main_fingerprint_from_subkeyID(data_.key_id)
					else:
						main_fingerprint = data_.fingerprint
					
					if data_.trust_level is not None and data_.trust_level >= 1 and self.lookup_Alias_absolut(main_fingerprint) != "None":
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge record data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=self.lookup_Alias(main_fingerprint), text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						if os.path.isfile(pathtorecord):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_record_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_record_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
					elif data_.trust_level is not None and data_.trust_level >= 1:
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge record data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=main_fingerprint, text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						if os.path.isfile(pathtostatement):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_statement_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_statement_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
					else:
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge record data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signature could not be verified!", text_color="red", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.34, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						if os.path.isfile(pathtostatement):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_statement_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import record data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_statement_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
						backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=discard_imported)
						backButton.place(relx=0.5, rely=0.94, anchor="center")
						
				else:
					messagebox.showinfo('Information', data_.status)
					self.select_what_to_sign()
			except FileNotFoundError:
					messagebox.showinfo("Information", "No settings file found.")
		
		def do_merge_record_data():
			global content
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			USER_INP = ''
			USER_INP = simpledialog.askstring(title="Information!", prompt="Enter a max 6 character prefix (optional):")
			input_size = len(USER_INP)
			if input_size > 6:
				USER_INP = USER_INP[:6]
			with open(pathtoimportedrecord, 'r') as source, open(pathtorecord, 'a') as result:
				line = source.readline() #remove header
				line = source.readline()
				while line != "":
					if USER_INP != '':
						line_list = line.split(',')
						line_list[2] = USER_INP + ':' + line_list[2]
						if len(line_list[2]) > 50:
							line_list[2] = line_list[2][:50]
						line = line_list[0] + ',' + line_list[1] + ',' + line_list[2]
					result.write(line)
					line = source.readline()
					
			if os.path.isfile(pathtoimportedrecord):
				os.remove(pathtoimportedrecord)
			self.get_key_records(fingerprint)	
			
		def do_import_record_data():
			global content
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			shutil.copy(pathtoimportedrecord, pathtorecord)
			if os.path.isfile(pathtoimportedrecord):
				os.remove(pathtoimportedrecord)
			self.get_key_records(fingerprint)		
		
		def discard_imported():
			if os.path.isfile(pathtoimportedrecord):
				os.remove(pathtoimportedrecord)
			self.get_key_records(fingerprint)	
				
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Import and merge record data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.11, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Decrypt with your private key and any signature is checked using all public keys on local keychain.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.18, anchor="w")
		
		Label21 = ctk.CTkLabel(my_Frame, text="The imported data will be merged with existing records for the key (if any).", text_color="white", fg_color="black", font=my_font)
		Label21.place(relx=0.05, rely=0.24, anchor="w")
		
		Label22 = ctk.CTkLabel(my_Frame, text="Before merge there is an option to add a short prefix to the comment field for all merged lines.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.05, rely=0.3, anchor="w")
				
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight='bold', underline=False, overstrike=False)
		Button2 = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color='dark green', font=my_font, border_width=2, border_color="white", command=do_import_and_merge_record)
		Button2.place(relx=0.5, rely=0.53, anchor="center")
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.get_key_records, fingerprint))
		backButton.place(relx=0.5, rely=0.95, anchor="center")
		
	def import_and_merge_statement(self, walletname):
		global PersonalGPGKey
		global GPG_button_color
		global content
		
		main_fingerprint = ' '
		content = ''
		
		def get_main_fingerprint_from_subkeyID(key_ID_tag):
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			found_ = "no"
			# Get list of public keys
			public_keys = gpg.list_keys()

			# Loop through and display look for any containing a sign subkey
			if public_keys:
				for i in public_keys:
					subkey_lists = i['subkeys']
					# Loop though the subkeys lists 
					for ii in subkey_lists:
						if ii[1] == 's' and ii[0] == key_ID_tag: # If the subkey is signing key and the key ID match
							found_ = i['fingerprint']
				return found_
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		pathtostatement = str(filepathdestinationfolder) + "/secure/wallets/Statement" + walletname + ".csv"
		pathtoimportedstatement = str(filepathdestinationfolder) + "/secure/wallets/importedStatement" + walletname + ".csv"
		
		def do_import_and_merge_statement():
			
			# Open the file
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the file to decrypt.')
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			stream = open(filepathSourcefile, 'rb')
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			try:
				data_ = gpg.decrypt_file(stream, output=pathtoimportedstatement)
				if data_.ok:
					content = data_.data
					if get_main_fingerprint_from_subkeyID(data_.key_id) != "no":
						main_fingerprint = get_main_fingerprint_from_subkeyID(data_.key_id)
					else:
						main_fingerprint = data_.fingerprint
					
					if data_.trust_level is not None and data_.trust_level >= 1 and self.lookup_Alias_absolut(main_fingerprint) != "None":
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge statement data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=self.lookup_Alias(main_fingerprint), text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						if os.path.isfile(pathtostatement):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_statement_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
							nomergeButton = ctk.CTkButton(my_Frame, text="Don't merge data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							nomergeButton.place(relx=0.5, rely=0.75, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_statement_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
							noimportButton = ctk.CTkButton(my_Frame, text="Don't import data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							noimportButton.place(relx=0.5, rely=0.75, anchor="center")
					elif data_.trust_level is not None and data_.trust_level >= 1:
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge statement data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signed by:", text_color="light green", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.32, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv1 = ctk.CTkLabel(my_Frame, text=main_fingerprint, text_color="light green", fg_color="black", font=my_font)
						Labelv1.place(relx=0.5, rely=0.38, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", weight="normal", underline=False, overstrike=False)
						Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + data_.key_id, text_color="light green", fg_color="black", font=my_font)
						Labelv2.place(relx=0.5, rely=0.45, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
						Labelv3.place(relx=0.5, rely=0.52, anchor="center")
						if os.path.isfile(pathtostatement):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_statement_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
							nomergeButton = ctk.CTkButton(my_Frame, text="Don't merge data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							nomergeButton.place(relx=0.5, rely=0.75, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_statement_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
							noimportButton = ctk.CTkButton(my_Frame, text="Don't import data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							noimportButton.place(relx=0.5, rely=0.75, anchor="center")
					else:
						backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
						Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
						Label1 = ctk.CTkLabel(my_Frame, text="Import and merge statement data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
						Label1.place(relx=0.5, rely=0.11, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight="bold", underline=False, overstrike=False)
						Labelv = ctk.CTkLabel(my_Frame, text="Signature could not be verified!", text_color="red", fg_color="black", font=my_font)
						Labelv.place(relx=0.5, rely=0.34, anchor="center")
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
						if os.path.isfile(pathtostatement):
							mergeButton = ctk.CTkButton(my_Frame, text="Merge statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_merge_statement_data)
							mergeButton.place(relx=0.5, rely=0.66, anchor="center")
							nomergeButton = ctk.CTkButton(my_Frame, text="Don't merge data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							nomergeButton.place(relx=0.5, rely=0.75, anchor="center")
						else:
							importButton = ctk.CTkButton(my_Frame, text="Import statement data", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_import_statement_data)
							importButton.place(relx=0.5, rely=0.66, anchor="center")
							noimportButton = ctk.CTkButton(my_Frame, text="Don't import data!", text_color="white", fg_color="red", font=my_font, border_width=2, border_color="white", command=self.create_BitcoinWalletmeny)
							noimportButton.place(relx=0.5, rely=0.75, anchor="center")
						backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=discard_imported)
						backButton.place(relx=0.5, rely=0.94, anchor="center")
						
				else:
					messagebox.showinfo('Information', data_.status)
					self.select_what_to_sign()
			except FileNotFoundError:
					messagebox.showinfo("Information", "No settings file found.")
		
		def do_merge_statement_data():
			global content
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			USER_INP = ''
			USER_INP = simpledialog.askstring(title="Information!", prompt="Enter a max 6 character prefix (optional):")
			input_size = len(USER_INP)
			if input_size > 6:
				USER_INP = USER_INP[:6]
			with open(pathtoimportedstatement, 'r') as source, open(pathtostatement, 'a') as result:
				line = source.readline() #remove header
				line = source.readline()
				while line != "":
					if USER_INP != '':
						line_list = line.split(',')
						line_list[2] = USER_INP + ':' + line_list[2]
						if len(line_list[2]) > 30:
							line_list[2] = line_list[2][:30]
						line = line_list[0] + ',' + line_list[1] + ',' + line_list[2] + ',' + line_list[3] + ',' + line_list[4]
					result.write(line)
					line = source.readline()
					
			if os.path.isfile(pathtoimportedstatement):
				os.remove(pathtoimportedstatement)
			self.showWalletStatement(walletname)	
			
		def do_import_statement_data():
			global content
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			shutil.copy(pathtoimportedstatement, pathtostatement)
			if os.path.isfile(pathtoimportedstatement):
				os.remove(pathtoimportedstatement)
			self.showWalletStatement(walletname)	
		
		def discard_imported():
			if os.path.isfile(pathtoimportedstatement):
				os.remove(pathtoimportedstatement)
			self.showWalletStatement(walletname)
				
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Import and merge statement data from enrypted and signed file", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.11, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Decrypt with your private key and any signature is checked using all public keys on local keychain.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.18, anchor="w")
		
		Label21 = ctk.CTkLabel(my_Frame, text="The imported data will be merged with existing records for the wallets statement (if any).", text_color="white", fg_color="black", font=my_font)
		Label21.place(relx=0.05, rely=0.24, anchor="w")
		
		Label22 = ctk.CTkLabel(my_Frame, text="Before merge there is an option to add a short prefix to the comment field for all merged lines.", text_color="white", fg_color="black", font=my_font)
		Label22.place(relx=0.05, rely=0.3, anchor="w")
				
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight='bold', underline=False, overstrike=False)
		Button2 = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color='dark green', font=my_font, border_width=2, border_color="white", command=do_import_and_merge_statement)
		Button2.place(relx=0.5, rely=0.53, anchor="center")
		
		backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=150, height=32, font=my_font, command=partial(self.showWalletStatement, walletname))
		backButton.place(relx=0.5, rely=0.95, anchor="center")
							
	def encrypt_file(self):
		global clicked_publicKey
		global PersonalGPGKey
		global GPG_button_color
		
		pathtogroupsfile = "/home/user1/secure/groups.csv"
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_encrypt_file_on_USB():
			global clicked_publicKey
			decoded_fingerprint = ['N/A']
			encr_pass = False
			clicked_publicKey = str(clicked.get())
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_fingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_fingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
				
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			validity_for_key = self.get_key_validity(decoded_fingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
				time.sleep(2)
				tk.messagebox.showinfo('Information', 'Select the file you want to encrypt.')
				time.sleep(2)
				file_path = filedialog.askopenfilename(initialdir='/media/user1')
				
				completeName = file_path + '.asc'
				
				filename_list = file_path.split("/")
				filename_ = str(filename_list[-1])
				encfilename = filename_ + '.asc'
				
				# Read the file
				stream = open(file_path, 'rb')
					
				# Encrypt the file
				encrypted_data = gpg.encrypt_file(stream, decoded_fingerprint, always_trust=True)

				# Write the encrypted file if encryption went OK
				write_ok = False
				if encrypted_data.ok:
					try:
						with open(completeName, 'w') as f:
							f.write(str(encrypted_data))
							f.flush()
							os.fsync(f.fileno())
							write_ok = True
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
					os.system("sync")
					time.sleep(1)
					if write_ok:
						statusText = 'File has been encrypted and stored as:\n\n  ' + encfilename
						self.unmount_USBs(statusText)
						
					self.select_what_to_sign()
				else:
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")
				
		def do_encrypt_file_on_OD():
			global clicked_publicKey
			decoded_fingerprint = ['N/A']
			
			clicked_publicKey = str(clicked.get())
			# Check first if selected is a group
			it_is_a_group = self.check_if_group(clicked_publicKey)
			
			if it_is_a_group:
				decoded_fingerprint = self.get_members(clicked_publicKey)
			else:
				decoded_fingerprint[0] = self.lookup_fingerprint(clicked_publicKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			validity_for_key = self.get_key_validity(decoded_fingerprint)
			
			if validity_for_key[0] == 'g':
				answer = messagebox.askquestion('Web-of-trust!', 'One or more of the encryption keys in the group is not fully validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'u' or validity_for_key[0] == 'n':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is not validated by you or by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'm':
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is only marginally validated by the web-of-trust. Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			elif validity_for_key[0] == 'f':
				encr_pass = True
			else:
				answer = messagebox.askquestion('Web-of-trust!', 'The encryption key is unknown! Do you want to continue?')
				if answer == 'yes':
					encr_pass = True
				else:
					encr_pass = False
			
			if encr_pass:
				tk.messagebox.showinfo('Information', 'Select the file you want to encrypt.')
				time.sleep(1)
				file_path = filedialog.askopenfilename(initialdir='/home/user1/secure')
				
				filename_list = file_path.split("/")
				filename_ = str(filename_list[-1])
				encfilename = filename_ + '.asc'
				
				# Read the file
				stream = open(file_path, 'rb')
					
				# Encrypt the file
				encrypted_data = gpg.encrypt_file(stream, decoded_fingerprint, always_trust=True)
				
				answer = messagebox.askquestion('Information!', 'Do you want to save the encrypted file on an external USB-device?')
				if answer == 'yes':
					tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
					time.sleep(2)
					tk.messagebox.showinfo('Information', 'Select directory on the USB-device for the signed and encrypted file.')
					time.sleep(2)
					outputdir = filedialog.askdirectory(initialdir='/media/user1')
					outputfilesname = outputdir + "/" + encfilename
				else:
					outputfilesname = file_path + '.asc'	
				
				# Write the encrypted file if encryption and signing went OK
				if encrypted_data.ok:
					try:
						with open(outputfilesname, 'w') as f:
							f.write(str(encrypted_data))
							messagebox.showinfo('Information', 'File has been encrypted and stored as:\n\n  '+ encfilename)
					except FileNotFoundError:
						messagebox.showinfo("Warning!", "Could not write to file!")
						return False
				else:
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe the recipients key don't have the correct trust level or encryption capabilities?")

				self.select_what_to_sign()
			
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Encrypt a file using one of the public keys on the local keychain", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.05, rely=0.1, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Encryption will be done with the recipients public key.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.05, rely=0.17, anchor="w")
		
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
			
		List_fingerprints = []
		
		# Add groups first in list of public keys
		self.cleanupgroups()
		
		if os.path.isfile(pathtogroupsfile):
			try:
				with open(pathtogroupsfile, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines[1] not in List_fingerprints:	
							List_fingerprints.append(lines[1])
			except FileNotFoundError:
				print("Could not open groups file")
				
		public_fingerprints_and_aliases = []
		
		publickeysavailable = False
			
		for nkey in public_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
		
		if List_fingerprints:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)	
			clicked.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if publickeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select public key(s) to encrypt the file with (TO):", font=my_font, text_color="white", fg_color="black")
			Label1.place(relx=0.44, rely=0.4, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *public_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.45, rely=0.4, anchor="w")

			Button2 = ctk.CTkButton(my_Frame, text="Select file on a USB-device", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_file_on_USB)
			Button2.place(relx=0.83, rely=0.48, anchor="e")
			Button3 = ctk.CTkButton(my_Frame, text="Select file on Offline device", text_color="white", fg_color=GPG_button_color, font=my_font, border_width=2, border_color="white", command=do_encrypt_file_on_OD)
			Button3.place(relx=0.83, rely=0.54, anchor="e")
		else:
			Button = ctk.CTkButton(my_Frame, text="There are no public keys on the keychain. Create one now?", font=my_font, text_color="white", fg_color="green", border_width=2, border_color="white", command=self.importGPG_Key)
			Button.place(relx=0.5, rely=0.5, anchor="center")
			
	def list_sigs_on_key(self):
		global GPG_button_color
		global PersonalGPGKey
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		pathtobackg = "/home/user1/images/GnuPGbackground.JPG"
		
		top_Frame = ctk.CTkFrame(my_Frame, 
		width=1200, 
		height=150,
		border_width=2,
		border_color="green"
		)
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 146))
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=0, y=0, anchor="nw")
		top_Frame.focus_set()
		top_Frame.focus_force()
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1174, 
		height=484,
		orientation="vertical",
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		
		backg2 = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 496))
		Label_backg2 = ctk.CTkLabel(bottom_Frame, image=backg2, text = "")
		Label_backg2.place(x=2, y=2)
		bottom_Frame.place(x=0, y=150, anchor="nw")	
		bottom_Frame.focus_set()
		bottom_Frame.focus_force()
		
		def do_list_sigs_on_key():
			global clicked_publicKey
			
			bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
			width=1174, 
			height=484,
			orientation="vertical",
			border_width=2,
			border_color="green",
			fg_color="gray1"
			)
			
			backg2 = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 496))
			Label_backg2 = ctk.CTkLabel(bottom_Frame, image=backg2, text = "")
			Label_backg2.place(x=2, y=2)
			bottom_Frame.place(x=0, y=150, anchor="nw")	
			bottom_Frame.focus_set()
			bottom_Frame.focus_force()
			
			clicked_publicKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_publicKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			
			# Get sigs for the selected key
			public_keys = gpg.list_keys(sigs=True)
			temp_list = []
			# Loop through and display sigs
			if public_keys:
				for i in public_keys:
					if i['fingerprint'] == decoded_fingerprint and i['sigs']: 
						my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
				
						tuple_of_sigs_in_key = i['sigs']

						for ii in tuple_of_sigs_in_key:
							if ii:
								if ii[0] != i['keyid']:
									keyID = ii[0]
									
									user_id = ii[1]
									signature_class = ii[2]
									if keyID not in temp_list:
										Label = ctk.CTkLabel(bottom_Frame, text= ' ' + keyID + '   ' +  user_id, text_color="white", fg_color="black", font=my_font)
										Label.pack(padx=10, pady=1, side= TOP, anchor="w")
									
									temp_list.append(keyID)

		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
			
		List_fingerprints = []
		public_fingerprints_and_aliases = []
		
		pubickeysavailable = False
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)

		# List the private keys that can be used for signing			
		for i in public_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
				
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No public keys."')
			
		else:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(public_fingerprints_and_aliases[0])
			pubickeysavailable = True
				
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if pubickeysavailable == True:			
			Label5 = ctk.CTkLabel(top_Frame, text="Select public key to list signatures for:", text_color="white", fg_color="black", font=my_font)
			Label5.place(relx=0.4, rely=0.3, anchor="e")
			drop = OptionMenu(top_Frame, clicked, *public_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.41, rely=0.3, anchor="w")
			
			Button2 = ctk.CTkButton(top_Frame, text="List signatures", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_list_sigs_on_key)
			Button2.place(relx=0.65, rely=0.6, anchor="w")
		else:
			Button = ctk.CTkButton(top_Frame, text="There are no public keys on the keychain.", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font,command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.1, anchor="center")
						
	def sign_key_on_keychain(self):
		global GPG_button_color
		def do_sign_key_on_keychain():
			global clicked_privateKey
			global clicked_publicKey
			
			trusted_public_key = False
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			clicked_publicKey = str(clicked2.get())
			decoded_publifingerprint = self.lookup_fingerprint(clicked_publicKey)
			my_Frame = ctk.CTkFrame(self, 
			width=1200, 
			height=650,
			border_width=4,
			border_color="blue"
			)
			my_Frame.place(relx=0.5, rely=0.6, anchor="center")
			
			pathtobackg = self.get_background_image()
		
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			public_keys = gpg.list_keys()
			
			trusted_public_key = True
			
			if trusted_public_key:				
				# Sign the public key and pass argument fingerprint
				command= 'gpg --local-user ' + decoded_fingerprint + ' --quick-sign-key ' + decoded_publifingerprint
				
				os.system(command) 
				new_record = [decoded_fingerprint, "Signed a public key.", decoded_publifingerprint]
				self.add_record(new_record)
				new_record = [decoded_publifingerprint, "Signed/validated.", "With key:" + decoded_fingerprint]
				self.add_record(new_record)
				tk.messagebox.showinfo('Information', 'Please check that the key on the local keychain was signed.')
			self.create_GPGmeny()
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signing a public key on the local keychain using one of the private keys", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.18, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="(1). Select a private key to sign with *.  (2). Select the public key that you would like to sign.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.30, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="* If key has a signing subkey, then you might need to select the subkey instead.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.35, anchor="center")

		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
			
		List_fingerprints = []
		List_fingerprints2 = []
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False

		# List the private keys that can be used for signing			
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:	 
			for i in private_keys:
				if i['subkeys']: 
					listoflistindict = i['subkeys']
					dictofsubkeyinfo = i['subkey_info']
					for ii in listoflistindict:
						if ii:
							subkinfo = ii[0]
							capacity = dictofsubkeyinfo[subkinfo]['cap']
							if capacity == 's':
								List_fingerprints.append(subkinfo)	
	
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No private keys."')
		else:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_fingerprints2.append(i2['fingerprint'])
		
		if not List_fingerprints2:	
			tk.messagebox.showinfo('Information', 'No public keys."')
		else:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints2)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
				
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if privatekeysavailable == True:
			Label5 = ctk.CTkLabel(my_Frame, text="Select a private key to sign with:", text_color="white", fg_color="black", font=my_font)
			Label5.place(relx=0.4, rely=0.5, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.41, rely=0.5, anchor="w")
			Label6 = ctk.CTkLabel(my_Frame, text="Select the public key you want to sign:", text_color="white", fg_color="black", font=my_font)
			Label6.place(relx=0.4, rely=0.55, anchor="e")
			drop2 = OptionMenu(my_Frame, clicked2, *public_fingerprints_and_aliases)
			drop2.config(width=45)
			drop2.place(relx=0.41, rely=0.55, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Sign the public key", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_sign_key_on_keychain)
			Button2.place(relx=0.63, rely=0.61, anchor="w")
		else:
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the keychain. Create one now?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.65, anchor="center")
			Button = ctk.CTkButton(my_Frame, text="Or, import one?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=self.importGPG_Key)
			Button.place(relx=0.5, rely=0.72, anchor="center")	
	
	def get_background_image(self):
		pathtobackg = "/home/user1/images/blackbackground.jpg"
		if path_to_USB_secure == 'Secure USB folder is available':			
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			try:
				with open(completeName, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:	
							users_theme = lines[1]
							users_colors = lines[2]
			except FileNotFoundError:
				messagebox.showinfo("Information", "No settings file found.")
			if users_theme == 'Winter':
				pathtobackg = "/home/user1/images/winterbackgroundmid.jpg"
			if users_theme == 'Summer':
				pathtobackg = "/home/user1/images/summerbackgroundmid.jpg"
			if users_theme == 'Light':
				pathtobackg = "/home/user1/images/lightbackgroundmid.jpg"
			if users_theme == 'Dark':
				pathtobackg = "/home/user1/images/black.png"	
		return pathtobackg
	
	def sign_specific_key_on_keychain(self, fingerprint_to_sign):
		global GPG_button_color
		def do_sign_key_on_keychain():
			global clicked_privateKey
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			my_Frame = ctk.CTkFrame(self, 
			width=1200, 
			height=650,
			border_width=4,
			border_color="blue"
			)
			my_Frame.place(relx=0.5, rely=0.6, anchor="center")
			
			pathtobackg = self.get_background_image()
		
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
			Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
			Label_backg.place(x=0, y=0)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			public_keys = gpg.list_keys()
			
			trusted_public_key = True
			
			if trusted_public_key:				
				# Sign the public key and pass argument fingerprint
				command= 'gpg --local-user ' + decoded_fingerprint + ' --quick-sign-key ' + fingerprint_to_sign
				
				os.system(command) 
				new_record = [decoded_fingerprint, "Signed a public key.", fingerprint_to_sign]
				self.add_record(new_record)
				new_record = [fingerprint_to_sign, "Signed/validated.", "With key:" + decoded_fingerprint]
				self.add_record(new_record)
				tk.messagebox.showinfo('Information', 'Please check that the key on the local keychain was signed.')
			self.edit_public_key(fingerprint_to_sign)
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signing a public key on the local keychain using one of the private keys", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.2, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="(1). Select a private key to sign with *.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.30, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="* If key has a signing subkey, then you might need to select the subkey instead.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.35, anchor="center")

		private_keys = gpg.list_keys(True)
		public_keys = gpg.list_keys()
				
		clicked = StringVar()
		clicked2 = StringVar()
			
		List_fingerprints = []
		List_fingerprints2 = []
		private_fingerprints_and_aliases = []
		public_fingerprints_and_aliases = []
		
		privatekeysavailable = False

		# List the private keys that can be used for signing			
		for nkey in private_keys:
			if nkey['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(nkey['fingerprint'])
			
		if List_fingerprints:	 
			for i in private_keys:
				if i['subkeys']: 
					listoflistindict = i['subkeys']
					dictofsubkeyinfo = i['subkey_info']
					for ii in listoflistindict:
						if ii:
							subkinfo = ii[0]
							capacity = dictofsubkeyinfo[subkinfo]['cap']
							if capacity == 's':
								List_fingerprints.append(subkinfo)	
	
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No private keys."')
		else:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
		for i2 in public_keys:
			if i2['fingerprint'] != PersonalGPGKey:
				List_fingerprints2.append(i2['fingerprint'])
		
		if not List_fingerprints2:	
			tk.messagebox.showinfo('Information', 'No public keys."')
		else:
			public_fingerprints_and_aliases = self.get_Aliases(List_fingerprints2)
			clicked2.set(public_fingerprints_and_aliases[0])
			publickeysavailable = True
				
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if privatekeysavailable == True:
			Label5 = ctk.CTkLabel(my_Frame, text="Select a private key to sign with:", text_color="white", fg_color="black", font=my_font)
			Label5.place(relx=0.4, rely=0.5, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.41, rely=0.5, anchor="w")
			Label6 = ctk.CTkLabel(my_Frame, text="Public key to sign:", text_color="white", fg_color="black", font=my_font)
			Label6.place(relx=0.4, rely=0.55, anchor="e")
			fingerprint_to_sign
			Label66 = ctk.CTkLabel(my_Frame, text=fingerprint_to_sign, text_color="white", fg_color="black", font=my_font)
			Label66.place(relx=0.41, rely=0.55, anchor="w")
			Button2 = ctk.CTkButton(my_Frame, text="Sign the public key", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_sign_key_on_keychain)
			Button2.place(relx=0.62, rely=0.61, anchor="w")
		else:
			Button = ctk.CTkButton(my_Frame, text="There are no private keys on the keychain. Create one now?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=partial(self.newGPGFull_Key, "none"))
			Button.place(relx=0.5, rely=0.65, anchor="center")
			Button = ctk.CTkButton(my_Frame, text="Or, import one?", text_color="white", fg_color="green", font=my_font, border_width=2, border_color="white", command=self.importGPG_Key)
			Button.place(relx=0.5, rely=0.72, anchor="center")	
	
	def sign_document(self):
		global clicked_privateSubKey 
		#global outputdir
		global GPG_button_color
		
		def start_do_sign():
			tk.messagebox.showinfo("Information", "Insert USB-device and then click \"OK\".")
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the document to sign.')
			time.sleep(2)
			filepathSourcefile = filedialog.askopenfilename(initialdir='/media/user1')
			tk.messagebox.showinfo('Information', 'Select the output folder for the detached signature by double clicking on it.')
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			do_sign(filepathSourcefile, outputdir)
		
		def do_new_Bitcoinwallet(TimestampAddress, totalHash, outputfilesname, filename):
		
			path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
			
			now = datetime.now()
			dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
			dt_string_short = now.strftime("%Y-%m-%d")
					
			new_paperwallet = [
								"Timestamp",
								dt_string_short,
								TimestampAddress,
								totalHash,
								filename,
								outputfilesname,
								"Not payed"]

			with open(path_to_wallets, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_paperwallet)
		
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
						
		def do_sign(filepathSourcefile, outputdir):
			global clicked_privateSubKey
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			filename_list = filepathSourcefile.split("/")
			filename_ = str(filename_list[-1])
			sigfilename = filename_ + '.sig'
			outputfilesname = outputdir + "/" + sigfilename
			
			with open(filepathSourcefile, 'rb') as f: 
				try:
					data_ = gpg.sign_file(f, keyid=decoded_fingerprint, detach=True)
					f2 = open(outputfilesname, 'w')
					f2.write(str(data_))
					f2.close()
				except ValueError as ve:
					tk.messagebox.showinfo('Information', 'Something went wrong in signing!')
			pathtobackg = self.get_background_image()
			my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
			if data_.status == "signature created":
				if checkbox.get() == "on":
					# Create a timestamp Bitcoin address by hashing a combining of hashes from both signature file and document file
					# After sending sats to this new address it is prof that BOTH the signature and the signed data existed at the time the transaction was included in a block on the Bitcoin blockchain 
					
					# Make hash for document
					hashForDocument = sha256Hex(filepathSourcefile)
					
					# Make hash for signature
					hashForSignature = sha256Hex(outputfilesname)
					
					# Make combined hash for combination of document and signature hashes
					totalHash = hashForSignature + hashForDocument
					
					# Hash a Bitcoin address from the combined hash
					addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
					
					signatureAddress = addr.address
					
					# Generate a Bitcoin transaction including amount of 1100 sats to the newly hashed address
					transaction_payload = "bitcoin:" + signatureAddress + '?amount=0.00001100'
					
					# Clear screen and re-fill
					backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
					Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
					Label_backg.place(x=0, y=0)
		
					Label1 = ctk.CTkLabel(my_Frame, text="Signing a document using one of your private keys", text_color="white", fg_color="black", font=my_font)
					Label1.place(relx=0.5, rely=0.1, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label2 = ctk.CTkLabel(my_Frame, text="The signature file and the document together has created below QR- transaction.", text_color="white", fg_color="black", font=my_font)
					Label2.place(relx=0.5, rely=0.2, anchor="center")
					
					Label3 = ctk.CTkLabel(my_Frame, text="Scan the transaction QR-code and pay it and thereby making a proof on the Bitcoin blockchain.", text_color="white", fg_color="black", font=my_font)
					Label3.place(relx=0.5, rely=0.25, anchor="center")
					
					# Create a QR-code for the transaction
					pathtosignature = qrcode.make(transaction_payload)
					resize_pathtosignature = pathtosignature.resize((280, 280))
					pathtotransactionsignature = str(filepathdestinationfolder) + "/secure/transactionsignature.png"
					resize_pathtosignature.save(pathtotransactionsignature)
					loadimg = ctk.CTkImage(light_image=Image.open(pathtotransactionsignature), dark_image=Image.open(pathtotransactionsignature), size=(280, 280))
					Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
					Labelpublicimg.place(relx=0.72, rely=0.56, anchor="center")
					
					# Add the signatures transaction in the paper wallets CSV-file
					do_new_Bitcoinwallet(signatureAddress, totalHash, sigfilename, filename_)
					
					my_font = ctk.CTkFont(family="Arial", size=36, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="Success!", text_color="light green", font=my_font, fg_color="black")
					pubLabel.place(relx=0.35, rely=0.46, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=34, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.35, rely=0.55, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
					outLabel = ctk.CTkLabel(my_Frame, text="Output file:", text_color="white", font=my_font, fg_color="black")
					outLabel.place(relx=0.35, rely=0.64, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text=sigfilename, text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.35, rely=0.7, anchor="center")
					new_record = [decoded_fingerprint, "Signed file.", sigfilename + '.']
					self.add_record(new_record)
					scanLabel = ctk.CTkLabel(my_Frame, text="Pay address *:", text_color="white", fg_color="black", font=my_font)
					scanLabel.place(relx=0.72, rely=0.31, anchor="center")
					
					detailsButton = ctk.CTkButton(my_Frame, text="Details", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=partial(self.do_edit_Bitcoinwallets, signatureAddress))
					detailsButton.place(relx=0.72, rely=0.82, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label11 = ctk.CTkLabel(my_Frame, text="* Sending bitcoin to the stated address records the event (hashed proof) on the Bitcoin Blockchain.", text_color="white", fg_color="black", font=my_font)
					Label11.place(relx=0.05, rely=0.88, anchor="w")
					backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.select_what_to_sign)
					backButton.place(relx=0.5, rely=0.94, anchor="center")
				else:
					backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
					Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
					Label_backg.place(x=0, y=0)
					
					Label1 = ctk.CTkLabel(my_Frame, text="Signing a document using one of your private keys", text_color="white", fg_color="black", font=my_font)
					Label1.place(relx=0.5, rely=0.1, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
					
					Label2 = ctk.CTkLabel(my_Frame, text="The signature file has been created.", text_color="white", fg_color="black", font=my_font)
					Label2.place(relx=0.5, rely=0.2, anchor="center")
					
					Label3 = ctk.CTkLabel(my_Frame, text="Keep the signature file and the document file in the same directory.", text_color="white", fg_color="black", font=my_font)
					Label3.place(relx=0.5, rely=0.25, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=36, weight="bold", slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="Signature created!", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.5, rely=0.5, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=False, overstrike=False)
					pubLabel = ctk.CTkLabel(my_Frame, text="(" + sigfilename + ")", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.5, rely=0.62, anchor="center")
					new_record = [decoded_fingerprint, "Signed file.", sigfilename + '.']
					self.add_record(new_record)
					backButton = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color="black", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.select_what_to_sign)
					backButton.place(relx=0.5, rely=0.9, anchor="center")
			else:
				tk.messagebox.showinfo('Alert!', 'Something went wrong!')	
				self.select_what_to_sign()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		private_fingerprints_and_aliases = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Signing a document using one of your private keys", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select what document to sign, where to place the document after signing and what private key to sign with.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.2, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="(The output will be a detached signature (.sig) in the folder that you selected.)", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.25, anchor="center")

		private_keys = gpg.list_keys(True)
				
		clicked = StringVar()
			
		List_fingerprints = []
		
		privatekeysavailable = False
		
		# List the private keys that can be used for signing (exclude the Offline device own encryption key)			
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No private keys."')
		else:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
			
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		check_var = ctk.StringVar(value="off")
		
		checkbox = ctk.CTkCheckBox(my_Frame, text="Create timestamp *", font=my_font, variable=check_var, onvalue="on", offvalue="off", text_color="white", fg_color="black")
		checkbox.place(relx=0.74, rely=0.57, anchor="w")
		
		if privatekeysavailable == True:
			Label1 = ctk.CTkLabel(my_Frame, text="Select a private key to sign with:", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.54, rely=0.5, anchor="e")
			drop = OptionMenu(my_Frame, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.72, rely=0.57, anchor="e")
			Button = ctk.CTkButton(my_Frame, text="Start", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=start_do_sign)
			Button.place(relx=0.72, rely=0.64, anchor="e")
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
			Label11 = ctk.CTkLabel(my_Frame, text="* A Bitcoin transaction is needed to timestamp the document/signature combo.", text_color="white", fg_color="black", font=my_font)
			Label11.place(relx=0.2, rely=0.92, anchor="w")
			
		else:
			Button2 = ctk.CTkButton(my_Frame, text="There are no private keys on the keychain. Create one now?", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font,command=partial(self.newGPGFull_Key, "none"))
			Button2.place(relx=0.5, rely=0.65, anchor="center")
			Button3 = ctk.CTkButton(my_Frame, text="Or, import one?", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.72, anchor="center")	
	
	def signQRfromCamera(self, fingerprint):
		global clicked_privateSubKey
		
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt.sig\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt.sig', 'w', encoding='utf-8')
			c.write(str(signed_data))
			c.close()
			c2 = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c2.write(file_content)
			c2.close()
			messagebox.showinfo('Information', 'Signature file \"' +USER_INP + '.sig\" and data file \".txt\" has been saved to the USB-device')
			self.select_what_to_sign()
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="brown"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		
				
		if path_to_USB_secure == 'Secure USB folder is available':			
			link_to_signature_data = "/home/user1/secure/QRsignaturefile.txt"
			
			if os.path.isfile(link_to_signature_data):
				try:
					f = open(link_to_signature_data, "r")
					file_content = f.read()
					f.close()
					transactiondatoavailable = True
				except OSError:
					print("No file")
				signed_data = gpg.sign(file_content, keyid=fingerprint, detach=True)
				
				signed_data_address = qrcode.make(signed_data)
									
				resize_signed_data_address = signed_data_address.resize((390, 390))
				pathtoQRsignature = str(filepathdestinationfolder) + "/secure/signatureQRmessage.png"
				
				resize_signed_data_address.save(pathtoQRsignature)
				
				loadimg = ctk.CTkImage(light_image=Image.open(pathtoQRsignature), dark_image=Image.open(pathtoQRsignature), size=(390, 390))
				
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
				
				my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", underline=True, overstrike=False)
				pubLabel = ctk.CTkLabel(my_Frame, text="Signature:", text_color="white", font=my_font, fg_color="black")
				pubLabel.place(relx=0.5, rely=0.1, anchor="center")
				Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = loadimg)
				Labelpublicimg.place(relx=0.5, rely=0.45, anchor="center")
				new_record = [fingerprint, "Signed QR-code.", '']
				self.add_record(new_record)
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
				saveQRButton = ctk.CTkButton(my_Frame, text="Save signature to USB", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=save_to_USB)
				saveQRButton.place(relx=0.5, rely=0.8, anchor="center")
				onemoreButton = ctk.CTkButton(my_Frame, text="Sign another", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.sign_QR)
				onemoreButton.place(relx=0.5, rely=0.89, anchor="center")
				backButton = ctk.CTkButton(my_Frame, text="Back", text_color="black", fg_color="orange", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.select_what_to_sign)
				backButton.place(relx=0.5, rely=0.96, anchor="center")
			else:
				my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", underline=False, overstrike=False)
				pubLabel = ctk.CTkLabel(my_Frame, text="Could not read QR-data", text_color="white", font=my_font, fg_color="black")
				pubLabel.place(relx=0.5, rely=0.46, anchor="center")
		else:
			notOKButton = ctk.CTkButton(my_Frame, text="You are not logged in. Log in now?", text_color="white", fg_color="purple", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
		
	def sign_QR(self):
		global clicked_privateSubKey
		global outputdir
		global GPG_button_color
		
		def do_scan():
			global clicked_privateSubKey
			global outputdir
			
			clicked_privateKey = str(clicked.get())
			decoded_fingerprint = self.lookup_fingerprint(clicked_privateKey)
			self.readQRfromCameraToSign(decoded_fingerprint)
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
		private_fingerprints_and_aliases = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Scan a QR-code with the camera and sign the information with your private key", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.14, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		Label11 = ctk.CTkLabel(my_Frame, text="This could be a hash (checksum) from a large file or a Bitcoin address etc.", text_color="white", fg_color="black", font=my_font)
		Label11.place(relx=0.5, rely=0.25, anchor="center")
		
		Label2 = ctk.CTkLabel(my_Frame, text="Select a private key to sign with and then press \"Start camera\" to start scanning.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.35, anchor="center")
		
		Label3 = ctk.CTkLabel(my_Frame, text="You can save the detached signature as a file (.sig) or scan it back via a QR-code.", text_color="white", fg_color="black", font=my_font)
		Label3.place(relx=0.5, rely=0.41, anchor="center")
		
		private_keys = gpg.list_keys(True)
				
		clicked = StringVar()
			
		List_fingerprints = []
		
		privatekeysavailable = False
		
		# List the private keys that can be used for signing (exclude the Offline device own encryption key)			
		for i in private_keys:
			if i['fingerprint'] != PersonalGPGKey:
				List_fingerprints.append(i['fingerprint'])
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No private keys."')
		else:
			private_fingerprints_and_aliases = self.get_Aliases(List_fingerprints)
			clicked.set(private_fingerprints_and_aliases[0])
			privatekeysavailable = True
			
		# Get input on what key to use	
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if privatekeysavailable == True:
			Label1 = ctk.CTkLabel(self, text="Select a private key to sign with:", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.44, rely=0.65, anchor="e")
			drop = OptionMenu(self, clicked, *private_fingerprints_and_aliases)
			drop.config(width=45)
			drop.place(relx=0.45, rely=0.65, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
		
			startButton = ctk.CTkButton(self, text="Start camera", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=do_scan)
			startButton.place(relx=0.5, rely=0.75, anchor="center")
			
		else:
			Button2 = ctk.CTkButton(self, text="There are no private keys on the keychain. Create one now?", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font,command=partial(self.newGPGFull_Key, "none"))
			Button2.place(relx=0.5, rely=0.65, anchor="center")
			Button3 = ctk.CTkButton(self, text="Or, import one?", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.72, anchor="center")	
	
	def show_timestamp(self, frame_):
		global filepathdestinationfolder
		global path_to_data_file
		global path_to_sig
		
		the_blockchain_link = ' '
		
		def save_to_USB():
			tk.messagebox.showinfo('Information', 'Connect the USB-device and then click \"OK\".')
			time.sleep(2)
			tk.messagebox.showinfo('Information', 'Select the directory for the file.')
			time.sleep(2)
			outputdir = filedialog.askdirectory(initialdir='/media/user1')
			USER_INP = simpledialog.askstring(title="Required!", prompt="Name for file (the file type \".txt\" will be added automatically):")
			c = open(outputdir + '/' + USER_INP + '.txt', 'w', encoding='utf-8')
			c.write(the_blockchain_link)
			c.close()
			messagebox.showinfo('Information', 'File \"' +USER_INP + '.txt\"' + ' has been saved to the USB-device')
			self.select_what_to_sign()
			
		def sha256Hex(filename):
			BUF_SIZE = 65536
			
			sha256 = hashlib.sha256()
			
			with open(filename, 'rb') as f:
				while True:
					data = f.read(BUF_SIZE)
					if not data:
						break
					sha256.update(data)
					
			return sha256.hexdigest()
			
		# Make hash for document
		hashForDocument = sha256Hex(path_to_data_file)
		
		# Make hash for signature
		hashForSignature = sha256Hex(path_to_sig)
		
		# Make combined hash for combination of document and signature hashes
		totalHash = hashForSignature + hashForDocument
		
		# Hash a Bitcoin address from the combined hash
		addr = Address(totalHash, encoding='bech32', script_type='p2wsh')
		
		btcAddress = addr.address
		
		# Generate QR-codes for bitcoin address 
		qr_public_address = qrcode.make(btcAddress)
		resize_qr_public_address = qr_public_address.resize((160, 160))
		pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
		resize_qr_public_address.save(pathtopublic)
		publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(160, 160))
		Labelpublicimg = ctk.CTkLabel(frame_,  text = "", image = publicimg)
		Labelpublicimg.place(relx=0.2, rely=0.68, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
	
		pubLabel = ctk.CTkLabel(frame_, text="BTC address", text_color="white", font=my_font, fg_color="black")
		pubLabel.place(relx=0.2, rely=0.52, anchor="center")
		
		# Generate QR-codes for Blockchain search 
		the_blockchain_link = "www.mempool.space/address/" + str(btcAddress)
		qr_blockchain_address = qrcode.make(the_blockchain_link)
		resize_qr_blockchain_address = qr_blockchain_address.resize((200, 200))
		pathtoblockchain = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
		resize_qr_blockchain_address.save(pathtoblockchain)
		blockchainimg = ctk.CTkImage(light_image=Image.open(pathtoblockchain), dark_image=Image.open(pathtoblockchain), size=(200, 200))
		Labelblockchainimg = ctk.CTkLabel(frame_,  text = "", image = blockchainimg)
		Labelblockchainimg.place(relx=0.8, rely=0.65, anchor="center")
		
		pubLabel = ctk.CTkLabel(frame_, text="Blockchain link *:", text_color="white", font=my_font, fg_color="black")
		pubLabel.place(relx=0.8, rely=0.46, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		saveButton = ctk.CTkButton(frame_, text="Save to USB-device", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=save_to_USB)
		saveButton.place(relx=0.8, rely=0.83, anchor="center")
		infoLabel = ctk.CTkLabel(frame_, text="* Use Blockchain link to check if a timestamped transaction has been made to the BTC address.", text_color="white", font=my_font, fg_color="black")
		infoLabel.place(relx=0.18, rely=0.88, anchor="w")
					
	def check_document(self):
		global outputdir
		global GPG_button_color
		global path_to_data_file
		global path_to_sig
		
		def get_main_fingerprint_from_subkeyID(key_ID_tag):
			found_ = "no"
			# Get list of public keys
			public_keys = gpg.list_keys()

			# Loop through and display look for any containing a sign subkey
			if public_keys:
				for i in public_keys:
					subkey_lists = i['subkeys']
					# Loop though the subkeys lists 
					for ii in subkey_lists:
						if ii[1] == 's' and ii[0] == key_ID_tag: # If the subkey is signing key and the key ID match
							found_ = i['fingerprint']
				return found_
			
		asc_file_found = False		# If signed or clearsigned
		sig_file_found = False		# If detached signature
		manual_file_found = False
		file_found = False
		name_of_file = " "
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		public_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Checking a signed file with a public key on the local keychain", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="The file and it's detached signature file should be in the same directory.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.5, rely=0.2, anchor="center")

		public_keys = gpg.list_keys()
			
		List_fingerprints = []
		
		publickeysavailable = False
		
		# List the public keys that can be used for checking			
		for i in public_keys:
			List_fingerprints.append(i['fingerprint'])
		if not List_fingerprints:	
			tk.messagebox.showinfo('Information', 'No public keys."')
		else:
			publickeysavailable = True

		if publickeysavailable == True:
			result = tk.messagebox.askokcancel('Information', 'Connect the USB-device and then click \"OK\".')
			if not result:
				self.select_what_to_sign()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel('Information', 'Select the file/document you want to check.')
			if not result:
				self.select_what_to_sign()
				return
			time.sleep(2)
			path_to_data_file = filedialog.askopenfilename(initialdir='/media/user1')
			name_of_file = os.path.basename(path_to_data_file)
			# Try checking with signature in the same document
			try:
				open_stream = open(path_to_data_file, 'rb')
				file_found = True
			except FileNotFoundError:
				print("No file_found")
				
			if file_found:
				verified = gpg.verify_file(open_stream)
			else:
				verified = False
				
			if verified and verified.key_status == None:	
				Label11 = ctk.CTkLabel(my_Frame, text="The signature in file:\n", text_color="white", fg_color="black", font=my_font)
				Label11.place(relx=0.5, rely=0.55, anchor="center")
				Label22 = ctk.CTkLabel(my_Frame, text=name_of_file, text_color="white", fg_color="black", font=my_font)
				Label22.place(relx=0.5, my_Frame=0.6, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=True, overstrike=False)
				Label33 = ctk.CTkLabel(my_Frame, text="Is GOOD!", text_color="green", fg_color="black", font=my_font)
				Label33.place(relx=0.5, rely=0.7, anchor="center")
			else:
				# Try checking file/document with a file in same catalog and same name but with added .asc or .sig to the complete file name
				path_to_asc = path_to_data_file + '.asc'
				path_to_sig = path_to_data_file + '.sig'	
				try:
					open_stream = open(path_to_asc, 'rb')
					asc_file_found = True
					path_to_sig = path_to_asc
				except FileNotFoundError:
					print("No .asc file_found")
				if not asc_file_found:	
					try:
						open_stream = open(path_to_sig, 'rb')
						sig_file_found = True
					except FileNotFoundError:
							print("No .asc or .sig file_found")
						
				# If there was no .asc or .pgp signature files found
				if not asc_file_found and not sig_file_found:
					tk.messagebox.showinfo('Information', 'No signature file with extension .asc or .sig found!\nManually select the signature file.\n')
					path_to_signature = filedialog.askopenfilename(initialdir='/media/user1')
					try:
						open_stream = open(path_to_signature, 'rb')
						path_to_sig = path_to_signature
						manual_file_found = True
					except FileNotFoundError:
						print("Failed to open manually selected signature file")
				
				if asc_file_found or sig_file_found or manual_file_found:	
					verified = gpg.verify_file(open_stream, path_to_data_file)
				
				if verified:
					if get_main_fingerprint_from_subkeyID(verified.key_id) != "no":
						main_fingerprint = get_main_fingerprint_from_subkeyID(verified.key_id)
					else:
						main_fingerprint = verified.fingerprint
							
				if ((asc_file_found and verified) or (sig_file_found and verified) or (manual_file_found and verified)) and verified.key_status == None:
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
					Labelv = ctk.CTkLabel(my_Frame, text="The file \"" + name_of_file + "\" was signed by:", text_color="light green", fg_color="black", font=my_font)
					Labelv.place(relx=0.5, rely=0.32, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", weight="bold", underline=False, overstrike=False)
					Labelv1 = ctk.CTkLabel(my_Frame, text=self.lookup_Alias(main_fingerprint), text_color="light green", fg_color="black", font=my_font)
					Labelv1.place(relx=0.5, rely=0.42, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", weight="normal", underline=False, overstrike=False)
					Labelv2 = ctk.CTkLabel(my_Frame, text="Key ID :" + verified.key_id, text_color="light green", fg_color="black", font=my_font)
					Labelv2.place(relx=0.5, rely=0.48, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=28, slant="roman", weight="bold", underline=False, overstrike=False)
					Labelv3 = ctk.CTkLabel(my_Frame, text="Signature is good!", text_color="light green", fg_color="black", font=my_font)
					Labelv3.place(relx=0.5, rely=0.58, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight="bold", underline=False, overstrike=False)
					timestampbutton = ctk.CTkButton(my_Frame, text="Check Timestamp", text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, command=partial(self.show_timestamp, my_Frame))
					timestampbutton.place(relx=0.5, rely=0.65, anchor="center")
					
					my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
				elif (asc_file_found and not verified) or (sig_file_found and not verified) or (manual_file_found and not verified):
					my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", weight="normal", underline=False, overstrike=False)
					Label111 = ctk.CTkLabel(my_Frame, text="The signature for file:\n", text_color="white", fg_color="black", font=my_font)
					Label111.place(relx=0.5, rely=0.4, anchor="center")
					my_font = ctk.CTkFont(family="Verdana", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
					Label222 = ctk.CTkLabel(my_Frame, text=name_of_file, text_color="white", fg_color="black", font=my_font)
					Label222.place(relx=0.5, rely=0.5, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
					Label333 = ctk.CTkLabel(my_Frame, text="Is BAD!", text_color="red", fg_color="black", font=my_font)
					Label333.place(relx=0.5, rely=0.6, anchor="center")
				else:
					Label111 = ctk.CTkLabel(my_Frame, text="The signature for:\n", text_color="white", fg_color="black", font=my_font)
					Label111.place(relx=0.5, rely=0.55, anchor="center")
					my_font = ctk.CTkFont(family="Verdana", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
					Label222 = ctk.CTkLabel(my_Frame, text=name_of_file, text_color="white", fg_color="black", font=my_font)
					Label222.place(relx=0.5, rely=0.6, anchor="center")
					my_font = ctk.CTkFont(family="Arial", size=38, weight="bold", slant="roman", underline=True, overstrike=False)
					Label333 = ctk.CTkLabel(my_Frame, text="Could not be verified!", text_color="red", fg_color="black", font=my_font)
					Label333.place(relx=0.5, rely=0.7, anchor="center")
					
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			back_button = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=self.select_what_to_sign)
			back_button.place(relx=0.5, rely=0.94, anchor="center")
			
		else:
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Button3 = ctk.CTkButton(self, text="There are no public keys on the keychain. Import one now?", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font,command=self.importGPG_Key)
			Button3.place(relx=0.5, rely=0.53, anchor="center")
			back_button = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=GPG_button_color, border_width=2, border_color="white", font=my_font, command=self.select_what_to_sign)
			back_button.place(relx=0.5, rely=0.88, anchor="center")
	
	def avatar_decrypt_SecUSB(self, fingerprint):
		global path_to_USB_secure
		global PersonalGPGKey
		global filepathdestinationfolder
		global timeSecUSBLastModified
		PersonalGPGKey = fingerprint
		
		existing_hw_setting = self.get_hw_setting()	# Get HW setting for the individual user
		
		if existing_hw_setting[0] == "keyboard_mouse":
			k_1 = False
			m_1 = False
			k_2 = False
			m_2 = False
			# Check if keyboard or mouse has changed 
			existing_hw_data = self.get_sec_hw_data()			# Get stored HW data and serial number for the individual user
			count = 0
			while count < 5: # Try to avoid that the mouse or keyboard just is busy from kernel check multiple times
				# Get the current mouse data and serial number
				cmd = 'sudo lsusb | grep -i "mouse"'
				m_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_data = m_data.stdout.strip().decode("utf-8")
				real_m_data = clean_m_data.partition(":")
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'mouse' | awk '{print $6}') | grep 'iSerial'"
				m_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_serial = m_serial.stdout.strip().decode("utf-8")
				
				# Get the current keyboard data and serial number
				cmd = 'sudo lsusb | grep -i "keyboard"'
				k_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_data = k_data.stdout.strip().decode("utf-8")
				real_k_data = clean_k_data.partition(":")
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'keyboard' | awk '{print $6}') | grep 'iSerial'"
				k_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_serial = k_serial.stdout.strip().decode("utf-8")
				
				if real_k_data[2] == existing_hw_data[0].strip('"'):
					k_1 = True
				if clean_k_serial == existing_hw_data[1].strip('"'):
					k_2 = True
				if real_m_data[2] == existing_hw_data[2].strip('"'):
					m_1 = True
				if clean_m_serial == existing_hw_data[3].strip('"'):
					m_2 = True
				time.sleep(.1)
				count += 1
			# Compare if it never came true
			if not k_1 or not k_2:
				result = tk.messagebox.askokcancel("WARNING!", "THE KEYBOARD HAS BEEN MODIFIED OR CHANGED.\nYOU COULD BE SUBJECT TO AN ATTACKER TRYING TO SPY OR STEAL YOUR DATA.\n\nIf it was you that changed the keyboard then just click \"OK\" to continue.\n\nGo to \"Settings\" and click on \"Update settings\" to make this new/modified keyboard the recognized one.")
				if not result:
					self.create_meny()
					return
			if not m_1 or not m_2:
				result = tk.messagebox.askokcancel("WARNING!", "THE MOUSE HAS BEEN MODIFIED OR CHANGED.\nYOU COULD BE SUBJECT TO AN ATTACKER TRYING TO SPY OR STEAL YOUR DATA.\n\nIf it was you that changed the mouse then just click \"OK\" to continue.\n\nGo to \"Settings\" and click on \"Update settings\" to make this new/modified mouse the recognized one.")
				if not result:
					self.create_meny()
					return
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
		full_path = filepathdestinationfolder + '/' + fingerprint + 'securefolder.tar.gz.gpg'
		if os.path.isfile(full_path):
			try:
				out_path = filepathdestinationfolder + "/" + fingerprint + 'securefolder.tar.gz'
				data_ = gpg.decrypt_file(full_path, output=out_path)
				if data_.ok:
					tar = tarfile.open(filepathdestinationfolder + "/" + fingerprint + 'securefolder.tar.gz') 
					tar.extractall(filepathdestinationfolder + "/" + 'secure', filter='fully_trusted')
					tar.close()		
					os.remove(filepathdestinationfolder + "/" + fingerprint + "securefolder.tar.gz")

					path_to_USB_secure = 'Secure USB folder is available'
					
					timeSecUSBLastModified = str(time.ctime(os.path.getmtime(full_path)))
					self.create_meny()
				if data_.ok == False:
					messagebox.showinfo("Information", data_.status)
					messagebox.showinfo("Information", "Trying to recover from previous session.")
					full_path_recover = filepathdestinationfolder + '/Documents/RecoveryFor' + PersonalGPGKey + 'securefolder.tar.gz.gpg'
					data_ = gpg.decrypt_file(full_path_recover, output=out_path)
					if data_.ok:
						tar = tarfile.open(filepathdestinationfolder + "/" + fingerprint + 'securefolder.tar.gz') 
						tar.extractall(filepathdestinationfolder + "/" + 'secure', filter='fully_trusted')
						tar.close()		
						os.remove(filepathdestinationfolder + "/" + fingerprint + "securefolder.tar.gz")

						path_to_USB_secure = 'Secure USB folder is available'
						
						timeSecUSBLastModified = str(time.ctime(os.path.getmtime(full_path)))
						self.create_meny()
						if data_.ok == False:
							messagebox.showinfo("Information", data_.status)
							messagebox.showinfo("Information", "Automatic recovery failed. Please use a backup to restore your account.")
			except FileNotFoundError:
				messagebox.showinfo("Information", "No account found.")
		else:
			messagebox.showinfo("Information", "There is no account for the selected secret key.")		
					
	def decrypt_SecUSB(self):
		global path_to_USB_secure
		global filepathdestinationfolder
		global PersonalGPGKey
		global clicked_privateKey
		global timeSecUSBLastModified
		global SecUSB_button_color
		
		private_keys = []
		
		def store_selected():
			global path_to_USB_secure
			global PersonalGPGKey
			global filepathdestinationfolder
			global timeSecUSBLastModified
			clicked_privateKey = str(clicked.get())
			PersonalGPGKey = clicked_privateKey

			full_path = str(filepathdestinationfolder + "/" + clicked_privateKey + "securefolder.tar.gz.gpg")
			
			full_path = filepathdestinationfolder + '/' + clicked_privateKey + 'securefolder.tar.gz.gpg'
			if os.path.isfile(full_path):
				# Use PersonalGPGKey
				try:
					out_path = filepathdestinationfolder + "/" + clicked_privateKey + 'securefolder.tar.gz'
					data_ = gpg.decrypt_file(full_path, output=out_path)
					if data_.ok:
						tar = tarfile.open(filepathdestinationfolder + "/" + clicked_privateKey + 'securefolder.tar.gz') 
						tar.extractall(filepathdestinationfolder + "/" + 'secure', filter='fully_trusted')
						tar.close()		
						os.remove(filepathdestinationfolder + "/" + clicked_privateKey + "securefolder.tar.gz")
						my_Frame.place(relx=0.5, rely=0.6, anchor="center")
						Labelinf = ctk.CTkLabel(my_Frame, text="You have been logged in.", text_color="white", fg_color="black", font=my_font)
						Labelinf.place(relx=0.5, rely=0.4, anchor="center") 
						Labelinf2 = ctk.CTkLabel(my_Frame, text="Encryption standard: RFC 4880.", text_color="white", fg_color="black", font=my_font)
						Labelinf2.place(relx=0.5, rely=0.45, anchor="center") 
						Labelinf3 = ctk.CTkLabel(my_Frame, text="Key length: 4096 bits.", text_color="white", fg_color="black", font=my_font)
						Labelinf3.place(relx=0.5, rely=0.5, anchor="center") 
						time.sleep(1)
						path_to_USB_secure = 'Secure USB folder is available'
						
						timeSecUSBLastModified = str(time.ctime(os.path.getmtime(full_path)))
						self.create_meny()
					if data_.ok == False:
						messagebox.showinfo("Information", data_.status)
						messagebox.showinfo("Information", "Trying to recover from previous session.")
						full_path_recover = filepathdestinationfolder + '/Documents/RecoveryFor' + PersonalGPGKey + 'securefolder.tar.gz.gpg'
						data_ = gpg.decrypt_file(full_path_recover, output=out_path)
						if data_.ok:
							tar = tarfile.open(filepathdestinationfolder + "/" + fingerprint + 'securefolder.tar.gz') 
							tar.extractall(filepathdestinationfolder + "/" + 'secure', filter='fully_trusted')
							tar.close()		
							os.remove(filepathdestinationfolder + "/" + fingerprint + "securefolder.tar.gz")

							path_to_USB_secure = 'Secure USB folder is available'
							
							timeSecUSBLastModified = str(time.ctime(os.path.getmtime(full_path)))
							self.create_meny()
							if data_.ok == False:
								messagebox.showinfo("Information", data_.status)
								messagebox.showinfo("Information", "Automatic recovery failed. Please use a backup to restore your account.")
				except FileNotFoundError:
					messagebox.showinfo("Information", "No account found.")
			else:
				messagebox.showinfo("Information", "There is no account for the selected secret key.")			
				
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="purple"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		existing_hw_setting = self.get_hw_setting()	# Get HW setting for the individual user
		
		if existing_hw_setting[0] == "keyboard_mouse":
			k_1 = False
			m_1 = False
			k_2 = False
			m_2 = False
			# Check if keyboard or mouse has changed 
			existing_hw_data = self.get_sec_hw_data()			# Get stored HW data and serial number for the individual user
			
			count = 0
			while count < 5: # Try to avoid that the mouse or keyboard just is busy from kernel check multiple times..
				# Get the current mouse data and serial number
				cmd = 'sudo lsusb | grep -i "mouse"'
				m_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_data = m_data.stdout.strip().decode("utf-8")
				real_m_data = clean_m_data.partition(":")
				print(real_m_data)
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'mouse' | awk '{print $6}') | grep 'iSerial'"
				m_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)
				clean_m_serial = m_serial.stdout.strip().decode("utf-8")
				
				# Get the current keyboard data and serial number
				cmd = 'sudo lsusb | grep -i "keyboard"'
				k_data = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_data = k_data.stdout.strip().decode("utf-8")
				real_k_data = clean_k_data.partition(":")
				print(real_k_data)
				
				cmd = "sudo lsusb -v -d $(lsusb |grep -i 'keyboard' | awk '{print $6}') | grep 'iSerial'"
				k_serial = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE)  
				clean_k_serial = k_serial.stdout.strip().decode("utf-8")
				
				if real_k_data[2] == existing_hw_data[0].strip('"'):
					k_1 = True
				if clean_k_serial == existing_hw_data[1].strip('"'):
					k_2 = True
				if real_m_data[2] == existing_hw_data[2].strip('"'):
					m_1 = True
				if clean_m_serial == existing_hw_data[3].strip('"'):
					m_2 = True
				time.sleep(.1)
				count += 1
				
			# Compare if it never came true
			if not k_1 or not k_2:
				result = tk.messagebox.askokcancel("WARNING!", "THE KEYBOARD HAS BEEN MODIFIED OR CHANGED.\nYOU COULD BE SUBJECT TO AN ATTACKER TRYING TO SPY OR STEAL YOUR DATA.\n\nIf it was you that changed the keyboard then just click \"OK\" to continue.\n\nGo to \"Settings\" and click on \"Update settings\" to make this new/modified keyboard the recognized one.")
				if not result:
					self.create_meny()
					return
			if not m_1 or not m_2:
				result = tk.messagebox.askokcancel("WARNING!", "THE MOUSE HAS BEEN MODIFIED OR CHANGED.\nYOU COULD BE SUBJECT TO AN ATTACKER TRYING TO SPY OR STEAL YOUR DATA.\n\nIf it was you that changed the mouse then just click \"OK\" to continue.\n\nGo to \"Settings\" and click on \"Update settings\" to make this new/modified mouse the recognized one.")
				if not result:
					self.create_meny()
					return
						
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
			
		if path_to_USB_secure == 'Secure USB folder is available':
			# Display the keys <for information> if the secure folder has already been decrypted
			Label1 = ctk.CTkLabel(my_Frame, text="You are already logged in.", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.44, rely=0.4, anchor="e")
			Label11 = ctk.CTkLabel(my_Frame, text=PersonalGPGKey, text_color="white", fg_color="black", font=my_font)
			Label11.place(relx=0.45, rely=0.4, anchor="w")
			
		else:
			privatekeysavailable = False
			
			private_keys = gpg.list_keys(True)
			
			clicked = StringVar()
				
			List_fingerprints = []
			
			for i in private_keys:
				List_fingerprints.append(i['fingerprint'])
			
			if not List_fingerprints:	
				Button = ctk.CTkButton(my_Frame, text="There are no user accounts on the device. Create one now?", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font,command=self.create_getStartedmeny)
				Button.place(relx=0.5, rely=0.5, anchor="center")
			else:
				clicked.set(List_fingerprints[0])
				
				Label2 = ctk.CTkLabel(my_Frame, text="Select key for login *:", text_color="white", fg_color="black", font=my_font)
				Label2.place(relx=0.4, rely=0.4, anchor="e")

				drop = OptionMenu(my_Frame, clicked, *List_fingerprints)
				drop.place(relx=0.41, rely=0.4, anchor="w")

				Button2 = ctk.CTkButton(my_Frame, text="Log in **", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=store_selected)
				Button2.place(relx=0.63, rely=0.49, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=14, weight="bold", slant="roman", underline=False, overstrike=False)
		
				Labelinf1 = ctk.CTkLabel(my_Frame, text="* Key is used for decrypting the offline device.", text_color="white", fg_color="black", font=my_font)
				Labelinf1.place(relx=0.5, rely=0.8, anchor="center")
				Labelinf2 = ctk.CTkLabel(my_Frame, text="** Correct operation is only possible if time and date is set correcty. If the time/date can't be stored the internal battery needs to be replaced.", text_color="white", fg_color="black", font=my_font)
				Labelinf2.place(relx=0.5, rely=0.84, anchor="center")
				Button3 = ctk.CTkButton(my_Frame, text="Update time/date", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.create_getSettimetextbox)
				Button3.place(relx=0.5, rely=0.9, anchor="center")
	
	def make_SecUSB_archive(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global timeSecUSBLastModified
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
		# Try to copy over a copy of any external aliases (in case a recovery is needed in the future)
		path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
		path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
		if os.path.isfile(path_to_externalAliases):
			shutil.copy(path_to_externalAliases, path_to_externalAliases_localcopy)
			
		full_path = str(filepathdestinationfolder) + "/secure/"
	
		compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
		# Encrypt the tarfile and sefely remove the unencrypted tarfile (srm)
		encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
		cmd = 'shred -zu -n7 ' + filepathdestinationfolder + "/" + "secure.tar.gz"
		os.system(cmd)

		# Write the encrypted file to disk and also write to recovery if file is not zero
		compressedoutfile = open(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', 'w')
		compressedoutfile.write(str(encrypted_data))
		compressedoutfile.close()
		if os.stat(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg').st_size > 1000:
			shutil.copy(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', filepathdestinationfolder + '/Documents/RecoveryFor' + PersonalGPGKey + 'securefolder.tar.gz.gpg')
	
	def pre_encrypt_SecUSB(self):
		global filepathdestinationfolder
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=1,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		my_font = ctk.CTkFont(family="Helvetica", size=32, weight="bold", slant="roman", underline=False, overstrike=False)
		LLabel3 = ctk.CTkLabel(my_Frame, text="Logging out. Please wait......... ", text_color="white", fg_color="black", font=my_font)
		LLabel3.place(relx=0.5, rely=0.5, anchor="center")
		self.update()
		time.sleep(1)
		time.sleep(.2)
		self.encrypt_SecUSB()
					
	def encrypt_SecUSB(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="purple"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		private_keys = []
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			global timeSecUSBLastModified
			# Try to copy over a copy of any external aliases (in case a recovery is needed in the future)
			path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
			path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
			if os.path.isfile(path_to_externalAliases):
				shutil.copy(path_to_externalAliases, path_to_externalAliases_localcopy)
				
			full_path = str(filepathdestinationfolder) + "/secure/"
		
			compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
			# Encrypt the tarfile and sefely remove the unencrypted tarfile (srm)
			encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
			cmd = 'shred -zu -n7 ' + filepathdestinationfolder + "/" + "secure.tar.gz"
			os.system(cmd)

			# Write the encrypted file to disk and also write to recovery if file is not zero
			compressedoutfile = open(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', 'w')
			compressedoutfile.write(str(encrypted_data))
			compressedoutfile.close()
			if os.stat(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg').st_size > 1000:
				shutil.copy(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', filepathdestinationfolder + '/Documents/RecoveryFor' + PersonalGPGKey + 'securefolder.tar.gz.gpg')
			Labelinf = ctk.CTkLabel(my_Frame, text="You are being logged out.", text_color="white", fg_color="black", font=my_font)
			Labelinf.place(relx=0.5, rely=0.4, anchor="center") 
			Labelinf2 = ctk.CTkLabel(my_Frame, text="The device is being encrypted. Please wait..", text_color="white", fg_color="black", font=my_font)
			Labelinf2.place(relx=0.5, rely=0.45, anchor="center") 
			Labelinf3 = ctk.CTkLabel(my_Frame, text="(Encryption standard: RFC 4880)", text_color="white", fg_color="black", font=my_font)
			Labelinf3.place(relx=0.5, rely=0.5, anchor="center") 

			full_path = str(filepathdestinationfolder) + "/secure"
			cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
			os.system(cmd)
			cmd = 'rm -r ' +  full_path
			os.system(cmd)

			path_to_USB_secure = 'Secure USB folder is not available'
			timeSecUSBLastModified = '<Unknown>'
			self.set_colors('Varied')
			self.create_meny()
			
		else:
			Labelinf = ctk.CTkLabel(my_Frame, text="You are not logged in.", text_color="white", fg_color="black", font=my_font)
			Labelinf.place(relx=0.5, rely=0.4, anchor="center") 
			GPGButton = ctk.CTkButton(my_Frame, text="Home", text_color="white", font=my_font, border_width=2, border_color="white", fg_color=SecUSB_button_color, command=self.create_meny)
			GPGButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def new_secureUSB_Pre(self):
		global filepathdestinationfolder
		global SecUSB_button_color
		global s_width,s_height
		
		def clock():
			hour = time.strftime("%H")
			minute = time.strftime("%M")
			second = time.strftime("%S")
			
			timeLabel.config(text=hour + ":" + minute + ":" + second)
			timeLabel.after(1000, clock)
		
		def date():
			weekday = time.strftime("%A")
			dayofmonth = time.strftime("%d")
			month = time.strftime("%B")
			year = time.strftime("%Y")
			
			dateLabel.config(text=weekday + " the " + dayofmonth + " of " + month + ' ' + year)
			dateLabel.after(1000, date)
		def update():
			timeLabel.config(text="New Text")
			
		# Make sure time and date is correct before creating any new keys 	
		my_big_Frame = ctk.CTkFrame(self, 
		width=s_width, 
		height=s_height,
		border_width=0,
		border_color="black"
		)
		my_big_Frame.place(relx=0.5, rely=0.5, anchor="center")
		
		pathtobackg = "/home/user1/images/black.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(s_width, s_height))
		Label_backg = ctk.CTkLabel(my_big_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_big_Frame.focus_set()
		my_big_Frame.focus_force()
		
		my_Frame = ctk.CTkFrame(my_big_Frame, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		pathtobackg = "/home/user1/images/bluebackground.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		timeLabel = tk.Label(my_big_Frame, text="", font=("Helvetica", 16), fg="white", bg='black')
		dateLabel = tk.Label(my_big_Frame, text="", font=("Helvetica", 16), fg="white", bg='black')
		
		clock()
		date()
		
		timeLabel.place(relx=0.95, rely=0.94, anchor="e")
		dateLabel.place(relx=0.95, rely=0.97, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		homeButton = ctk.CTkButton(my_big_Frame, text="Home", text_color="white", border_width=2, border_color="white", fg_color="navy blue", font=my_font, command=self.create_meny)
		homeButton.place(relx=0.1, rely=0.1, anchor="center")
		
		HelpButton = ctk.CTkButton(my_big_Frame, text="Help", text_color="white", border_width=2, border_color="white", fg_color="dark orange", width=120, height=32, font=my_font, command=self.create_helpmeny)
		HelpButton.place(relx=0.93, rely=0.05, anchor="center")
		
		settimeButton = ctk.CTkButton(my_big_Frame, text="Settings", text_color="white", border_width=2, border_color="white", fg_color="navy blue", width=120, height=32, font=my_font, command=self.create_getSettimetextbox)
		settimeButton.place(relx=0.93, rely=0.1, anchor="center")
		
		ExitButton = ctk.CTkButton(my_big_Frame, text="Close and exit", text_color="white", border_width=2, border_color="white", fg_color="navy blue", width=120, height=32, font=my_font, command=self.pre_encryptanddestroy)
		ExitButton.place(relx=0.5, rely=0.95, anchor="center")
		
		my_Frame.focus_set()
		my_Frame.focus_force()			
		
		def do_new_secureUSB_Pre():
			global filepathdestinationfolder
			key_fingerprint = ''
			# Set the date and time
			thedate = cal.get_date()
			thetime = time_picker.time()
			
			thedatestr = str('sudo date -s \'' + str(thedate) + ' ' + str(thetime[0]) + ':' + str(thetime[1]) + ':00\'')			
			os.system(thedatestr)
			thestr = 'sudo hwclock -w'	
			os.system(thestr)
			os.system(thestr)
			self.new_secureUSB("none")
			
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Important! Before creating new account make sure the time and date are correct:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")
		
		time_picker = AnalogPicker(my_Frame, type=constants.HOURS24)
		time_picker.setHours(datetime.now().hour)
		time_picker.setMinutes(datetime.now().minute)
		time_picker.place(relx=0.65, rely=0.45, anchor="e")
		
		theme = AnalogThemes(time_picker)
		theme.setNavyBlue()
		time_picker.configAnalog(textcolor="#ffffff", bg="#0a0832", bdColor="#000000", headbdcolor="#000000")
		
		cal = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black", year=2025)
		cal.place(relx=0.65, rely=0.73, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
		Button = ctk.CTkButton(my_Frame, text="Next!", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_new_secureUSB_Pre)
		Button.place(relx=0.5, rely=0.86, anchor="center")
						
	def new_secureUSB(self, combinedValueBase58):
		global s_width,s_height
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		global stored_name, stored_email
		global diceFunction
		users_avatar_name = ''
		users_name_name = 'Bob Smith'
		stored_name = ''
		stored_email = ''
		new_Avatar_Entry = 'Anon'
		login_name = ''
		my_big_Frame = ctk.CTkFrame(self, 
		width=s_width, 
		height=s_height,
		border_width=0,
		border_color="black"
		)
		my_big_Frame.place(relx=0.5, rely=0.5, anchor="center")
		
		pathtobackg = "/home/user1/images/black.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(s_width, s_height))
		Label_backg = ctk.CTkLabel(my_big_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_big_Frame.focus_set()
		my_big_Frame.focus_force()
		
		my_Frame = ctk.CTkFrame(my_big_Frame, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		pathtobackg = "/home/user1/images/bluebackground.jpg"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		homeButton = ctk.CTkButton(my_big_Frame, text="Home", text_color="white", border_width=2, border_color="white", fg_color="navy blue", font=my_font, command=self.create_meny)
		homeButton.place(relx=0.1, rely=0.1, anchor="center")
		
		HelpButton = ctk.CTkButton(my_big_Frame, text="Help", text_color="white", border_width=2, border_color="white", fg_color="dark orange", width=120, height=32, font=my_font, command=self.create_helpmeny)
		HelpButton.place(relx=0.93, rely=0.05, anchor="center")
		
		settimeButton = ctk.CTkButton(my_big_Frame, text="Settings", text_color="white", border_width=2, border_color="white", fg_color="navy blue", width=120, height=32, font=my_font, command=self.create_getSettimetextbox)
		settimeButton.place(relx=0.93, rely=0.1, anchor="center")
		
		ExitButton = ctk.CTkButton(my_big_Frame, text="Close and exit", text_color="white", border_width=2, border_color="white", fg_color="navy blue", width=120, height=32, font=my_font, command=self.pre_encryptanddestroy)
		ExitButton.place(relx=0.5, rely=0.95, anchor="center")
		
		def limitSizePassphrase_text(*args):
			value = strong_password_var.get()
			if len(value) > 99: strong_password_var.set(value[:99])
		
		def clock():
			hour = time.strftime("%H")
			minute = time.strftime("%M")
			second = time.strftime("%S")
			
			timeLabel.config(text=hour + ":" + minute + ":" + second)
			timeLabel.after(1000, clock)
		
		def date():
			weekday = time.strftime("%A")
			dayofmonth = time.strftime("%d")
			month = time.strftime("%B")
			year = time.strftime("%Y")
			
			dateLabel.config(text=weekday + " the " + dayofmonth + " of " + month + ' ' + year)
			dateLabel.after(1000, date)
			
		def update():
			timeLabel.config(text="New Text")
			
		def tPassphrase():
			if Secret_passphrasePrivateEntry.cget('show') == '':
				Secret_passphrasePrivateEntry.configure(show='*')
			else:
				Secret_passphrasePrivateEntry.configure(show='')
		
		def show_progress(_value):
			my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=False, overstrike=False)
			LLabel3 = ctk.CTkLabel(my_Frame, text="Progress......... " + _value + " %", text_color="white", fg_color="black", font=my_font)
			LLabel3.place(relx=0.5, rely=0.71, anchor="center")
		
		def dice_password_pre():
			global stored_name, stored_email
			stored_name = namePrivateEntry.get()
			stored_email = userNameEntry.get()
			self.dicePassword("1")
			
		def do_new_secureUSB_pre():
			global stored_name, stored_email
			
			P_ = Secret_passphrasePrivateEntry.get()

			stored_name = namePrivateEntry.get()
			stored_email = userNameEntry.get()
			
			if len(P_) < 6:
				tk.messagebox.showinfo('Information', "Use min 6 characters in passphrase!")
			else:
				if len(stored_name) < 2:
					stored_name = 'Anon'
				
				time.sleep(0.4)
				show_progress('8')
				self.update()
				time.sleep(1)
				show_progress('25')
				self.update()
				time.sleep(1)
				show_progress('46')
				self.update()
				do_new_secureUSB()
						
		def do_new_secureUSB():
			global path_to_USB_secure
			global PersonalGPGKey
			global filepathdestinationfolder
			global timeSecUSBLastModified
			global stored_name, stored_email
			
			if path_to_USB_secure == 'Secure USB folder is available':
				Labelinf = ctk.CTkLabel(my_Frame, text="You are already logged in.", text_color="white", fg_color="black", font=my_font)
				Labelinf.place(relx=0.5, rely=0.4, anchor="center") 
				GPGButton = ctk.CTkButton(my_Frame, text="Home", text_color="white", font=my_font, border_width=2, border_color="white", fg_color=SecUSB_button_color, command=self.create_meny)
				GPGButton.place(relx=0.5, rely=0.5, anchor="center")
			else:				
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				nr_avatars = 0
				
				# Make sure folder secure is not already available
				full_path = filepathdestinationfolder + "/secure"
				if os.path.isdir(full_path):
					cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
					os.system(cmd)
					cmd = 'rm -r ' +  full_path
					os.system(cmd)
				
				# Create a GPG master key for personal use, namePrivateEntry emailPrivateEntry Secret_passphrasePrivateEntry
				input_data_priv = gpg.gen_key_input(key_type='rsa', name_real=stored_name, expire_date='0', key_length='4096', name_email="account@Offlinedevice", passphrase=Secret_passphrasePrivateEntry.get())
				
				privatekey = gpg.gen_key(input_data_priv)
				
				show_progress('55')
				self.update()
				
				privatekeyfilename = 'privateKey' + privatekey.fingerprint + ".gpg"
				full_path_private = filepathdestinationfolder + "/" + privatekeyfilename
				
				# Export the private key and write to file in /home/user1 and to /home/user1/secure/keys
				ascii_armored_private_key = gpg.export_keys(privatekey.fingerprint, True, expect_passphrase=False)
				f2 = open(full_path_private, 'w')
				f2.write(ascii_armored_private_key)
				f2.close()
				
				# Check if it was written correctly else stop
				if os.path.getsize(full_path_private) > 1000:
					path_to_USB_secure = 'Secure USB folder is available'
					PersonalGPGKey = privatekey.fingerprint
					if len(userNameEntry.get()) < 2:
						final_alias = "Anon" + PersonalGPGKey[-4:]
					else:
						final_alias = userNameEntry.get()
					new_external_alias = [PersonalGPGKey, final_alias, new_Avatar_Entry]
					# Add an entry in External alias file for avatar login (if less than 4 already)		
					path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
					if not os.path.isfile(path_to_externalAliases):
						f = open(path_to_externalAliases, 'w')
						writer = csv.writer(f)
						writer.writerow(new_external_alias)
						f.close()
					else:
						try:
							with open(path_to_externalAliases) as f:
								nr_avatars = sum(1 for line in f)
						except FileNotFoundError:
							messagebox.showinfo("Information", "No Alias file found.")
						if nr_avatars < 4:
							with open(path_to_externalAliases, 'a') as f:
								writer = csv.writer(f)
								writer.writerow(new_external_alias)
								
					# Create a Secure folder
					full_path = str(filepathdestinationfolder) + "/secure/"
					full_path_wallets = str(filepathdestinationfolder) + "/secure/wallets/"
					full_path_keys = str(filepathdestinationfolder) + "/secure/keys/"
					full_path_paperwallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/"
					full_path_settings_file = str(filepathdestinationfolder) + "/secure/settings.csv"
					full_path_paperwallets_file = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
					full_path_boltcards = str(filepathdestinationfolder) + "/secure/boltcards/"
					full_path_boltcards_file = str(filepathdestinationfolder) + "/secure/boltcards/boltcards.csv"
					full_path_FIDOKeys = str(filepathdestinationfolder) + "/secure/FIDO/"
					full_path_FIDOKeys_file = str(filepathdestinationfolder) + "/secure/FIDO/FIDOKeys.csv"
					full_path_IDs = str(filepathdestinationfolder) + "/secure/ID/"
					full_path_IDs_file = str(filepathdestinationfolder) + "/secure/ID/IDs.csv"
					
					os.makedirs(os.path.dirname(full_path))
					os.makedirs(os.path.dirname(full_path_wallets))
					os.makedirs(os.path.dirname(full_path_keys))
					os.makedirs(os.path.dirname(full_path_paperwallets))
					os.makedirs(os.path.dirname(full_path_boltcards))
					os.makedirs(os.path.dirname(full_path_FIDOKeys))
					os.makedirs(os.path.dirname(full_path_IDs))
					
					time.sleep(1)
					show_progress('72')
					self.update()
					
					# Make local copy for external alias (in case of recovery on new device)
					path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
					with open(path_to_externalAliases_localcopy, 'w') as f:
						writer = csv.writer(f)
						writer.writerow(new_external_alias)
						
					self.new_Alias_real_name(privatekey.fingerprint, "Offline device Key")
					
					c = open(full_path + "passwords.txt", 'w')
					c.write(str("Passwords and accounts\n___________________________________\n\nUser/account: \n\n   Password: \n\n   Comment: \n\n___________________________________\n\n"))
					c.close()
					c = open(full_path_wallets + "wallets.txt", 'w')
					c.write(str("Wallets\n___________________________________\n\nName: \n\n   Seed words/key: \n\n   Comment: \n\n___________________________________\n\n"))
					c.close()
					with open(full_path_settings_file, 'w', newline='') as file:
						writer = csv.writer(file)
						field = ['Username', 'Theme', 'Colors']
					with open(full_path_paperwallets_file, 'w', newline='') as file:
						writer = csv.writer(file)
						field = ['Name', 'Datecreated', 'Pubkey', 'wif', 'mnemonic', 'amount', 'Category']
					with open(full_path_boltcards_file, 'w', newline='') as file:
						writer = csv.writer(file)
						field = ['name', 'description', 'datecreated', 'LNURLaddress', 'resetcode', 'programmingcode', 'withdrawallimit', 'dailywithdrawallimit', 'LNHublink', 'LNHubuser', 'LNHubuserpassword']	
					with open(full_path_FIDOKeys_file, 'w', newline='') as file:
						writer = csv.writer(file)
						field = ['name', 'description', 'services']	
					with open(full_path_IDs_file, 'w', newline='') as file:
						writer = csv.writer(file)
						field = ['type', 'fingerprint', 'name', 'lastname', 'address', 'address2', 'birthdate', 'sex', 'issuedate']
					
					time.sleep(1)
					show_progress('85')
					self.update()
				
					destPriv = filepathdestinationfolder + "/secure/keys/" + privatekeyfilename
					shutil.copy(full_path_private, destPriv)
				
					# Make initial settings in settings file
					completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
					with open(completeName, 'w') as result:
						csvwriter = csv.writer(result)
						new_settings = [
										stored_name,
										'Standard',
										'Varied']

						csvwriter.writerow(new_settings)	

					iconopen_image = ctk.CTkImage(light_image=Image.open("/home/user1/images/iconopen.png"), dark_image=Image.open("/home/user1/images/iconopen.png"), size=(30, 30))
					openlock_Label = ctk.CTkLabel(self, text="", image=iconopen_image)
					openlock_Label.place(relx=0.02, rely=0.94, anchor="w")
					new_record = [PersonalGPGKey, "Offline device key created.", "Alias:" + final_alias]
					self.add_record(new_record)
					self.add_history("Account created!")
					# Make an encrypted archive just in case power goes out etc before user do shutdown or logout
					self.make_SecUSB_archive()
					stored_name = ''
					stored_email = ''
					
					show_progress('100')
					self.update()
					time.sleep(0.3)
					self.create_meny()
				else:
					stored_name = ''
					stored_email = ''
					try:
						key = gpg.delete_keys(privatekey.fingerprint, True, expect_passphrase=False) 
					except ValueError as ve:
						messagebox.showinfo('Information', 'Something went wrong (code "privkey").')
					try:
						key = gpg.delete_keys(privatekey.fingerprint) 
					except ValueError as ve:
						messagebox.showinfo('Information', 'Something went wrong (code "pubkey").')
					messagebox.showinfo('Warning!', "That didn't work!\nMaybe you inserted the wrong passphrase three times?")
					
					self.create_meny()
					
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		timeLabel = tk.Label(my_big_Frame, text="", font=("Helvetica", 16), fg="white", bg='black')
		dateLabel = tk.Label(my_big_Frame, text="", font=("Helvetica", 16), fg="white", bg='black')
		
		clock()
		date()
		
		timeLabel.place(relx=0.95, rely=0.94, anchor="e")
		dateLabel.place(relx=0.95, rely=0.97, anchor="e")
		
		my_font = ctk.CTkFont(family="Tahoma", size=34, weight="bold", slant="roman", underline=True, overstrike=False)
	
		Label = ctk.CTkLabel(my_Frame, text="Please provide your data:", text_color="white", fg_color="black", font=my_font)
		Label.place(relx=0.5, rely=0.18, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		# Data for the user account 
		userName = ctk.CTkLabel(my_Frame, text="Name for account:", text_color="white", fg_color="black", font=my_font)
		userName.place(relx=0.34, rely=0.33, anchor="e")
		
		users_avatar_name_var = StringVar()
		
		def limitSizeAvatarname(*args):
			value = users_avatar_name_var.get()
			if len(value) > 17: users_avatar_name_var.set(value[:17])
							
		users_avatar_name_var = ctk.StringVar(value=stored_email)
		users_avatar_name_var.trace('w', limitSizeAvatarname)
		
		userNameEntry = ctk.CTkEntry(my_Frame, placeholder_text=stored_email, textvariable=users_avatar_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		userNameEntry.place(relx=0.35, rely=0.33, anchor="w")
		
		namePrivate = ctk.CTkLabel(my_Frame, text="My name:", text_color="white", fg_color="black", font=my_font)
		namePrivate.place(relx=0.34, rely=0.39, anchor="e")
		
		users_name_name_var = StringVar()
		
		def limitSizeNamename(*args):
			value = users_name_name_var.get()
			if len(value) > 28: users_name_name_var.set(value[:28])
							
		users_name_name_var = ctk.StringVar(value=stored_name)
		users_name_name_var.trace('w', limitSizeNamename)
		
		namePrivateEntry = ctk.CTkEntry(my_Frame, placeholder_text=stored_name, textvariable=users_name_name_var, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		namePrivateEntry.place(relx=0.35, rely=0.39, anchor="w")
		
		LabelPassphrasePrivate = ctk.CTkLabel(my_Frame, text="Secret passphrase:", text_color="white", fg_color="black", font=my_font)
		LabelPassphrasePrivate.place(relx=0.34, rely=0.47, anchor="e")
		
		if combinedValueBase58 != "none":
			strong_password_var = ctk.StringVar(value=combinedValueBase58)
			strong_password_var.trace('w', limitSizePassphrase_text)
			Secret_passphrasePrivateEntry = ctk.CTkEntry(my_Frame, placeholder_text=combinedValueBase58, textvariable=strong_password_var, show='*', font=my_font, width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8)
			Secret_passphrasePrivateEntry.place(relx=0.35, rely=0.47, anchor="w")
			my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=False, overstrike=False)
		
			LLabel = ctk.CTkLabel(my_Frame, text="MAKE SURE YOU HAVE THE PASSPHRASE WRITTEN DOWN\nBEFORE PROCEEDING.", text_color="white", fg_color="black", font=my_font)
			LLabel.place(relx=0.5, rely=0.63, anchor="center")
		else:
			Secret_passphrasePrivateEntry = ctk.CTkEntry(my_Frame, placeholder_text="*****************", show='*', width=320, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			Secret_passphrasePrivateEntry.place(relx=0.35, rely=0.47, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		
		tButton = ctk.CTkButton(my_Frame, text="Show/hide", text_color="black", fg_color="pink", border_width=2, border_color="white", font=my_font, command=tPassphrase)
		tButton.place(relx=0.68, rely=0.47, anchor="center")
		diceFunction = "newAccount"
		doButton = ctk.CTkButton(my_Frame, text="Create strong password", text_color="white", fg_color="brown", border_width=2, border_color="white", width=240, height=32, font=my_font, command=dice_password_pre)
		doButton.place(relx=0.75, rely=0.47, anchor="w")
		
		Button = ctk.CTkButton(my_Frame, text="Create new account *", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_new_secureUSB_pre)
		Button.place(relx=0.43, rely=0.54, anchor="w")
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
		
		LLabel = ctk.CTkLabel(my_Frame, text="* This can take a while.. Move mouse around to create randomness....", text_color="white", fg_color="black", font=my_font)
		LLabel.place(relx=0.5, rely=0.94, anchor="center")
	
	def unmount_USBs(self, infomessage):
		os.system("sync")
		time.sleep(3)
				
		with open('/proc/mounts', 'r') as f:
			for line in f:
				parts = line.split()
				# USB devices on Linux typically start with /dev/sd
				if parts[0].startswith('/dev/sd'):
					cmd = 'sudo eject ' + parts[0]
					print(cmd)
					subprocess.run(cmd, shell=True)
			
		messagebox.showinfo("Information", infomessage + "\n\nNow you can safely remove the USB- device.")
			
					
	def copy_SecUSB(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()	
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		def do_copy_SecUSB():
			global filepathdestinationfolder
			global PersonalGPGKey
			failedExport = 0
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			if path_to_USB_secure == 'Secure USB folder is available':
				# Try to copy over a copy of any external aliases (in case a recovery is needed in the future)
				path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
				path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
				if os.path.isfile(path_to_externalAliases):
					shutil.copy(path_to_externalAliases, path_to_externalAliases_localcopy)
				full_path = str(filepathdestinationfolder) + "/secure/"
				# Ask the user if the private keys on the local keychain really has been backed-up to the secure archive
				answer = messagebox.askquestion('Important!', 'Has all the private keys been backed-up to the secure archive?')
				if answer == 'yes':
					result = tk.messagebox.askokcancel("Information", "Insert the USB-device and then click \"OK\".")
					if not result:
						self.copy_SecUSB()
						return
					time.sleep(2)
					result = tk.messagebox.askokcancel("Information", "Double click to select the USB-device and then select the directory where to place the backup.")
					if not result:
						self.copy_SecUSB()
						return
					time.sleep(2)
					USBdevice = filedialog.askdirectory(initialdir='/media/user1/')
					
					if USBdevice == '/home' or USBdevice == '/home/user1' or USBdevice == '/home/user1/secure' or USBdevice == '/media' or USBdevice == '/media/user1':
						messagebox.showinfo("Alert!", "This is not an external USB-device. Are you sure you double-clicked on the USB-device?")
						self.do_copy_SecUSB()
					else:
						Aliases = filepathdestinationfolder + "/secure/Alias.csv"
						archiveAliases = filepathdestinationfolder + "/secure/archiveAlias.csv"
						shutil.copy(Aliases, archiveAliases)
						# Set the path to where to place private key and encrypted tarfile
						now = datetime.now()
						dt_string_short = now.strftime("%Y%m%d")
						path_to_privatekeyfile = USBdevice + "/" + 'privateKey' + dt_string_short + '_' + PersonalGPGKey + '.gpg'
						path_to_archive = USBdevice + "/" + dt_string_short + '_' + PersonalGPGKey + 'securefolder.tar.gz.gpg'
						
						USER_INP = simpledialog.askstring(title="Input required!", prompt="Name for Backup files (optional):")
						
						if USER_INP != '':
							path_to_privatekeyfile = USBdevice + "/" + USER_INP + ".gpg"
							path_to_archive = USBdevice + "/" + USER_INP + 'securefolder.tar.gz.gpg'
							if os.path.isfile(path_to_archive): # Not to over write existing file if any
								now = datetime.now()
								dt_string = now.strftime("%Y%m%d-%H%M")
								path_to_archive = USBdevice + "/" + USER_INP + '(' + dt_string + ')' + 'securefolder.tar.gz.gpg'
								
						Label_backg.place(x=0, y=0)
						my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=False, overstrike=False)
						Label22 = ctk.CTkLabel(my_Frame, text="Working on it....", text_color="dark green", fg_color="black", font=my_font)
						Label22.place(relx=0.5, rely=0.6, anchor="center")
						time.sleep(2)
						full_path = filepathdestinationfolder + "/secure/"
						
						compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
						gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				
						# Encrypt the tarfile and sefely remove the unencrypted tarfile (srm)
						encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
						tar_path = filepathdestinationfolder + "/secure.tar.gz"
						
						if os.path.isfile(tar_path):
							cmd = 'shred -zu -n7 ' + tar_path
							os.system(cmd)

						# If encryption was OK then write the encrypted file to the USB-device 
						if encrypted_data.ok:
							try:
								f = open(path_to_archive, "w")
								f.write(str(encrypted_data))
								f.close()
							except Exception as e: print(e)
						
							ascii_armored_private_key = gpg.export_keys(PersonalGPGKey, True, expect_passphrase=False)
							
							try:
								f2 = open(path_to_privatekeyfile, "w")
								f2.write(ascii_armored_private_key)
								f2.close()
							except Exception as e: print(e)
								
							if os.path.isfile(path_to_archive):
								if os.path.getsize(path_to_archive) > 1000:
									if os.path.isfile(path_to_privatekeyfile):
										if os.path.getsize(path_to_privatekeyfile) > 1000:
											sizeArchive = str(round(os.path.getsize(path_to_archive) / 1000000, 2))
											sizeKey = str(round(os.path.getsize(path_to_privatekeyfile) / 1000, 2))
											statusText = "Backup files has been written to the USB-device!\n\nSecure archive:\n" + sizeArchive + " MB\n\nEncryption key:\n" + sizeKey + " kB\n"
											self.unmount_USBs(statusText)
											self.add_history("Account backup made to an USB-device!")
										else:
											messagebox.showinfo("Information", "That didn't work!\n\nBackup file for private key could not be written to the USB-device!")
								else:
									messagebox.showinfo("Information", "That didn't work!\n\nBackup file for secure archive could not be written to the USB-device!")
							self.create_meny()
						else:
							messagebox.showinfo("Information", "That didn't work!\n\nBackup file for secure archive could not be written to the USB-device!")
				else:
					messagebox.showinfo("Information", "Please backup the private keys from the local keychain to your Secure archive before backing up the account (under menu \"GPG -> Backup keys\").")
	
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			global timeSecUSBLastModified
			Label1 = ctk.CTkLabel(my_Frame, text="Make a backup to a USB-device", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.14, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			
			Label2 = ctk.CTkLabel(my_Frame, text="An encrypted backup will be stored on a USB-device together with a copy of the accounts key (for decrypting).", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.5, rely=0.24, anchor="center")
			
			Label22 = ctk.CTkLabel(my_Frame, text="Give the backup file a name or let the system name it. The files should be kept in the same folder.", text_color="white", fg_color="black", font=my_font)
			Label22.place(relx=0.5, rely=0.32, anchor="center")
			
			Label3 = ctk.CTkLabel(my_Frame, text="(Make sure that any changes on the local keychain has been backed up before proceeding.)", text_color="white", fg_color="black", font=my_font)
			Label3.place(relx=0.5, rely=0.4, anchor="center")
			
			theButton = ctk.CTkButton(my_Frame, text="Make a backup!", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_copy_SecUSB)
			theButton.place(relx=0.5, rely=0.52, anchor="center")
	
	def clone_microSD(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()	
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			Label1 = ctk.CTkLabel(my_Frame, text="Clone the system to a new microSD-card", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.14, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			Labelinf = ctk.CTkLabel(my_Frame, text="Cloning the device requires a microSD-card with minimum 32 GB.", text_color="white", fg_color="black", font=my_font)
			Labelinf.place(relx=0.5, rely=0.24, anchor="center") 

			Label2inf = ctk.CTkLabel(my_Frame, text="Use a USB-to-microSD adapter to connect the microSD-card.", text_color="white", fg_color="black", font=my_font)
			Label2inf.place(relx=0.5, rely=0.32, anchor="center")
						
			copySDButton = ctk.CTkButton(my_Frame, text="Clone the microSD card", text_color="white", font=my_font, border_width=2, border_color="white", fg_color=SecUSB_button_color, command=self.cloneSDcard)
			copySDButton.place(relx=0.5, rely=0.44, anchor="center")
			
	def restore_SecUSB(self):
		global path_to_USB_secure
		global timeSecUSBLastModified
		global filepathdestinationfolder
		global PersonalGPGKey
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()	
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			Label1 = ctk.CTkLabel(my_Frame, text="Restore an account from a backup on a USB-device", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.5, rely=0.14, anchor="center")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			Labelinf = ctk.CTkLabel(my_Frame, text="Connect a USB-device with both the encrypted file and the correct key to decrypt it.", text_color="white", fg_color="black", font=my_font)
			Labelinf.place(relx=0.5, rely=0.24, anchor="center") 

			Label2inf = ctk.CTkLabel(my_Frame, text="Any backed-up encryption keys will need to be restored to local keychain.", text_color="white", fg_color="black", font=my_font)
			Label2inf.place(relx=0.5, rely=0.32, anchor="center")
			
			ButtonRestore= ctk.CTkButton(my_Frame, text="Restore from USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.restoreFromencrypted_SecUSB)
			ButtonRestore.place(relx=0.5, rely=0.44, anchor="center")
					
	def cloneSDcard( self):
		global path_to_USB_secure, use_filter
		global SecUSB_button_color
		global filepathdestinationfolder
		
		use_filter = ' '
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="purple"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		
		if path_to_USB_secure == 'Secure USB folder is available':
			answer = messagebox.askquestion('Information!', 'Before cloning the system you will be logged out (all changes will be saved first). Insert the SD-card with adaptor now. \"From\" device is /dev/mmcblk0. Check the tick-box for new partition UUIDs. Are you SURE you want to proceed?')
			if answer == 'yes':
				full_path = str(filepathdestinationfolder) + "/secure/"
				self.add_history("System cloned to external storage media.")
				
				gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
				
				compressed_file = shutil.make_archive(full_path, 'gztar', full_path)
				# Encrypt the tarfile and remove the unencrypted tarfile
				encrypted_data = gpg.encrypt_file(compressed_file, PersonalGPGKey, always_trust=True) 
				
				cmd = 'shred -zu -n7 ' + filepathdestinationfolder + "/" + "secure.tar.gz"
				os.system(cmd)

				# Write the encrypted file to disk
				compressedoutfile = open(filepathdestinationfolder + "/" + PersonalGPGKey + 'securefolder.tar.gz.gpg', 'w')
				compressedoutfile.write(str(encrypted_data))
				compressedoutfile.close()
				full_path = str(filepathdestinationfolder) + "/secure"
				cmd = 'find ' +  full_path + ' -type f -exec shred -zu {} \\;'
				os.system(cmd)
				cmd = 'rm -r ' +  full_path
				os.system(cmd)
				path_to_USB_secure = 'Secure USB folder is not available'
				
				cmd = 'env SUDO_ASKPASS=/usr/lib/piclone/pwdpic.sh sudo -AE dbus-launch piclone'
				os.system(cmd)
				homeButton = ctk.CTkButton(my_Frame, text="Home", text_color="white", font=my_font, border_width=2, border_color="white", fg_color=SecUSB_button_color, command=self.create_meny)
				homeButton.place(relx=0.5, rely=0.6, anchor="center")
			else:
				messagebox.showinfo("Information", "Cloning process aborted!")
				self.check_SecUSB("none")
						
	def restoreFromencrypted_SecUSB(self):
		# Restore from a SecUSB encrypted USB-device 
		global filepathdestinationfolder
		global SecUSB_button_color
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		my_Frame.focus_set()
		my_Frame.focus_force()			
		
		def avatar_decrypt_SecUSB_and_restore(fingerprint):
			global path_to_USB_secure
			global PersonalGPGKey
			global filepathdestinationfolder
			global timeSecUSBLastModified
			PersonalGPGKey = fingerprint
			new_Avatar_Entry = "Recovered account"
			recovered_external_alias = [fingerprint, new_Avatar_Entry, 'Anon']
			gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
			
			full_path = filepathdestinationfolder + '/' + fingerprint + 'securefolder.tar.gz.gpg'
			out_path = filepathdestinationfolder + '/' + fingerprint + 'securefolder.tar.gz'
			# Decrypt with a selected avatar
			if os.path.isfile(full_path):
				# Decrypt and recover external alias from user secure archive 
				data_ = gpg.decrypt_file(full_path, output=out_path)
				if data_.ok:
					tar = tarfile.open(filepathdestinationfolder + "/" + fingerprint + 'securefolder.tar.gz') 
					tar.extractall(filepathdestinationfolder + '/secure', filter='fully_trusted')
					tar.close()		
					os.remove(filepathdestinationfolder + "/" + fingerprint + "securefolder.tar.gz")
					
					# Restore external alias from local copy (if any)
					path_to_externalAliases_localcopy = str(filepathdestinationfolder) + "/secure/externalAliases_localcopy.csv"
					
					if os.path.isfile(path_to_externalAliases_localcopy):
						with open(path_to_externalAliases_localcopy, 'r') as file:
							csvfile = csv.reader(file)
							for row in csvfile:
								if row[0] == fingerprint:
									recovered_external_alias = [fingerprint, row[1], row[2]]
					
					# If own avatar in secure archive copy over to device
					if recovered_external_alias[2] != 'Anon' and recovered_external_alias[2] != 'Male' and recovered_external_alias[2] != 'Woman' and recovered_external_alias[2] != 'Boy' and recovered_external_alias[2] != 'Girl' and recovered_external_alias[2] != 'Yin Yang' and recovered_external_alias[2] != 'Skull':
						pathtopicturearchivelocation = filepathdestinationfolder + "/secure/" + PersonalGPGKey + '.png'
						pathtopicturelocation = filepathdestinationfolder + "/Documents/" + PersonalGPGKey + '.png'
						if os.path.isfile(pathtopicturearchivelocation):
							shutil.copy(pathtopicturearchivelocation, pathtopicturelocation)
						else:
							# Pic file not found in secure folder so set external avatar to anon again
							recovered_external_alias[2] = 'Anon'
					 
					# Add an entry in External alias file for avatar login (if less than 4 already)
					path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
					if not os.path.isfile(path_to_externalAliases):
						f = open(path_to_externalAliases, 'w')
						writer = csv.writer(f)
						writer.writerow(recovered_external_alias)
						f.close()
					else:
						with open(path_to_externalAliases) as f:
							nr_avatars = sum(1 for line in f)
						
						if nr_avatars < 4:
							with open(path_to_externalAliases, 'a') as f:
								writer = csv.writer(f)
								writer.writerow(recovered_external_alias)
						
					path_to_USB_secure = 'Secure USB folder is available'
					
					timeSecUSBLastModified = str(time.ctime(os.path.getmtime(full_path)))
					return True
				if data_.ok == False:
					messagebox.showinfo("Information", data_.status)
					return False
				return False	
				
		def do_restoreFromencrypted_SecUSB():
			global filepathdestinationfolder
			key_fingerprint = ''
			
			def decrypt_and_restore():
				# Add an entry in External alias file for avatar login (if less than 4 already)
				new_Avatar_Entry = "Recovered account"
				recoveredPersonalGPGKey = import_result.fingerprints[0]	
				new_external_alias = [recoveredPersonalGPGKey, new_Avatar_Entry, 'Anon']
				path_to_externalAliases = str(filepathdestinationfolder) + "/Documents/externalAliases.csv"
				if not os.path.isfile(path_to_externalAliases):
					f = open(path_to_externalAliases, 'w')
					writer = csv.writer(f)
					writer.writerow(new_external_alias)
					f.close()
				else:
					try:
						with open(path_to_externalAliases) as f:
							nr_avatars = sum(1 for line in f)
					except FileNotFoundError:
						messagebox.showinfo("Information", "No Alias file found.")
					if nr_avatars < 4:
						with open(path_to_externalAliases, 'a') as f:
							writer = csv.writer(f)
							writer.writerow(new_external_alias)
							
			# Set the date and time
			thedate = cal.get_date()
			thetime = time_picker.time()
			
			thedatestr = str('sudo date -s \'' + str(thedate) + ' ' + str(thetime[0]) + ':' + str(thetime[1]) + ':00\'')			
			os.system(thedatestr)
			thestr = 'sudo hwclock -w'	
			os.system(thestr)
			os.system(thestr)
			
			# Select the file with the private key and scan it for fingerprint
			result = tk.messagebox.askokcancel("Information", "Insert the USB-device with the backup data and click \"OK\".")
			if not result:
				self.restore_SecUSB()
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel("Information", "Select the key for the account (could start with \"privateKey\" and ends with \".gpg\" or be with a custom name).")
			if not result:
				self.restore_SecUSB()
				return
			time.sleep(2)
			
			filepathkeyfile = filedialog.askopenfilename(initialdir='/media/user1')	
			directory_path = os.path.dirname(os.path.abspath(filepathkeyfile))
			file_name = Path(filepathkeyfile).stem
			
			keys = gpg.scan_keys(filepathkeyfile)
			key_fingerprint = str(keys.fingerprints[0])
			
			# Restore private key
			full_path = filepathdestinationfolder + '/privateKey' + key_fingerprint + '.gpg'
			# Check if the private key already is in the /user/home directory
			if os.path.isfile(full_path):
				answer = messagebox.askquestion('WARNING!', 'WARNING! There\'s already a key with that fingerprint on the offline device! Are you SURE you want to proceed?')
				if answer == 'yes':
					# Copy over the encrypted private key
					shutil.copy(filepathkeyfile, full_path)
					import_result = gpg.import_keys_file(full_path)
					gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_ULTIMATE')
				else:
					messagebox.showinfo("Information", "OK. Keeping the existing key on the offline device.")
			else:
				# Copy over the encrypted private key
				shutil.copy(filepathkeyfile, full_path)
				try:
					import_result = gpg.import_keys_file(full_path)
					gpg.trust_keys(import_result.fingerprints, trustlevel='TRUST_ULTIMATE')
				except ValueError as ve:
					messagebox.showinfo('Information', 'Something went wrong! Check that you set correct date and time before trying to restore an account!')
					self.create_meny()
					return
			
			# Copy secure archive file
			result = tk.messagebox.askokcancel("Information", "Now select the encrypted backup archive (could end with \".securefolder.tar.gz.gpg\" or other).")
			if not result:
				self.restore_SecUSB()
				return
				
			time.sleep(2)
			filepatharchivefile = filedialog.askopenfilename(initialdir='/media/user1')
			
			full_path_archive = filepathdestinationfolder + '/' + key_fingerprint + 'securefolder.tar.gz.gpg'
			
			shutil.copy(filepatharchivefile, full_path_archive)
			
			# Decrypt and cover any external alias information
			result = avatar_decrypt_SecUSB_and_restore(key_fingerprint)
			if result:
				answer2 = messagebox.askquestion('Information!', 'Do you also want to restored all backed-up encryption keys (this can also be done later)?')
				if answer2 == 'yes':
					self.do_all_keys()
				messagebox.showinfo("Information", "The account has been restored from backup.")
				self.create_meny()
				return
			else:
				messagebox.showinfo("Information", "That didn't work!") 
				self.create_meny()
				return
		
		gpg = gnupg.GPG(gnupghome='/home/user1/.gnupg/')
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
		
		Label1 = ctk.CTkLabel(my_Frame, text="Important! Make sure to set the correct date and time:", text_color="white", fg_color="black", font=my_font)
		Label1.place(relx=0.5, rely=0.1, anchor="center")

		time_picker = AnalogPicker(my_Frame, type=constants.HOURS24)
		time_picker.setHours(datetime.now().hour)
		time_picker.setMinutes(datetime.now().minute)
		time_picker.place(relx=0.65, rely=0.45, anchor="e")
		
		theme = AnalogThemes(time_picker)
		theme.setNavyBlue()
		time_picker.configAnalog(textcolor="#ffffff", bg="#0a0832", bdColor="#000000", headbdcolor="#000000")
		
		cal = DateEntry(my_Frame, width=20, text_color="white", bg="darkblue", fg="black", year=2025)
		cal.place(relx=0.65, rely=0.73, anchor="e")
			
		Button = ctk.CTkButton(my_Frame, text="Start restoring from backup!", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=do_restoreFromencrypted_SecUSB)
		Button.place(relx=0.5, rely=0.86, anchor="center")
	
	def file_is_a_systemfile(self, pathlink):
		global filepathdestinationfolder
		full_path = str(filepathdestinationfolder) + "/Documents/Systemfiles.txt"
		if os.path.isfile(full_path):
			with open(full_path, 'r') as file:
				lines = [line.strip() for line in file.readlines()]
			if pathlink in lines:
				return True
		return False
	
	def take_picture(self):
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/take_picture.py'], shell=True)
		original_img = Image.open('/home/user1/secure/taken_picture.jpg')
		v_image = original_img.transpose(method=Image.FLIP_TOP_BOTTOM)
		real_image = v_image.transpose(method=Image.FLIP_LEFT_RIGHT)
		
		time.sleep(1)
		result = tk.messagebox.askokcancel("Information", "Select where to save the picture.")
		if not result:
			self.check_SecUSB('none')
			return
		time.sleep(1)
		save_dir = filedialog.askdirectory(initialdir='/home/user1/secure/')
		
		# Ask for name for file (optional).
		USER_INP = simpledialog.askstring(title="Information!", prompt="Enter a name for the file (\".jpg\" will be added automatically):")
		input_size = len(USER_INP)
		if input_size > 42:
			messagebox.showinfo("Information", "The filename can be max 42 characters.")
			self.check_SecUSB('none')
		else:
			if USER_INP == '':
				now = datetime.now()
				dt_string = now.strftime("%Y-%m-%d %H-%M-%S")
				USER_INP = 'picture_' + dt_string + '.jpg'
			
			new_location = save_dir + '/' + USER_INP + '.jpg'	
			real_image.save(new_location)
			if os.path.isfile('/home/user1/secure/taken_picture.jpg'):
				os.remove('/home/user1/secure/taken_picture.jpg')
				self.add_history("Picture taken (" + USER_INP + '.jpg)')
				tk.messagebox.showinfo('Information', 'Picture has been saved as:\n\n' + USER_INP + '.jpg')
			else:
				tk.messagebox.showinfo('Information', "That didn't work")			
		self.check_SecUSB('none')
		return
	
	def take_ID_picture(self):
		subprocess.run(['/home/user1/myenv/bin/python /home/user1/take_ID_picture.py'], shell=True)
		original_img = Image.open('/home/user1/secure/taken_ID_picture.jpg')
		v_image = original_img.transpose(method=Image.FLIP_TOP_BOTTOM)
		real_image = v_image.transpose(method=Image.FLIP_LEFT_RIGHT)
		
		w, h = real_image.size
		res = real_image.crop((w/2 - h/3.068, h/12, w/2 + h/3.068, h-h/12))
		time.sleep(1)
		result = tk.messagebox.askokcancel("Information", "Select where to save the picture.")
		if not result:
			self.check_SecUSB('none')
			return
		time.sleep(1)
		save_dir = filedialog.askdirectory(initialdir='/home/user1/secure/')
		
		# Ask for name for file (optional).
		USER_INP = simpledialog.askstring(title="Information!", prompt="Enter a name for the file (\".jpg\" will be added automatically):")
		input_size = len(USER_INP)
		if input_size > 42:
			messagebox.showinfo("Information", "The filename can be max 42 characters.")
			self.check_SecUSB('none')
		else:
			if USER_INP == '':
				now = datetime.now()
				dt_string = now.strftime("%Y-%m-%d %H-%M-%S")
				USER_INP = 'picture_' + dt_string + '.jpg'
			
			new_location = save_dir + '/' + USER_INP + '.jpg'	
			res.save(new_location)
			if os.path.isfile('/home/user1/secure/taken_ID_picture.jpg'):
				os.remove('/home/user1/secure/taken_ID_picture.jpg')
				self.add_history("Picture taken (" + USER_INP + '.jpg)')
				tk.messagebox.showinfo('Information', 'Picture has been saved as:\n\n' + USER_INP + '.jpg')
			else:
				tk.messagebox.showinfo('Information', "That didn't work")	
		self.check_SecUSB('none')
		return
						
	def check_SecUSB(self, key):
		global PersonalGPGKey
		global SecUSB_button_color, use_filter
		
		file_list = []
		
		my_Frame = ctk.CTkFrame(self,
		width=1200, 
		height=650,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		top_Frame = ctk.CTkScrollableFrame(my_Frame,
		width=1176, 
		height=634,
		border_width=2,
		border_color="green",
		fg_color="gray1"
		)
		pathtobackg = "/home/user1/images/black.png"
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1176, 630))
		Label_backg = ctk.CTkLabel(top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		top_Frame.place(x=0, y=0, anchor="nw")
		
		more_info_text = "Secure archive:\n\nAll files and folders placed under the folder /home/user1/secure/ will be encrypted each time the user click on \"Close and exit\" or \"Logout\". When cloning or making a backup of the system it is these files and folders that will be included. It is best to keep only small, and the most important files, in the secure archive as it will effects both the startup and closing time of the system.\n\nBlue = System files.\n\nYellow = Text files.\n\nGreen = Encryption files.\n\nPurple = Image files."
		
		def more_info():
			tk.messagebox.showinfo('Information', more_info_text)
		
		def search_data():
			global use_filter
			
			search_key = searchEntry.get()
			use_filter = search_key
			
			self.check_SecUSB('none')
			return
		
		def limitSearchField(*args):
			value = Search_var.get()
			if len(value) > 42: Search_var.set(value[:42])
		
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		Button = ctk.CTkButton(my_Frame, text="Add file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.addfile_SecUSB)
		Button.place(relx=0.03, rely=0.05, anchor="w")
		Button2 = ctk.CTkButton(my_Frame, text="Remove file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.removefile_SecUSB)
		Button2.place(relx=0.16, rely=0.05, anchor="w")
		Button3 = ctk.CTkButton(my_Frame, text="Add folder", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.add_directory_SecUSB)
		Button3.place(relx=0.29, rely=0.05, anchor="w")
		Button4 = ctk.CTkButton(my_Frame, text="Remove folder", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.remove_directory)
		Button4.place(relx=0.42, rely=0.05, anchor="w")
		zipButton = ctk.CTkButton(my_Frame, text="Zip", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=70, height=28, font=my_font, command=self.zip_directory)
		zipButton.place(relx=0.55, rely=0.05, anchor="w")
		tarButton = ctk.CTkButton(my_Frame, text="Tar folder", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=90, height=28, font=my_font, command=self.tar_directory)
		tarButton.place(relx=0.63, rely=0.05, anchor="w")
		picButton = ctk.CTkButton(my_Frame, text="Take Picture", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=90, height=28, font=my_font, command=self.take_picture)
		picButton.place(relx=0.53, rely=0.1, anchor="w")
		IDpicButton = ctk.CTkButton(my_Frame, text="ID pic", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=90, height=28, font=my_font, command=self.take_ID_picture)
		IDpicButton.place(relx=0.63, rely=0.1, anchor="w")
		Button5 = ctk.CTkButton(my_Frame, text="Copy a file from archive to USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=280, height=28, font=my_font, command=self.copyfile_SecUSB)
		Button5.place(relx=0.86, rely=0.05, anchor="center")
		Button6 = ctk.CTkButton(my_Frame, text="Copy a file from USB to USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=280, height=28, font=my_font, command=self.copyfile_USB_to_USB)
		Button6.place(relx=0.86, rely=0.1, anchor="center")
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=True, overstrike=False)
		filterLabel = ctk.CTkLabel(my_Frame, text="Filter:", text_color="white", font=my_font, fg_color="black")
		filterLabel.place(relx=0.85, rely=0.24, anchor="e")
		my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
		editButton = ctk.CTkButton(my_Frame, text="Edit Filter", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=80, height=22, font=my_font, command=self.filter_SecUSB)
		editButton.place(relx=0.87, rely=0.24, anchor="w")
		
		filter_path = filepathdestinationfolder + '/secure/' + PersonalGPGKey + '_filter.cvs'
		# Add a default filter if no filter file 
		if not os.path.isfile(filter_path):
			default_filter = ['Encryption keys', '/home/user1/secure/keys/']
			with open(filter_path, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(default_filter)
		padding = 0.3	
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)	
		if os.path.isfile(filter_path):
			# Look in filter CVS-file for different filters (name of filter and the full path to directory)
			Counting = 0
			try:
				with open(filter_path, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							if Counting < 11:	
								Button7 = ctk.CTkButton(my_Frame, text=lines[0], text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=230, height=28, font=my_font, command=partial(self.check_SecUSB, lines[1]))
								Button7.place(relx=0.87, rely=padding, anchor="center")
								Counting += 1
								padding += 0.05
							else:
								continue
							
			except FileNotFoundError:
				messagebox.showinfo("Information", "No filter file found.")
		
		if use_filter != ' ':
			# Use the search string to add only paths that contain the search string
			full_path = str(filepathdestinationfolder) + "/secure/**/*"
			for name in glob.glob(full_path, recursive=True): 
				if use_filter in name:
					if not os.path.isdir(name):
						file_list.append(name)
		elif key == 'none':
			# If there is no search string and no filter add all data from glob glob
			full_path = str(filepathdestinationfolder) + "/secure/**/*"
			for name in glob.glob(full_path, recursive=True): 
				if not os.path.isdir(name):
					file_list.append(name)
		else:
			# List the SELECTED directory on the Secure USB (no filtering)
			if os.path.isdir(key):
				for name in glob.glob(key + '/**/*', recursive=True): 
					if not os.path.isdir(name):
						file_list.append(name)
			
		file_list = sorted(file_list, key = operator.itemgetter(0))
		
		sz = 6
		count_lines = 0
		fLabel = ctk.CTkLabel(top_Frame, text=" ", text_color="black", fg_color="black", font=my_font)
		fLabel.pack(padx=55, pady=10, side= TOP, anchor="w")	
		
		for i2 in file_list:
			CD = tk.Frame(top_Frame, width=650, borderwidth=0, bg="black")
			my_font = ctk.CTkFont(family="Consolas", size=18, slant="roman", underline=False, overstrike=False)
			file_extension = pathlib.Path(i2).suffix
			if self.file_is_a_systemfile(i2):
				link_Button = ctk.CTkButton(CD, text=" " + f"{i2:63}", text_color="royal blue", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.file_SecUSB, i2))
			else:
				if file_extension == '.gpg' or file_extension == '.asc' or file_extension == '.sig' or file_extension == '.GPG' or file_extension == '.ASC' or file_extension == '.SIG' or file_extension == '.pgp' or file_extension == '.PGP':
					link_Button = ctk.CTkButton(CD, text=" " + f"{i2:63}", text_color="light green", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.file_SecUSB, i2))
				elif file_extension == '.png' or file_extension == '.PNG' or file_extension == '.jpg' or file_extension == '.JPG':
					link_Button = ctk.CTkButton(CD, text=" " + f"{i2:63}", text_color="medium orchid", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.file_SecUSB, i2))
				elif file_extension == '.txt' or file_extension == '.TXT' or file_extension == '.msg' or file_extension == '.MSG':
					link_Button = ctk.CTkButton(CD, text=" " + f"{i2:63}", text_color="yellow", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.file_SecUSB, i2))
				else:
					link_Button = ctk.CTkButton(CD, text=" " + f"{i2:63}", text_color="white", fg_color="black", border_width=0, border_color="black", width=sz, height=sz, font=my_font, command=partial(self.file_SecUSB, i2))
			link_Button.pack(padx=2, side=tk.LEFT, fill=tk.BOTH, anchor="w")
			CD.pack(fill=tk.BOTH, expand=tk.TRUE)
			count_lines+=1
					
		Search_var = ctk.StringVar(value='')
		Search_var.trace('w', limitSearchField)
		
		my_font = ctk.CTkFont(family="Arial", size=18, weight="bold", slant="roman", underline=False, overstrike=False)
		
		searchEntry = ctk.CTkEntry(my_Frame, placeholder_text='', textvariable=Search_var, width=200, height=30, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
		searchEntry.place(relx=0.84, rely=0.15, anchor="ne")
		
		search_Button = ctk.CTkButton(my_Frame, text="Search file", text_color="white", fg_color="dark green", border_width=2, border_color="white", height=30, font=my_font, command=search_data)
		search_Button.place(relx=0.85, rely=0.15, anchor="nw")
		
		Buttonmoreinfo = ctk.CTkButton(my_Frame, text="More info", text_color="black", fg_color="dark orange", border_width=2, border_color="white", width=90, height=20, font=my_font, command=more_info)
		Buttonmoreinfo.place(relx=0.92, rely=0.95, anchor="center")
	
	def file_SecUSB(self, full_path):
		global PersonalGPGKey, use_filter
		global SecUSB_button_color
		
		file_extension = ''
		use_filter = ' '
		data_list = []
		
		def removefile_SecUSB():
			result = tk.messagebox.askokcancel("Information", "Are you sure you want to delete the file?")
			if not result:
				self.file_SecUSB(full_path)
				return
			else:
				os.remove(full_path)
			self.check_SecUSB('none')
		
		def copy_to_USB():
			result = tk.messagebox.askokcancel("Information", "Insert the USB-device and then click \"OK\".")
			if not result:
				self.file_SecUSB(full_path)
				return
			time.sleep(2)
			result = tk.messagebox.askokcancel("Information", "Double click to select the USB-device and then select the directory where to copy the file.")
			if not result:
				self.file_SecUSB(full_path)
				return
			time.sleep(2)
			USBdevice = filedialog.askdirectory(initialdir='/media/user1/')
			
			if USBdevice == '/home' or USBdevice == '/home/user1' or USBdevice == '/home/user1/secure' or USBdevice == '/media' or USBdevice == '/media/user1':
				messagebox.showinfo("Alert!", "This is not an external USB-device. Are you sure you double-clicked on the USB-device?")
				self.file_SecUSB(full_path)
				return
			else:
				shutil.copy(full_path, USBdevice)
				os.system("sync")
			self.check_SecUSB('none')
		
		def the_size():
			size = 0.0
			size = Path(full_path).stat().st_size
			size_kb = size / 1024
			if size_kb < 100.0:
				size_str = str(round(size_kb, 2)) + ' kB'
				return size_str
			else:
				size_mb = size_kb / 1024
				size_str = str(round(size_mb, 3)) + ' MB'
			return size_str
		
		def creation_date():
			stat = os.stat(full_path)
			try:
				return datetime.fromtimestamp(stat.st_birthtime).strftime('%Y-%m-%d - %H:%M')
			except AttributeError:
				return datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d - %H:%M')
					
		def load_message_to_edit():
			try:
				f = open(full_path, 'r', encoding='utf-8')
				file_content = f.read()
				f.close()
			except OSError:
				messagebox.showinfo('Information', 'There was a problem reading the file.')
			data_list.append('text')
			data_list.append(file_content)
			data_list.append('none')
			self.encrypt_message(data_list)
		
		def compress_file_tar():
			sizeBefore = 'N/A'
			sizeAfter = 'N/A'
			if os.path.isfile(full_path):
				sizeBefore = str(round(os.path.getsize(full_path) / 1000000, 2))
			path_list = full_path.split("/")
			full_name_from_path = str(path_list[-1])
			name_path_list = full_name_from_path.split(".")
			name_from_path = str(name_path_list[-2])
			dest_path = os.path.dirname(os.path.abspath(full_path)) + '/'
			full_path_output_file = dest_path + name_from_path + '.tar.gz'
			
			result = tk.messagebox.askokcancel("Information", "Place the compressed file in the same folder as the original file?")
			if not result:
				result = tk.messagebox.askokcancel("Information", "Double click to select the folder where to place the compressed file.")
				if not result:
					self.file_SecUSB(full_path)
					return
				time.sleep(.1)
				to_folder = filedialog.askdirectory(initialdir='/home/user1/secure')
				custom_path = to_folder + '/' + name_from_path
				full_path_output_file = to_folder + '/' + name_from_path + '.tar.gz'
				shutil.make_archive(base_name=custom_path, format="gztar", root_dir=dest_path, base_dir=full_path)
				if os.path.isfile(full_path_output_file):
					sizeAfter = str(round(os.path.getsize(full_path_output_file) / 1000000, 2))
				messagebox.showinfo("Information", "File written to disk.\nSize before:\n\n" + sizeBefore + ' MB\n\n' + 'After:\n\n' + sizeAfter)
			
				self.check_SecUSB('none')
				return
			else:
				dest_path = os.path.dirname(os.path.abspath(full_path)) + '/'
				full_path_output_file = dest_path + name_from_path + '.tar.gz'
				shutil.make_archive(base_name=custom_path, format="gztar", root_dir=dest_path, base_dir=full_path)
				if os.path.isfile(full_path_output_file):
					sizeAfter = str(round(os.path.getsize(full_path_output_file) / 1000000, 2))
				messagebox.showinfo("Information", "File written to disk.\nSize before:\n\n" + sizeBefore + ' MB\n\n' + 'After:\n\n' + sizeAfter)
			
				self.check_SecUSB('none')
		
		def compress_file_zip():
			sizeBefore = 'N/A'
			sizeAfter = 'N/A'
			if os.path.isfile(full_path):
				sizeBefore = str(round(os.path.getsize(full_path) / 1000000, 2))
			path_list = full_path.split("/")
			full_name_from_path = str(path_list[-1])
			name_path_list = full_name_from_path.split(".")
			name_from_path = str(name_path_list[-2])
			dest_path = os.path.dirname(os.path.abspath(full_path)) + '/'
			full_path_output_file = dest_path + name_from_path + '.zip'
			
			result = tk.messagebox.askokcancel("Information", "Place the compressed file in the same folder as the original file?")
			if not result:
				result = tk.messagebox.askokcancel("Information", "Double click to select the folder where to place the compressed file.")
				if not result:
					self.file_SecUSB(full_path)
					return
				time.sleep(.1)
				to_folder = filedialog.askdirectory(initialdir='/home/user1/secure')
				custom_path = to_folder + '/' + name_from_path
				full_path_output_file = to_folder + '/' + name_from_path + '.tar.gz'
				shutil.make_archive(base_name=custom_path, format="zip", root_dir=dest_path, base_dir=full_path)
				if os.path.isfile(full_path_output_file):
					sizeAfter = str(round(os.path.getsize(full_path_output_file) / 1000000, 2))
				messagebox.showinfo("Information", "File written to disk.\nSize before:\n\n" + sizeBefore + ' MB\n\n' + 'After:\n\n' + sizeAfter)
			
				self.check_SecUSB('none')
				return
			else:
				dest_path = os.path.dirname(os.path.abspath(full_path)) + '/'
				full_path_output_file = dest_path + name_from_path + '.zip'
				shutil.make_archive(base_name=custom_path, format="zip", root_dir=dest_path, base_dir=full_path)
				if os.path.isfile(full_path_output_file):
					sizeAfter = str(round(os.path.getsize(full_path_output_file) / 1000000, 2))
				messagebox.showinfo("Information", "File written to disk.\nSize before:\n\n" + sizeBefore + ' MB\n\n' + 'After:\n\n' + sizeAfter)
			
				self.check_SecUSB('none')
				
		def unzip_file():
			file_extension = pathlib.Path(full_path).suffix
			result = tk.messagebox.askokcancel("Information", "Extract the zipped-folder to an existing folder?")
			if not result:
				USER_INP_tr = ''
				USER_INP = simpledialog.askstring(title="Input required!", prompt="Name for new folder:")
		
				if USER_INP == "" or USER_INP == " ":
					name_list = full_path.split("/")
					USER_INP_tr = str(name_list[-1])
				else:
					USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
					USER_INP_tr = ''.join([char for char in USER_INP_tr if char.isalnum() or char.isspace() or char == '_' or char == '-'])
				newfoldername = filedialog.askdirectory(initialdir='/home/user1/secure')
		
				path = os.path.join(newfoldername, USER_INP_tr)
				os.makedirs(path)
				if file_extension == '.gz' or file_extension == '.Gz' or file_extension == '.GZ':
					shutil.unpack_archive(full_path, path, "gztar")
				if file_extension == '.zip' or file_extension == '.Zip' or file_extension == '.ZIP':
					shutil.unpack_archive(full_path, path, "zip")
				self.check_SecUSB('none')
				return
			else:
				result = tk.messagebox.askokcancel("Information", "Double click to select the folder where to extract the archive to.")
				if not result:
					self.file_SecUSB(full_path)
					return
				time.sleep(.1)
				to_folder = filedialog.askdirectory(initialdir='/home/user1/secure')
				if file_extension == '.gz' or file_extension == '.Gz' or file_extension == '.GZ':
					shutil.unpack_archive(full_path, to_folder, "gztar")
				if file_extension == '.zip' or file_extension == '.Zip' or file_extension == '.ZIP':
					shutil.unpack_archive(full_path, to_folder, "zip")
				self.check_SecUSB('none')
		
		def preview_picture():
			original_img = Image.open(full_path)
			
			w, h = original_img.size
			factor = h/230
			scaled_w = w / factor
			backg = ctk.CTkImage(light_image=Image.open(full_path), dark_image=Image.open(full_path), size=(scaled_w, 230))
			Label_backg = ctk.CTkLabel(picture_Frame, image=backg, text = "")
			Label_backg.place(x=2, y=2)
						
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="green"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = "/home/user1/images/black.png"
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		file_extension = pathlib.Path(full_path).suffix
		
		if file_extension == '.jpg' or file_extension == '.JPG' or file_extension == '.jpeg' or file_extension == '.JPEG' or file_extension == '.png' or file_extension == '.PNG':
			picture_Frame = ctk.CTkFrame(my_Frame,
			width=300, 
			height=230,
			border_width=2,
			border_color="black",
			)
			pathtobackg = "/home/user1/images/black.png"
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(300, 230))
			Label_backg = ctk.CTkLabel(picture_Frame, image=backg, text = "")
			Label_backg.place(x=2, y=2)
			picture_Frame.place(x=800, y=350, anchor="nw")
		
		def limitRenameField(*args):
			value = Rename_var.get()
			if len(value) > 42: Rename_var.set(value[:42])
		
		Rename_var = ctk.StringVar(value='')
		Rename_var.trace('w', limitRenameField)
		
		my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=True, overstrike=False)
		
		filename_list = full_path.split("/")
		filename_ = str(filename_list[-1])
		
		Label = ctk.CTkLabel(my_Frame, text="Secure folder (file details):", text_color="white", fg_color="black", font=my_font)
		Label.place(relx=0.2, rely=0.12, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		nameLabel = ctk.CTkLabel(my_Frame, text="File name:", text_color="white", fg_color="black", font=my_font)
		nameLabel.place(relx=0.18, rely=0.24, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="normal", slant="roman", underline=False, overstrike=False)
		nameLabel2 = ctk.CTkLabel(my_Frame, text=filename_, text_color="white", fg_color="black", font=my_font)
		nameLabel2.place(relx=0.19, rely=0.24, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
		locationLabel = ctk.CTkLabel(my_Frame, text="File path:", text_color="white", fg_color="black", font=my_font)
		locationLabel.place(relx=0.18, rely=0.3, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=20, weight="normal", slant="roman", underline=False, overstrike=False)
		locationLabel2 = ctk.CTkLabel(my_Frame, text=full_path, text_color="white", fg_color="black", font=my_font)
		locationLabel2.place(relx=0.19, rely=0.3, anchor="w")
		
		fsize = the_size()
		my_font = ctk.CTkFont(family="Arial", size=24, weight="normal", slant="roman", underline=True, overstrike=False)
		sizeLabel = ctk.CTkLabel(my_Frame, text="File size:", text_color="white", fg_color="black", font=my_font)
		sizeLabel.place(relx=0.18, rely=0.36, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="normal", slant="roman", underline=False, overstrike=False)
		sizeLabel2 = ctk.CTkLabel(my_Frame, text=fsize, text_color="white", fg_color="black", font=my_font)
		sizeLabel2.place(relx=0.19, rely=0.36, anchor="w")
		
		readable_creation_time = creation_date()
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="normal", slant="roman", underline=True, overstrike=False)
		createdLabel = ctk.CTkLabel(my_Frame, text="Created:", text_color="white", fg_color="black", font=my_font)
		createdLabel.place(relx=0.18, rely=0.42, anchor="e")
		
		my_font = ctk.CTkFont(family="Arial", size=24, weight="normal", slant="roman", underline=False, overstrike=False)
		createdLabel2 = ctk.CTkLabel(my_Frame, text=readable_creation_time, text_color="white", fg_color="black", font=my_font)
		createdLabel2.place(relx=0.19, rely=0.42, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
		copyButton = ctk.CTkButton(my_Frame, text="Copy to USB", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=copy_to_USB)
		copyButton.place(relx=0.5, rely=0.5, anchor="center")
		
		if file_extension == '.asc' or file_extension == '.ASC' or file_extension == '.rtf' or file_extension == '.RTF' or file_extension == '.msg' or file_extension == '.MSG' or file_extension == '.txt' or file_extension == '.TXT':
			editButton = ctk.CTkButton(my_Frame, text="View/Edit/Encrypt", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=load_message_to_edit)
			editButton.place(relx=0.5, rely=0.56, anchor="center")
		else:
			encryptButton = ctk.CTkButton(my_Frame, text="Encrypt file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=partial(self.encrypt_and_sign_file, full_path))
			encryptButton.place(relx=0.5, rely=0.56, anchor="center")
		if file_extension == '.gz' or file_extension == '.Gz' or file_extension == '.GZ':
			unzipButton = ctk.CTkButton(my_Frame, text="Untar file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=120, height=28, font=my_font, command=unzip_file)
			unzipButton.place(relx=0.67, rely=0.56, anchor="center")
		elif file_extension == '.zip' or file_extension == '.Zip' or file_extension == '.ZIP':
			unzipButton = ctk.CTkButton(my_Frame, text="Unzip file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=120, height=28, font=my_font, command=unzip_file)
			unzipButton.place(relx=0.67, rely=0.56, anchor="center")
		else:
			tarButton = ctk.CTkButton(my_Frame, text="Tar file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=120, height=28, font=my_font, command=compress_file_tar)
			tarButton.place(relx=0.66, rely=0.5, anchor="center")
			zipButton = ctk.CTkButton(my_Frame, text="Zip file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=120, height=28, font=my_font, command=compress_file_zip)
			zipButton.place(relx=0.77, rely=0.5, anchor="center")
		if not self.file_is_a_systemfile(full_path):
			if file_extension == '.gpg' or file_extension == '.asc' or file_extension == '.sig' or file_extension == '.GPG' or file_extension == '.ASC' or file_extension == '.SIG' or file_extension == '.pgp' or file_extension == '.PGP':
				decryptButton = ctk.CTkButton(my_Frame, text="Decrypt file", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=partial(self.decrypt_file_direct, full_path))
				decryptButton.place(relx=0.5, rely=0.62, anchor="center")
				decrypttxtButton = ctk.CTkButton(my_Frame, text="Decrypt and view/edit", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=partial(self.decrypt_message, full_path))
				decrypttxtButton.place(relx=0.5, rely=0.68, anchor="center")
			elif file_extension == '.jpg' or file_extension == '.JPG' or file_extension == '.jpeg' or file_extension == '.JPEG' or file_extension == '.png' or file_extension == '.PNG':
				previewButton = ctk.CTkButton(my_Frame, text="Preview image", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=250, height=28, font=my_font, command=preview_picture)
				previewButton.place(relx=0.5, rely=0.62, anchor="center")
				
			deleteButton = ctk.CTkButton(my_Frame, text="Delete File!", text_color="black", fg_color="red", border_width=3, border_color="white", width=250, height=28, font=my_font, command=removefile_SecUSB)
			deleteButton.place(relx=0.5, rely=0.74, anchor="center")
		else:
			my_font = ctk.CTkFont(family="Arial", size=28, weight="bold", slant="roman", underline=False, overstrike=False)
			systemLabel = ctk.CTkLabel(my_Frame, text="THIS IS A SYSTEM FILE FOR THE OFFLINE DEVICE! ", text_color="royal blue", fg_color="black", font=my_font)
			systemLabel.place(relx=0.5, rely=0.7, anchor="center")
		back_button = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.check_SecUSB, 'none'))
		back_button.place(relx=0.5, rely=0.88, anchor="center")
		
	def filter_SecUSB(self):
		global filepathdestinationfolder
		global PersonalGPGKey
		
		def add_filter():
			messagebox.showinfo("Information", "Select the folder to add a filter for.")
					
			folder_path = filedialog.askdirectory(initialdir='/home/user1/secure')
			
			USER_INP = simpledialog.askstring(title="Input required!", prompt="Name for filter (max 20 charachters:")
			
			if USER_INP == "" or USER_INP == " ":
				messagebox.showinfo("Information", "OK, that's not a name. Skipping.")
				self.check_SecUSB("none")
			else:
				USER_INP_tr = USER_INP[:20] if len(USER_INP) > 20 else USER_INP
				USER_INP_tr = ''.join([char for char in USER_INP_tr if char.isalnum() or char.isspace() or char == '_' or char == '-'])
			filter_path = filepathdestinationfolder + '/secure/' + PersonalGPGKey + '_filter.cvs'
			
			# Add a filter to filter file 
			new_filter = [USER_INP_tr, folder_path]
			with open(filter_path, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_filter)
			self.check_SecUSB("none")
		
		def remove_filter():
			global filepathdestinationfolder
			completeName = filepathdestinationfolder + '/secure/' + PersonalGPGKey + '_filter.cvs'
			updatedcompleteName = filepathdestinationfolder + '/secure/Updated' + PersonalGPGKey + '_filter.cvs'
			with open(completeName, 'r') as source, open(updatedcompleteName, 'w') as result:
				csvreader = csv.reader(source)
				csvwriter = csv.writer(result)
				for row in csv.reader(source):
					try:
						if row[0] != clicked.get():
							csvwriter.writerow(row)				
					except:
						continue
			shutil.copy(updatedcompleteName, completeName)
			os.remove(updatedcompleteName)	
			self.check_SecUSB("none")
			
		my_Frame = ctk.CTkFrame(self, 
		width=1200,                                                                                                                                                                                                                                                                        
		height=650,
		border_width=4,
		border_color="blue"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		pathtobackg = self.get_background_image()
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		
		filter_path = filepathdestinationfolder + '/secure/' + PersonalGPGKey + '_filter.cvs'
		
		active_filter_name = []
		counting = 0
		
		if os.path.isfile(filter_path):
			# load filters from CVS-file
			my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
			try:
				with open(filter_path, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							active_filter_name.append(lines[0])
							counting += 1
			except FileNotFoundError:
				messagebox.showinfo("Information", "No filter file found.")
		else:
			messagebox.showinfo("Information", "No filter file found.")
		
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", weight='bold' , underline=False, overstrike=False)
		Label = ctk.CTkLabel(my_Frame, text="Add or remove a filter to view the files and folders of Secure archive", text_color="white", fg_color="black", font=my_font)
		Label.place(relx=0.07, rely=0.12, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", weight='normal' , underline=False, overstrike=False)
		Label2 = ctk.CTkLabel(my_Frame, text="Select to add a new filter or to remove an existing one (max 10 filter are possible)", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.07, rely=0.2, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight='bold' , underline=False, overstrike=False)
		if counting == 1:
			Label3 = ctk.CTkLabel(my_Frame, text="There are currently " + str(counting) + " filter active.", text_color="white", fg_color="black", font=my_font)
		else:
			Label3 = ctk.CTkLabel(my_Frame, text="There are currently " + str(counting) + " filters active.", text_color="white", fg_color="black", font=my_font)
		Label2.place(relx=0.07, rely=0.28, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", weight='bold' , underline=True, overstrike=False)
		
		Label4 = ctk.CTkLabel(my_Frame, text="Add one more filter.", text_color="white", fg_color="black", font=my_font)
		Label4.place(relx=0.07, rely=0.4, anchor="w")
		
		Label5 = ctk.CTkLabel(my_Frame, text="Remove a filter:", text_color="white", fg_color="black", font=my_font)
		Label5.place(relx=0.47, rely=0.4, anchor="w")
		
		my_font = ctk.CTkFont(family="Arial", size=24, slant="roman", weight='bold' , underline=False, overstrike=False)
		
		if counting < 10:
			Button2 = ctk.CTkButton(my_Frame, text="Add", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=add_filter)
			Button2.place(relx=0.36, rely=0.56, anchor="center")
		else:
			Label6 = ctk.CTkLabel(my_Frame, text="<Max number of filters reached>", text_color="white", fg_color="black", font=my_font)
			Label6.place(relx=0.38, rely=0.48, anchor="e")
			
		Label7 = ctk.CTkLabel(my_Frame, text="Select filter to remove:", text_color="white", fg_color="black", font=my_font)
		Label7.place(relx=0.68, rely=0.48, anchor="e")
		
		clicked = StringVar()
		
		if active_filter_name:
			clicked.set(active_filter_name[0])
			drop = OptionMenu(my_Frame, clicked, *active_filter_name)
			drop.config(width=25)
			drop.place(relx=0.69, rely=0.48, anchor="w")
			
			Button2 = ctk.CTkButton(my_Frame, text="Remove", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=remove_filter)
			Button2.place(relx=0.85, rely=0.56, anchor="center")
		else:
			Label2 = ctk.CTkLabel(my_Frame, text="<There are no filters yet>", text_color="white", fg_color="black", font=my_font)
			Label2.place(relx=0.73, rely=0.48, anchor="w")
				
	def copyfile_SecUSB(self):
		global filepathdestinationfolder
		messagebox.showinfo("Information", "Select a file to copy to USB.")
		filepathtocopy = filedialog.askopenfilename(initialdir='/home/user1/secure')
		messagebox.showinfo("Information", "Select destination folder by double clicking on it.")
		
		filepathdestinationfolderfull = filedialog.askdirectory(initialdir='/media/user1')
		
		if filepathdestinationfolderfull == '/media/user1':
			messagebox.showinfo("Information", "Make sure you DOUBLE CLICK on the destination folder to select it.")
		else:
			shutil.copy(filepathtocopy, filepathdestinationfolderfull)
		os.system("sync")
		self.unmount_USBs('Information.')
		self.check_SecUSB('none')
		
	def copyfile_USB_to_USB(self):
		global filepathdestinationfolder
		result = tk.messagebox.askokcancel("Information", "Insert both the USB-devices.") 
		if not result:
			self.check_SecUSB('none')
			return
		time.sleep(2)
		
		result = tk.messagebox.askokcancel("Information", "Select a file to copy FROM the first USB.")
		if not result:
			self.check_SecUSB('none')
			return
		time.sleep(2)
		source = filedialog.askopenfilename(initialdir='/media/user1')
		
		result = tk.messagebox.askokcancel("Information", "Select the TO destination by double clicking on it.")
		if not result:
			self.check_SecUSB('none')
			return
		destination_folder = filedialog.askdirectory(initialdir='/media/user1')
		filename_list = source.split("/")
		filename = str(filename_list[-1])
		
		destination = destination_folder + '/' + filename
		
		if destination_folder == '/media/user1':
			messagebox.showinfo("Information", "Make sure you first DOUBLE CLICK on the shown USB directory to select it.")
		else:
			try:
				with open(source, 'rb') as src_file, open(destination, 'wb') as dst_file:
					dst_file.write(src_file.read())
				time.sleep(1)
				messagebox.showinfo("Information", "File copied successfully.")
			except FileNotFoundError:
				messagebox.showinfo("Information", "Source file not found.")
			except PermissionError:
				messagebox.showinfo("Information", "Permission denied.")
		os.system("sync")
		self.check_SecUSB('none')
			
	def addfile_SecUSB(self):
		global filepathdestinationfolder
		result = tk.messagebox.askokcancel("Information", "Insert the USB-device with the file you want to add to the Secure archive and then press \"OK\".")
		if not result:
			self.check_SecUSB("none")
			return
		time.sleep(2)
		result = tk.messagebox.askokcancel("Information", "Select the file to add to the secure archive.")
		if not result:
			self.check_SecUSB("none")
			return
		time.sleep(2)
		filepathtocopy = filedialog.askopenfilename(initialdir='/media/user1')
		messagebox.showinfo("Information", "Select destination folder.")
		full_path = filepathdestinationfolder + '/secure'
		filepathdestinationfolderfull = filedialog.askdirectory(initialdir=full_path)
		shutil.copy(filepathtocopy, filepathdestinationfolderfull)
		messagebox.showinfo("Information", "File has been added.")
		self.check_SecUSB('none')
	
	def add_directory_SecUSB(self):
		global filepathdestinationfolder
		USER_INP_tr = ''
		USER_INP = simpledialog.askstring(title="Input required!", prompt="Name of new directory:")
		
		if USER_INP == "" or USER_INP == " ":
			messagebox.showinfo("Information", "OK, that's not a name. Skipping.")
			self.check_SecUSB("none")
		else:
			USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
			USER_INP_tr = ''.join([char for char in USER_INP_tr if char.isalnum() or char.isspace() or char == '_' or char == '-'])
				
		messagebox.showinfo("Information", "Select where to place the new directory (under \"/home/user1/secure\").")
		
		newfoldername = filedialog.askdirectory(initialdir='/home/user1/secure')
		
		path = os.path.join(newfoldername, USER_INP_tr)
		os.makedirs(path)
		self.check_SecUSB('none')				
						
	def removefile_SecUSB(self):
		global filepathdestinationfolder
		global PersonalGPGKey
		keyfilepath = '/home/user1/privateKey' + PersonalGPGKey + ".gpg"
		messagebox.showinfo("Information", "Select the file you want to remove.")
		full_path = filepathdestinationfolder + '/secure'
		filepathtoremove = filedialog.askopenfilename(initialdir=full_path)
		if filepathtoremove == keyfilepath or filepathtoremove == '/home/user1/secure/settings.csv' or filepathtoremove == '/home/user1/secure/passwords.txt' or filepathtoremove == '/home/user1/secure/boltcards/boltcards.csv' or filepathtoremove == '/home/user1/secure/wallets/wallets.txt' or filepathtoremove == '/home/user1/secure/wallets/paperwallets/paperwallets.csv' or filepathtoremove == '/home/user1/secure/FIDO/FIDOKeys.csv' or filepathtoremove == '/home/user1/secure/ID/IDs.csv':
			 messagebox.showinfo("Alert!", "This is a systems file. It can't be removed.")
			 self.removefile_SecUSB()
		else:
			os.remove(filepathtoremove)
		self.check_SecUSB('none')
		
	def remove_directory(self):
		global filepathdestinationfolder
		messagebox.showinfo("Information", "Select the directory you want to remove.")
		full_path = filepathdestinationfolder + '/secure'
		removefolderpath = filedialog.askdirectory(initialdir=full_path)
		if removefolderpath == '/home' or removefolderpath == '/home/user1' or removefolderpath == '/home/user1/secure' or removefolderpath == '/home/user1/secure/keys' or removefolderpath == '/home/user1/secure/boltcards' or removefolderpath == '/home/user1/secure/wallets' or removefolderpath == '/home/user1/secure/wallets/paperwallets' or removefolderpath == '/home/user1/secure/FIDO' or removefolderpath == '/home/user1/secure/ID':
			 messagebox.showinfo("Alert!", "This is a systems directory. It can't be removed.")
			 self.remove_directory()
		else:
			thetext = 'Are you sure you want to remove the directory ' + str(removefolderpath)
			answer = messagebox.askquestion('Warning!', thetext)
							
			if answer == 'yes':
				shutil.rmtree(removefolderpath, ignore_errors=True)
			else:
				messagebox.showinfo("Information", "OK. Keeping the directory.")
		self.check_SecUSB('none')
	
	def zip_directory(self):
		global filepathdestinationfolder
		messagebox.showinfo("Information", "Select the folder you want to zip (using zip-compression, Windows compatible).")
		full_path = filepathdestinationfolder + '/secure'
		zipfolderpath = filedialog.askdirectory(initialdir=full_path)
		USER_INP_tr = ''
		USER_INP = simpledialog.askstring(title="Input required!", prompt="Name for output file (.zip will be added automatically):")
		
		if USER_INP == "" or USER_INP == " ":
			filename_list = zipfolderpath.split("/")
			USER_INP_tr = str(filename_list[-1])
		else:
			USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
			USER_INP_tr = ''.join([char for char in USER_INP_tr if char.isalnum() or char.isspace() or char == '_' or char == '-'])
			
		if zipfolderpath == '/home' or zipfolderpath == '/home/user1' or zipfolderpath == '/home/user1/secure':
			 messagebox.showinfo("Alert!", "This is to big of a directory. It can't be zipped.")
			 self.check_SecUSB('none')
			 return
		else:
			messagebox.showinfo("Information", "Select the directory where you want to place in the zip-file.")
			destfolderpath = filedialog.askdirectory(initialdir=full_path)
			full_path_compr_file = destfolderpath + '/' + USER_INP_tr
			full_path_compr_file_ext = destfolderpath + '/' + USER_INP_tr + '.zip'
			shutil.make_archive(full_path_compr_file, 'zip', zipfolderpath)
			
			if os.path.isfile(full_path_compr_file):
				os.remove(full_path_compr_file)
				
				if os.path.isfile(full_path_compr_file_ext):
					if os.path.getsize(full_path_compr_file_ext) > 1000:
						messagebox.showinfo("Information", "Folder has been zipped to a compressed zip-file and written to disk.")
		self.check_SecUSB('none')
	
	def tar_directory(self):
		global filepathdestinationfolder
		messagebox.showinfo("Information", "Select the folder you want to include in tar-ball (using gzip-compression).")
		full_path = filepathdestinationfolder + '/secure'
		zipfolderpath = filedialog.askdirectory(initialdir=full_path)
		USER_INP_tr = ''
		USER_INP = simpledialog.askstring(title="Input required!", prompt="Name for output file (.tar.gz will be added automatically):")
		
		if USER_INP == "" or USER_INP == " ":
			filename_list = zipfolderpath.split("/")
			USER_INP_tr = str(filename_list[-1])
		else:
			USER_INP_tr = USER_INP[:30] if len(USER_INP) > 30 else USER_INP
			USER_INP_tr = ''.join([char for char in USER_INP_tr if char.isalnum() or char.isspace() or char == '_' or char == '-'])
			
		if zipfolderpath == '/home' or zipfolderpath == '/home/user1' or zipfolderpath == '/home/user1/secure':
			 messagebox.showinfo("Alert!", "This is to big of a directory. It can't be zipped.")
			 self.check_SecUSB('none')
			 return
		else:
			messagebox.showinfo("Information", "Select the directory where you want to place the tar-ball (gzip-compressed) file.")
			destfolderpath = filedialog.askdirectory(initialdir=full_path)
			full_path_compr_file = destfolderpath + '/' + USER_INP_tr
			full_path_compr_file_ext = destfolderpath + '/' + USER_INP_tr + '.tar.gz'
			shutil.make_archive(full_path_compr_file, 'gztar', zipfolderpath)
			
			if os.path.isfile(full_path_compr_file):
				os.remove(full_path_compr_file)
				if os.path.isfile(full_path_compr_file_ext):
					if os.path.getsize(full_path_compr_file_ext) > 1000:
						messagebox.showinfo("Information", "Folder has been added to tar-ball and written to a compressed file.")
		self.check_SecUSB('none')
			
	def create_Bitcointextbox(self, theFlag):
		global filepathdestinationfolder
		global SecUSB_button_color
		global view_btcAddr
		global use_filter
		global use_status
		
		view_btcAddr = 'none'
		SATs_value = 0.0
		
		if theFlag == 'all':
			use_filter = 'all'
			use_status = 'all'
			
		path_to_wallets = filepathdestinationfolder + "/secure/wallets/paperwallets/paperwallets.csv"

		def setFlagAll():
			global use_filter
			global use_status
			use_status = 'all'
			view_btcAddr = 'none'
			self.do_show_Bitcoinwallets(theFlag)
		def setFlagCreated():
			global use_filter
			global use_status
			use_status = 'Timestamp'
			view_btcAddr = 'none'
			self.do_show_Bitcoinwallets(theFlag)
		def setFlagActive():
			global use_filter
			global use_status
			use_status = 'Active'
			view_btcAddr = 'none'
			self.do_show_Bitcoinwallets(theFlag)
		def setFlagNonKYC():
			global use_filter
			global use_status
			use_status = 'Non KYC'
			view_btcAddr = 'none'
			self.do_show_Bitcoinwallets(theFlag)
		def setFlagSpent():
			global use_filter
			global use_status
			use_status = 'Spent'
			view_btcAddr = 'none'
			self.do_show_Bitcoinwallets(theFlag)
		
		# scrolleable frame
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
		
		bottom_Frame = ctk.CTkScrollableFrame(my_Frame, 
		width=1150, 
		height=570,
		orientation="vertical",
		border_width=2,
		border_color="white",
		fg_color="black"
		)
		bottom_Frame._scrollbar.configure(height=0)
		bottom_Frame.place(x=10, y=60, anchor="nw")
		
		# Make the buttons on the top of the frame on the frame
		if path_to_USB_secure == 'Secure USB folder is available':
			# Fix_csv to 6 collumns
			fix_csv = self.fix_csvfile()
			my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
			filter_all_Button = ctk.CTkButton(my_Frame, text="All wallets", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.create_Bitcointextbox, 'all'))
			filter_all_Button.place(relx=0.1, y=30, anchor="center")
			
			filter_Button = ctk.CTkButton(my_Frame, text="Use filter", fg_color="dark orange", text_color="black", border_width=2, border_color="white", font=my_font, command=self.do_show_Bitcoinwallets_start)
			filter_Button.place(relx=0.25, y=30, anchor="center")
			
			total_amount_BTC = self.get_total_BTC_amount()
			
			if total_amount_BTC > 100:
				BTCLabel = ctk.CTkLabel(my_Frame, text="Bitcoin total amount: " + str(int(total_amount_BTC)) + ' sats', text_color="white", fg_color="black", font=my_font)
				BTCLabel.place(relx=0.45, y=30, anchor="w")
			else:
				BTCLabel = ctk.CTkLabel(my_Frame, text="Bitcoin total amount: " + str(total_amount_BTC) + ' BTC', text_color="white", fg_color="black", font=my_font)
				BTCLabel.place(relx=0.45, y=30, anchor="w")
			addButton = ctk.CTkButton(my_Frame, text="Add new", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.do_new_Bitcoinwallet)
			addButton.place(relx=0.92, y=30, anchor="center")
			
			amount = 0.0 
			amount_round = 0.0
			loopcount = 0
			row_count = 0
			col_count = 0
			
			try:
				with open(path_to_wallets, 'r') as file:
					csvfile = csv.reader(file)
					for lines in csvfile:
						if lines:
							my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
							if lines[0] == 'Timestamp' and (theFlag == 'Timestamp' or theFlag == 'all'):
								if lines[5] == 'None':
									my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n' + 'Timestamp\n Document', anchor='center', text_color="white", fg_color="purple", border_width=4, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								else:
									my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n' + 'Timestamp\nSignature + Document', anchor='center', text_color="white", fg_color="purple", border_width=4, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								Button5.grid(row = row_count, column = col_count, sticky = W, padx = 30, pady = 10)
								col_count = col_count + 1
								if col_count == 4:
									col_count = 0
									row_count = row_count + 1
								
							if lines[0] == 'Active' and (theFlag == 'Active' or theFlag == 'all'):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="white", fg_color="green4", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								else:
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="white", fg_color="green4", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								
								Button5.grid(row = row_count, column = col_count, sticky = W, padx = 30, pady = 10)
								col_count = col_count + 1
								if col_count == 4:
									col_count = 0
									row_count = row_count + 1
								amount = amount + float(lines[5])
								
							if lines[0] == 'Spent' and (theFlag == 'Spent' or theFlag == 'all'):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="black", fg_color="grey", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								else:
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="black", fg_color="grey", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								
								Button5.grid(row = row_count, column = col_count, sticky = W, padx = 30, pady = 10)
								col_count = col_count + 1
								if col_count == 4:
									col_count = 0
									row_count = row_count + 1
								
							if lines[0] == 'Non KYC' and (theFlag == 'Non KYC' or theFlag == 'all'):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								else:
									Button5 = ctk.CTkButton(bottom_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.do_edit_Bitcoinwallets, lines[2]))
								
								Button5.grid(row = row_count, column = col_count, sticky = W, padx = 30, pady = 10)
								col_count = col_count + 1
								if col_count == 4:
									col_count = 0
									row_count = row_count + 1

								amount = amount + float(lines[5])
							loopcount = loopcount + 1
							
			except FileNotFoundError:
				messagebox.showinfo("Information", "No paper wallet file found.")
			amount_round = round(amount, 7)	
			row_count = row_count + 1
			
		else:
			my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
			Button = ctk.CTkButton(my_Frame, text="You are not logged in. Paper wallets can\'t be displayed.", font=my_font, text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", command=self.create_SecUSBmeny)
			Button.pack(pady=240)
			Label = ctk.CTkLabel(my_Frame, text=' ', text_color="white", font=("Arial", 18), fg_color="black", underline=True)
			Label.pack(pady=300)
	
	def copy2clip(self, txt):
		r = Tk()
		r.withdraw()
		r.clipboard_clear()
		r.clipboard_append(txt)
		r.update()
		r.destroy()
	
	def change_view_btcAddr(self, new_view_btcAddr):
		global view_btcAddr
		global ext_flag
		view_btcAddr = new_view_btcAddr
		self.do_show_Bitcoinwallets(ext_flag)
		
	def change_flag_and_reset_btcAddr(self, newFlag):
		global view_btcAddr
		global ext_flag
		ext_flag = newFlag
		view_btcAddr = 'none'
		self.do_show_Bitcoinwallets(ext_flag)
	
	def do_show_Bitcoinwallets_start(self):
		global view_btcAddr
		global use_filter
		global use_status
		use_status = 'all'
		use_filter = 'all'
		view_btcAddr = 'none'
		self.do_show_Bitcoinwallets('all')
			
	def do_show_Bitcoinwallets(self, theFlag):
		global Boltcard_button_color
		global filepathdestinationfolder
		global view_btcAddr
		global ext_flag
		global use_filter
		global use_status
		global categories_list
		global do_sort
		
		SATs_value = 0.0
		
		external_BTC_categories_file = filepathdestinationfolder + "/secure/BTC_categories.csv"	
		path_to_wallets = filepathdestinationfolder + "/secure/wallets/paperwallets/paperwallets.csv"
		pathtobackg = str(filepathdestinationfolder) + "/images/BTC_icon_black.jpg"
		
		categories_list = []
		status_list = ['Timestamp', 'Active', 'Non KYC', 'Spent']
		
		def change_sort_flag_to_date():
			global do_sort
			do_sort = 'date'
			self.do_show_Bitcoinwallets(use_status)
		
		def change_sort_flag_to_value():
			global do_sort
			do_sort = 'value'
			self.do_show_Bitcoinwallets(use_status)
			
		def change_sort_flag_to_none():
			global use_filter
			global use_status
			use_status = 'all'
			use_filter = 'all'
			self.do_show_Bitcoinwallets(use_status)
			
		def filter_on_category_and_status():
			global use_filter
			global use_status
			global view_btcAddr
			view_btcAddr = 'none'
			use_filter = clicked.get()
			use_status = clicked2.get()
			if use_filter == 'Select category':
				use_filter = 'all'
			if use_status == 'Select status':
				use_status = 'all'
			self.do_show_Bitcoinwallets(use_status)
			
		def get_categories():
			global categories_list
			with open(path_to_wallets, 'r') as file:
				csvfile = csv.reader(file)
				for row in csvfile:
					if row[6] not in categories_list and row[6] != "Not payed" and row[6] != "Payed":
						categories_list.append(row[6])
			
		main_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		main_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		top_Frame = ctk.CTkFrame(main_Frame, 
		width=1200, 
		height=60,
		border_width=2,
		border_color="black",
		fg_color="black"
		)
		top_Frame.place(x=0, y=0, anchor="nw")
		
		left_Frame = ctk.CTkFrame(main_Frame, 
		width=250, 
		height=590,
		border_width=2,
		border_color="black"
		)
		left_Frame.place(x=0, y=60, anchor="nw")
		
		left_top_Frame = ctk.CTkFrame(left_Frame, 
		width=250, 
		height=210,
		border_width=2,
		border_color="black"
		)
		left_top_Frame.place(x=0, y=0, anchor="nw")
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(248, 208))
		Label_backg = ctk.CTkLabel(left_top_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		left_mid_Frame = ctk.CTkFrame(left_Frame, 
		width=250, 
		height=200,
		border_width=2,
		border_color="black"
		)
		left_mid_Frame.place(x=0, y=210, anchor="nw")
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(248, 198))
		Label_backg = ctk.CTkLabel(left_mid_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		left_bottom_Frame = ctk.CTkFrame(left_Frame, 
		width=250, 
		height=176,
		border_width=2,
		border_color="black"
		)
		left_bottom_Frame.place(x=0, y=410, anchor="nw")
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(248, 174))
		Label_backg = ctk.CTkLabel(left_bottom_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2)
		
		left_wallet_Frame = ctk.CTkScrollableFrame(main_Frame, 
		width=275, 
		height=588,
		orientation="vertical",
		border_width=2,
		border_color="black",
		fg_color="gray1"
		)
		left_wallet_Frame._scrollbar.configure(height=0)
		left_wallet_Frame.place(x=250, y=60, anchor="nw")
		
		right_Frame = ctk.CTkFrame(main_Frame, 
		width=646, 
		height=588,
		border_width=2,
		border_color="white"
		)
		right_Frame.place(x=550, y=60, anchor="nw")
		
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(642, 584))
		right_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
		right_backg.place(x=2, y=2)
		
		if view_btcAddr != 'none':
			amount_round = 0.0
			notset_str = 'all'	
			the_status = ' '
			the_dt_string_short = ' '
			the_wif_private_key = ' '
			the_words = ' '
			the_amount = 0.0
			the_category = 'N/A'
			
			try:
				with open(path_to_wallets, 'r') as file:
					csvfile = csv.reader(file)
					for row in csvfile:
						try:
							if row[2] == view_btcAddr:
								the_status = row[0]
								the_dt_string_short = row[1]
								the_wif_private_key = row[3]
								the_words = row[4]
								the_amount = row[5]
								the_category =row[6]
						except:
							continue
			except FileNotFoundError:
					messagebox.showinfo("Information", "No paper wallet file found.")
					
			backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(642, 584))
			right_backg = ctk.CTkLabel(right_Frame, image=backg, text = "")
			right_backg.place(x=2, y=2)

			if the_status == "Timestamp":
				
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=True, overstrike=False)
				headingLabel = ctk.CTkLabel(right_Frame, text='Timestamp on the Bitcoin blockchain', text_color="white", font=my_font, fg_color="black")
				headingLabel.place(relx=0.05, rely=0.08, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
				
				if the_amount == 'None':
					filenameLabel = ctk.CTkLabel(right_Frame, text='Timestamp is for the hash of document:', text_color="white", font=my_font, fg_color="black")
					filenameLabel.place(relx=0.05, rely=0.14, anchor="w")
					my_font = ctk.CTkFont(family="Arial", size=20, slant="italic", underline=False, overstrike=False)
					filenameLabel2 = ctk.CTkLabel(right_Frame, text=the_words, text_color="white", font=my_font, fg_color="black")
					filenameLabel2.place(relx=0.05, rely=0.2, anchor="w")
				else:
					signameLabel = ctk.CTkLabel(right_Frame, text='For the combined hash of signature and document files:', text_color="white", font=my_font, fg_color="black")
					signameLabel.place(relx=0.05, rely=0.14, anchor="w")
					my_font = ctk.CTkFont(family="Arial", size=20, slant="italic", underline=False, overstrike=False)
					signameLabel2 = ctk.CTkLabel(right_Frame, text=the_amount, text_color="white", font=my_font, fg_color="black")
					signameLabel2.place(relx=0.05, rely=0.2, anchor="w")

					filenameLabel2 = ctk.CTkLabel(right_Frame, text=the_words, text_color="white", font=my_font, fg_color="black")
					filenameLabel2.place(relx=0.05, rely=0.25, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
				Label22 = ctk.CTkLabel(right_Frame, text='Status:', text_color="white", font=my_font, fg_color="black")
				Label22.place(relx=0.05, rely=0.48, anchor="w")
				Label23 = ctk.CTkLabel(right_Frame, text=the_category, text_color="white", font=("Helvetica", 20), fg_color="black")
				Label23.place(relx=0.05, rely=0.53, anchor="w")
				
				Label222 = ctk.CTkLabel(right_Frame, text='Address:', text_color="white", font=my_font, fg_color="black")
				Label222.place(relx=0.05, rely=0.69, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				Label232 = ctk.CTkLabel(right_Frame, text=view_btcAddr, text_color="white", font=my_font, fg_color="black")
				Label232.place(relx=0.05, rely=0.73, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=16, slant="roman", underline=False, overstrike=False)
				
				if the_category == "Not payed":
					# Generate a Bitcoin transaction including amount of 1100 sats to the newly hashed address
					transaction_payload = 'bitcoin:' + str(view_btcAddr) + '?amount=0.00001100'
					
					# Generate QR-codes to pay transaction 
					qr_public_address = qrcode.make(transaction_payload)
					resize_qr_public_address = qr_public_address.resize((160, 160))
					pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
					resize_qr_public_address.save(pathtopublic)
					publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(160, 160))
					Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = publicimg)
					Labelpublicimg.place(relx=0.6, rely=0.49, anchor="center")
					
					pubLabel = ctk.CTkLabel(right_Frame, text="Pay address:", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.6, rely=0.32, anchor="center")
					
					# Generate QR-codes for Blockchain search 
					ext_link = "www.mempool.space/address/" + view_btcAddr
					qr_blockchain_address = qrcode.make(ext_link)
					resize_qr_blockchain_address = qr_blockchain_address.resize((160, 160))
					pathtoblockchain = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
					resize_qr_blockchain_address.save(pathtoblockchain)
					blockchainimg = ctk.CTkImage(light_image=Image.open(pathtoblockchain), dark_image=Image.open(pathtoblockchain), size=(160, 160))
					Labelblockchainimg = ctk.CTkLabel(right_Frame,  text = "", image = blockchainimg)
					Labelblockchainimg.place(relx=0.86, rely=0.49, anchor="center")
					
					pubLabel = ctk.CTkLabel(right_Frame, text="Blockchain link:", text_color="white", font=my_font, fg_color="black")
					pubLabel.place(relx=0.86, rely=0.32, anchor="center")
					
					copy_bechaddr_button = ctk.CTkButton(right_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=1, border_color="white", font=my_font, command=partial(self.copy2clip, ext_link))
					copy_bechaddr_button.place(relx=0.86, rely=0.67, anchor="center")
				
					button3 = ctk.CTkButton(right_Frame, text="Set to payed", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Payed2, view_btcAddr))
					button3.place(relx=0.5, rely=0.8, anchor="center")
				else:
					# Generate QR-codes for Blockchain search 
					ext_link = "www.mempool.space/address/" + view_btcAddr
					qr_public_address = qrcode.make(ext_link)
					resize_qr_public_address = qr_public_address.resize((160, 160))
					pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/blockchain.png"
					resize_qr_public_address.save(pathtopublic)
					publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(160, 160))
					Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = publicimg)
					Labelpublicimg.place(relx=0.82, rely=0.49, anchor="center")
					
					blockchainLabel = ctk.CTkLabel(right_Frame, text="Blockchain link:", text_color="white", font=my_font, fg_color="black")
					blockchainLabel.place(relx=0.83, rely=0.32, anchor="center")
					
					copy_blockchain_button = ctk.CTkButton(right_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=1, border_color="white", font=my_font, command=partial(self.copy2clip, ext_link))
					copy_blockchain_button.place(relx=0.82, rely=0.67, anchor="center")
				
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				
				button4 = ctk.CTkButton(right_Frame, text="Delete", text_color="white", fg_color="red", border_width=2, border_color="white", font=my_font, command=partial(self.do_deleteBitcoinwallet, view_btcAddr))
				button4.place(relx=0.5, rely=0.87, anchor="center")
			else:
				# Generate QR-codes for Public address 
				qr_public_address = qrcode.make(view_btcAddr, version=1)
				resize_qr_public_address = qr_public_address.resize((200, 200))
				pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
				resize_qr_public_address.save(pathtopublic)
				publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(200, 200))
				# Generate QR-codes for WIF-address
				qr_wif_private_key = qrcode.make(the_wif_private_key, version=1)
				resize_qr_wif_private_key = qr_wif_private_key.resize((200, 200))
				pathtowif = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/wif.png"
				resize_qr_wif_private_key.save(pathtowif)
				wifimg = ctk.CTkImage(light_image=Image.open(pathtowif), dark_image=Image.open(pathtowif), size=(200, 200))
				
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				
				pubLabel = ctk.CTkLabel(right_Frame, text="Load", text_color="white", font=("Arial", 28), fg_color="black")
				pubLabel.place(relx=0.15, rely=0.18, anchor="center")
				Labelpublicimg = ctk.CTkLabel(right_Frame,  text = "", image = publicimg)
				Labelpublicimg.place(relx=0.17, rely=0.4, anchor="center")
				copy_bechaddr_button = ctk.CTkButton(right_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, view_btcAddr))
				copy_bechaddr_button.place(relx=0.15, rely=0.61, anchor="center")
				
				dotLabel = ctk.CTkLabel(right_Frame, text=".", text_color="black", font=("Helvetica", 15), fg_color="black")
				dotLabel.place(relx=0.1, rely=0.99, anchor="w")
				
				wifLabel = ctk.CTkLabel(right_Frame, text="Spend (Legacy)", text_color="white", font=("Arial", 28), fg_color="black")
				wifLabel.place(relx=0.83, rely=0.18, anchor="center")
				Labelwifimg = ctk.CTkLabel(right_Frame, text = "", image = wifimg)
				Labelwifimg.place(relx=0.83, rely=0.4, anchor="center")
				copy_wifaddr_button = ctk.CTkButton(right_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, the_wif_private_key))
				copy_wifaddr_button.place(relx=0.83, rely=0.61, anchor="center")
				my_font = ctk.CTkFont(family="Helvetica", size=26, weight="bold", slant="roman", underline=True, overstrike=False)
				Label0 = ctk.CTkLabel(right_Frame, text=the_status + ' Bitcoin wallet', text_color="white", font=my_font, fg_color="black")
				Label0.place(relx=0.5, rely=0.05, anchor="center")	
				my_font = ctk.CTkFont(family="Arial", size=16, weight="bold", slant="roman", underline=False, overstrike=False)
				Label1 = ctk.CTkLabel(right_Frame, text=view_btcAddr, text_color="white", font=("Helvetica", 20), fg_color="black")
				Label1.place(relx=0.5, rely=0.12, anchor="center")	
				Label2 = ctk.CTkLabel(right_Frame, text='Created: ' + the_dt_string_short, text_color="white", font=("Helvetica", 18), fg_color="black")
				Label2.place(relx=0.5, rely=0.26, anchor="center")	
				Label22 = ctk.CTkLabel(right_Frame, text='Category:', text_color="white", font=("Helvetica", 18), fg_color="black")
				Label22.place(relx=0.5, rely=0.34, anchor="center")
				Label23 = ctk.CTkLabel(right_Frame, text=the_category, text_color="white", font=("Helvetica", 22), fg_color="black")
				Label23.place(relx=0.5, rely=0.4, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
				if float(the_amount) < 0.01:
					SATs_value = float(the_amount) * 100000000
					BTC_value_rounded = round(SATs_value, 8)
					Label4 = ctk.CTkLabel(right_Frame, text='Amount:', text_color="white", font=my_font, fg_color="black")
					Label4.place(relx=0.5, rely=0.47, anchor="center")
					Label44 = ctk.CTkLabel(right_Frame, text=str(int(BTC_value_rounded)) + ' sats', text_color="white", font=("Helvetica", 22), fg_color="black")
					Label44.place(relx=0.5, rely=0.53, anchor="center")
				else:
					Label4 = ctk.CTkLabel(right_Frame, text='Amount: ' + str(the_amount) + ' BTC', text_color="white", font=my_font, fg_color="black")
					Label4.place(relx=0.5, rely=0.5, anchor="center")
				my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
				if (str(the_status) == "Active") or (str(the_status) == 'Created') or (str(the_status) == 'Non KYC'):
					if (str(the_amount) == '0') or (str(the_amount) == '0.0'):
						button1 = ctk.CTkButton(right_Frame, text="Add BTC", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.add_AmountToBitcoinwallet, view_btcAddr))
						button1.place(relx=0.5, rely=0.57, anchor="center")	
				if str(the_status) == 'Created':
					button2 = ctk.CTkButton(right_Frame, text="Change status to Active", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Active, view_btcAddr))
					button2.place(relx=0.5, rely=0.62, anchor="center")	
				if str(the_status) == 'Active' or str(the_status) == 'Non KYC':
					button3 = ctk.CTkButton(right_Frame, text="Change status to Spent", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Spent, view_btcAddr))
					button3.place(relx=0.5, rely=0.62, anchor="center")	
				button4 = ctk.CTkButton(right_Frame, text="Delete", text_color="white", fg_color="red", border_width=2, border_color="white", font=my_font, command=partial(self.do_deleteBitcoinwallet, view_btcAddr))
				button4.place(relx=0.5, rely=0.7, anchor="center")	
		
		my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
		
		clicked = StringVar()
		clicked2 = StringVar()
		
		amount = 0.0
		loopcount = 0
		SATs_value = 0.0
		
		
		if path_to_USB_secure == 'Secure USB folder is available':
			my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
		
			filter_all_Button = ctk.CTkButton(top_Frame, text="All wallets", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.create_Bitcointextbox, 'all'))
			filter_all_Button.place(relx=0.1, y=30, anchor="center")
			
			filter_Button = ctk.CTkButton(top_Frame, text="Use wallet filter", fg_color="dark orange", text_color="black", border_width=2, border_color="white", font=my_font, command=self.do_show_Bitcoinwallets_start)
			filter_Button.place(relx=0.25, y=30, anchor="center")
			
			addButton = ctk.CTkButton(top_Frame, text="Add new wallet", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=self.do_new_Bitcoinwallet)
			addButton.place(relx=0.9, y=30, anchor="center")
			wallets = False
			
			try:
				with open(path_to_wallets, 'r') as file:
					csvfile = csv.reader(file)
					if do_sort == 'date':
						csvfile = sorted(csvfile, key=lambda x: x[1], reverse=True)
					if do_sort == 'value':
						csvfile = sorted(csvfile, key=lambda x: x[5], reverse=True)
					for lines in csvfile:
						if lines:
							wallets = True
							my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
							if (lines[0] == 'Timestamp' and use_status == 'Timestamp' and lines[6] == use_filter) or (lines[0] == 'Timestamp' and use_status == 'all' and use_filter == 'all') or (lines[0] == 'Timestamp' and use_status == 'Timestamp' and use_filter == 'all') or (lines[0] == 'Timestamp' and use_status == 'all' and use_filter == lines[6]):
								
								if lines[5] == 'None':
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n' + 'Timestamp\n Document', anchor='center', text_color="white", fg_color="purple", border_width=4, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								else:
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n' + 'Timestamp\nSignature + Document', anchor='center', text_color="white", fg_color="purple", border_width=4, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								Button5.pack(pady = 10)
								
							if (lines[0] == 'Active' and use_status == 'Active' and lines[6] == use_filter) or (lines[0] == 'Active' and use_status == 'all' and use_filter == 'all') or (lines[0] == 'Active' and use_status == 'Active' and use_filter == 'all') or (lines[0] == 'Active' and use_status == 'all' and use_filter == lines[6]):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="white", fg_color="green4", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								else:
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="white", fg_color="green4", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								
								Button5.pack(pady = 10)
								amount = amount + float(lines[5])
								
							if (lines[0] == 'Spent' and use_status == 'Spent' and lines[6] == use_filter) or (lines[0] == 'Spent' and use_status == 'all' and use_filter == 'all') or (lines[0] == 'Spent' and use_status == 'Spent' and use_filter == 'all') or (lines[0] == 'Spent' and use_status == 'all' and use_filter == lines[6]):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="black", fg_color="grey", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								else:
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="black", fg_color="grey", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								
								Button5.pack(pady = 10)
								
							if (lines[0] == 'Non KYC' and use_status == 'Non KYC' and lines[6] == use_filter) or (lines[0] == 'Non KYC' and use_status == 'all' and use_filter == 'all') or (lines[0] == 'Non KYC' and use_status == 'Non KYC' and use_filter == 'all') or (lines[0] == 'Non KYC' and use_status == 'all' and use_filter == lines[6]):
								if float(lines[5]) < 0.01:
									SATs_value = float(lines[5]) * 100000000
									SATs_value_rounded = round(SATs_value, 7)
									SATs_value_int = int(SATs_value_rounded)
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + str(SATs_value_int) + ' sats', anchor='nc', text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								else:
									Button5 = ctk.CTkButton(left_wallet_Frame, text='Created: ' + lines[1] + '\n\n' + lines[5] + ' BTC', anchor='center', text_color="white", fg_color="dark green", border_width=2, border_color="white", font=my_font, width=220, height=100, command=partial(self.change_view_btcAddr, lines[2]))
								
								Button5.pack(pady = 10)
								amount = amount + float(lines[5])
							loopcount = loopcount + 1
							
			except FileNotFoundError:
				messagebox.showinfo("Information", "No paper wallet file found.")
			amount_round = round(amount, 7)	
			
			if wallets:
				# Get the current categories (if any)			
				get_categories()
				clicked.set("Select category")
				clicked2.set("Select status")
				
				statusLabel = ctk.CTkLabel(left_top_Frame, text="Filter on wallet type:", text_color="white", fg_color="black", font=my_font)
				statusLabel.place(x=10, y=28, anchor="w")
				drop2 = OptionMenu(left_top_Frame, clicked2, *status_list)
				drop2.config(width=18)
				drop2.place(x=234, y=62, anchor="e")
				
				categoryLabel = ctk.CTkLabel(left_top_Frame, text="Filter on wallet category:", text_color="white", fg_color="black", font=my_font)
				categoryLabel.place(x=10, y=106, anchor="w")
				drop = OptionMenu(left_top_Frame, clicked, *categories_list)
				drop.config(width=18)
				drop.place(x=234, y=140, anchor="e")
				
				selectCategoryButton = ctk.CTkButton(left_top_Frame, text="Apply", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=130, height=28, font=my_font, command=filter_on_category_and_status)
				selectCategoryButton.place(x=235, y=170, anchor="ne")
				
				sortLabel = ctk.CTkLabel(left_mid_Frame, text="Sort wallets on:", text_color="white", fg_color="black", font=my_font)
				sortLabel.place(x=10, y=20, anchor="w")
				
				sortdateButton = ctk.CTkButton(left_mid_Frame, text="Date", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=130, height=28, font=my_font, command=change_sort_flag_to_date)
				sortdateButton.place(x=235, y=45, anchor="ne")
				sortdateButton = ctk.CTkButton(left_mid_Frame, text="Value", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=130, height=28, font=my_font, command=change_sort_flag_to_value)
				sortdateButton.place(x=235, y=85, anchor="ne")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=True, overstrike=False)
			
				infoLabel = ctk.CTkLabel(left_bottom_Frame, text="Applied filters:", text_color="white", fg_color="black", font=my_font)
				infoLabel.place(x=10, y=20, anchor="w")
				my_font = ctk.CTkFont(family="Arial", size=20, slant="roman", underline=False, overstrike=False)
				infoLabel2 = ctk.CTkLabel(left_bottom_Frame, text="Status: " + use_status, text_color="white", fg_color="black", font=my_font)
				infoLabel2.place(x=22, y=60, anchor="w")
				infoLabel3 = ctk.CTkLabel(left_bottom_Frame, text="Category: " + use_filter, text_color="white", fg_color="black", font=my_font)
				infoLabel3.place(x=22, y=90, anchor="w")
				removefilterButton = ctk.CTkButton(left_bottom_Frame, text="Show all", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", width=130, height=28, font=my_font, command=change_sort_flag_to_none)
				removefilterButton.place(x=235, y=120, anchor="ne")	
		else:
			notOKButton = ctk.CTkButton(top_Frame, text="You are not logged in.", text_color="white", fg_color="brown", border_width=2, border_color="white", width=170, height=32, font=my_font, command=self.decrypt_SecUSB)
			notOKButton.place(relx=0.5, rely=0.5, anchor="center")
	
	def fix_csvfile(self):
		size_header = 0
		fixed = False
		path_to_wallets = filepathdestinationfolder + "/secure/wallets/paperwallets/paperwallets.csv"
		path_to_wallets_backup = filepathdestinationfolder + "/secure/wallets/paperwallets/paperwallets_backup.csv"
		path_to_temp_wallets = filepathdestinationfolder + "/secure/wallets/paperwallets/temp_paperwallets.csv"
		
		shutil.copy(path_to_wallets, path_to_wallets_backup)
		
		with open(path_to_temp_wallets, 'w') as target:
			target_writer = csv.writer(target)
			
			with open(path_to_wallets, 'r') as source:
				source_reader = csv.reader(source)
					
				for row in source_reader:
					size_header = len(row)
					if size_header == 6:
						fixed = True
						fixed_row = row
						fixed_row.append('N/A')
						target_writer.writerow(fixed_row)
					else:
						target_writer.writerow(row)
		if fixed:		
			shutil.copy(path_to_temp_wallets, path_to_wallets)
		return True
		
	def do_edit_Bitcoinwallets(self, bechaddr):
		global filepathdestinationfolder
		global SecUSB_button_color
		amount_round = 0.0
		path_to_wallets = filepathdestinationfolder + "/secure/wallets/paperwallets/paperwallets.csv"
		notset_str = 'all'	
		the_status = ' '
		the_dt_string_short = ' '
		the_wif_private_key = ' '
		the_words = ' '
		the_category = 'N/A'
		the_amount = 0.0
		
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=3,
		border_color="black"
		)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		
		try:
			with open(path_to_wallets, 'r') as file:
				csvfile = csv.reader(file)
				for row in csvfile:
					try:
						if row[2] == bechaddr:
							the_status = row[0]
							the_dt_string_short = row[1]
							the_addr = row[2]
							the_wif_private_key = row[3]
							the_words = row[4]
							the_amount = row[5]
							the_category = row[6]
					except:
						continue
		except FileNotFoundError:
				messagebox.showinfo("Information", "No paper wallet file found.")
				
		pathtobackg = str(filepathdestinationfolder) + "/images/BTC_icon_black.jpg"

		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1196, 646))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=2, y=2, anchor="nw")
		
		if str(the_status) == 'Timestamp':
				
			my_font = ctk.CTkFont(family="Arial", size=26, slant="roman", underline=True, overstrike=False)
			headingLabel = ctk.CTkLabel(my_Frame, text='Timestamp on the Bitcoin blockchain', text_color="white", font=my_font, fg_color="black")
			headingLabel.place(relx=0.1, rely=0.1, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)
			if the_amount == 'None':
				filenameLabel = ctk.CTkLabel(my_Frame, text='Timestamp is for the hash of document:', text_color="white", font=my_font, fg_color="black")
				filenameLabel.place(relx=0.1, rely=0.25, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="italic", underline=False, overstrike=False)
				
				filenameLabel2 = ctk.CTkLabel(my_Frame, text=the_words, text_color="white", font=my_font, fg_color="black")
				filenameLabel2.place(relx=0.1, rely=0.3, anchor="w")
			else:
				signameLabel = ctk.CTkLabel(my_Frame, text='For the combined hash of signature and document files:', text_color="white", font=my_font, fg_color="black")
				signameLabel.place(relx=0.1, rely=0.2, anchor="w")
				
				my_font = ctk.CTkFont(family="Arial", size=22, slant="italic", underline=False, overstrike=False)
				
				signameLabel2 = ctk.CTkLabel(my_Frame, text=the_amount, text_color="white", font=my_font, fg_color="black")
				signameLabel2.place(relx=0.1, rely=0.26, anchor="w")
				
				filenameLabel2 = ctk.CTkLabel(my_Frame, text=the_words, text_color="white", font=my_font, fg_color="black")
				filenameLabel2.place(relx=0.1, rely=0.32, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, slant="roman", underline=False, overstrike=False)	
			Label22 = ctk.CTkLabel(my_Frame, text='Status:', text_color="white", font=my_font, fg_color="black")
			Label22.place(relx=0.1, rely=0.46, anchor="w")
			Label23 = ctk.CTkLabel(my_Frame, text=the_category, text_color="white", font=("Helvetica", 22), fg_color="black")
			Label23.place(relx=0.1, rely=0.51, anchor="w")
			
			Label222 = ctk.CTkLabel(my_Frame, text='Address:', text_color="white", font=my_font, fg_color="black")
			Label222.place(relx=0.1, rely=0.65, anchor="w")
			Label232 = ctk.CTkLabel(my_Frame, text=the_addr, text_color="white", font=("Helvetica", 22), fg_color="black")
			Label232.place(relx=0.1, rely=0.7, anchor="w")

			if the_category == "Not payed":
				# Generate a Bitcoin transaction including amount of 1100 sats to the newly hashed address
				transaction_payload = 'bitcoin:' + the_addr + '?amount=0.00001100'
					
				# Generate QR-codes for transaction address 
				qr_public_address = qrcode.make(transaction_payload)
				resize_qr_public_address = qr_public_address.resize((200, 200))
				pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
				resize_qr_public_address.save(pathtopublic)
				publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(200, 200))
				Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = publicimg)
				Labelpublicimg.place(relx=0.7, rely=0.4, anchor="center")
				
				pubLabel = ctk.CTkLabel(my_Frame, text="Pay address:", text_color="white", font=("Arial", 28), fg_color="black")
				pubLabel.place(relx=0.7, rely=0.18, anchor="center")
				
				# Generate QR-codes for Blockchain search 
				ext_link = "www.mempool.space/address/" + the_addr
				qr_blockchain_address = qrcode.make(ext_link)
				resize_qr_blockchain_address = qr_blockchain_address.resize((200, 200))
				pathtoblockchain = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/blockchain.png"
				resize_qr_blockchain_address.save(pathtoblockchain)
				blockchainimg = ctk.CTkImage(light_image=Image.open(pathtoblockchain), dark_image=Image.open(pathtoblockchain), size=(200, 200))
				Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = blockchainimg)
				Labelpublicimg.place(relx=0.9, rely=0.4, anchor="center")
				
				blockchainLabel = ctk.CTkLabel(my_Frame, text="Blockchain link:", text_color="white", font=("Arial", 28), fg_color="black")
				blockchainLabel.place(relx=0.9, rely=0.18, anchor="center")
				
				copy_blockchain_button = ctk.CTkButton(my_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=1, border_color="white", font=my_font, command=partial(self.copy2clip, ext_link))
				copy_blockchain_button.place(relx=0.9, rely=0.61, anchor="center")
				
				button3 = ctk.CTkButton(my_Frame, text="Set to payed", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Payed, the_addr))
				button3.place(relx=0.5, rely=0.76, anchor="center")
			else:
				# Generate QR-codes for Blockchain search 
				ext_link = "www.mempool.space/address/" + the_addr
				qr_blockchain_address = qrcode.make(ext_link)
				resize_qr_blockchain_address = qr_blockchain_address.resize((200, 200))
				pathtoblockchain = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/blockchain.png"
				resize_qr_blockchain_address.save(pathtoblockchain)
				blockchainimg = ctk.CTkImage(light_image=Image.open(pathtoblockchain), dark_image=Image.open(pathtoblockchain), size=(200, 200))
				Labelblockchainimg = ctk.CTkLabel(my_Frame,  text = "", image = blockchainimg)
				Labelblockchainimg.place(relx=0.8, rely=0.4, anchor="center")
				
				blockchainLabel = ctk.CTkLabel(my_Frame, text="Blockchain link:", text_color="white", font=("Arial", 28), fg_color="black")
				blockchainLabel.place(relx=0.8, rely=0.18, anchor="center")
				
				copy_blockchain_button = ctk.CTkButton(my_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=1, border_color="white", font=my_font, command=partial(self.copy2clip, ext_link))
				copy_blockchain_button.place(relx=0.8, rely=0.61, anchor="center")
			
			button4 = ctk.CTkButton(my_Frame, text="Delete", text_color="white", fg_color="red", border_width=2, border_color="white", font=my_font, command=partial(self.do_deleteBitcoinwallet, the_addr))
			button4.place(relx=0.5, rely=0.84, anchor="center")
			button5 = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.create_Bitcointextbox, notset_str))
			button5.place(relx=0.5, rely=0.92, anchor="center")
		else:
			# Generate QR-codes for Public address and WIF-address and read them to display on screen
			qr_public_address = qrcode.make(the_addr, version=1)
			qr_wif_private_key = qrcode.make(the_wif_private_key, version=1)
			
			resize_qr_public_address = qr_public_address.resize((200, 200))
			resize_qr_wif_private_key = qr_wif_private_key.resize((200, 200))
			pathtopublic = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/public.png"
			pathtowif = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/wif.png"
			
			resize_qr_public_address.save(pathtopublic)
			resize_qr_wif_private_key.save(pathtowif)

			publicimg = ctk.CTkImage(light_image=Image.open(pathtopublic), dark_image=Image.open(pathtopublic), size=(200, 200))

			wifimg = ctk.CTkImage(light_image=Image.open(pathtowif), dark_image=Image.open(pathtowif), size=(200, 200))
			my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
			
			pubLabel = ctk.CTkLabel(my_Frame, text="Load", text_color="white", font=("Arial", 28), fg_color="black")
			pubLabel.place(relx=0.15, rely=0.18, anchor="center")
			Labelpublicimg = ctk.CTkLabel(my_Frame,  text = "", image = publicimg)
			Labelpublicimg.place(relx=0.15, rely=0.4, anchor="center")
			copy_bechaddr_button = ctk.CTkButton(my_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, the_addr))
			copy_bechaddr_button.place(relx=0.15, rely=0.61, anchor="center")
			
			dotLabel = ctk.CTkLabel(my_Frame, text=".", text_color="black", font=("Helvetica", 15), fg_color="black")
			dotLabel.place(relx=0.1, rely=0.99, anchor="w")
			
			wifLabel = ctk.CTkLabel(my_Frame, text="Spend (Legacy)", text_color="white", font=("Arial", 28), fg_color="black")
			wifLabel.place(relx=0.83, rely=0.18, anchor="center")
			Labelwifimg = ctk.CTkLabel(my_Frame, text = "", image = wifimg)
			Labelwifimg.place(relx=0.83, rely=0.4, anchor="center")
			copy_wifaddr_button = ctk.CTkButton(my_Frame, text="Copy to clipboard", text_color="white", fg_color=SecUSB_button_color, height=25, width=150, border_width=2, border_color="white", font=my_font, command=partial(self.copy2clip, the_wif_private_key))
			copy_wifaddr_button.place(relx=0.83, rely=0.61, anchor="center")
			if the_status == 'Created':
				my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
				Label0 = ctk.CTkLabel(my_Frame, text='Unused Bitcoin paper wallet:', text_color="white", font=("Helvetica", 20), fg_color="black")
				Label0.place(relx=0.5, rely=0.1, anchor="center")	
			else:	
				my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=True, overstrike=False)
				Label0 = ctk.CTkLabel(my_Frame, text=the_status + ' Bitcoin paper wallet:', text_color="white", font=("Helvetica", 20), fg_color="black")
				Label0.place(relx=0.5, rely=0.1, anchor="center")	
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			Label1 = ctk.CTkLabel(my_Frame, text=the_addr, text_color="white", font=("Helvetica", 20), fg_color="black")
			Label1.place(relx=0.5, rely=0.2, anchor="center")	
			Label2 = ctk.CTkLabel(my_Frame, text='Created: ' + the_dt_string_short, text_color="white", font=("Helvetica", 18), fg_color="black")
			Label2.place(relx=0.5, rely=0.27, anchor="center")	
			Label22 = ctk.CTkLabel(my_Frame, text='Category: ' + the_category, text_color="white", font=("Helvetica", 20), fg_color="black")
			Label22.place(relx=0.5, rely=0.33, anchor="center")
			Label3 = ctk.CTkLabel(my_Frame, text='WIF: ' + the_wif_private_key, text_color="white", font=("Helvetica", 15), fg_color="black")
			Label3.place(relx=0.5, rely=0.4, anchor="center")	
			if float(the_amount) < 0.01:
				SATs_value = float(the_amount) * 100000000
				BTC_value_rounded = round(SATs_value, 7)
				Label4 = ctk.CTkLabel(my_Frame, text='Amount: ' + str(int(BTC_value_rounded)) + ' sats', text_color="white", font=my_font, fg_color="black")
				Label4.place(relx=0.5, rely=0.5, anchor="center")
			else:
				Label4 = ctk.CTkLabel(my_Frame, text='Amount: ' + str(the_amount) + ' BTC', text_color="white", font=my_font, fg_color="black")
				Label4.place(relx=0.5, rely=0.5, anchor="center")
			my_font = ctk.CTkFont(family="Arial", size=18, slant="roman", underline=False, overstrike=False)
			if (str(the_status) == "Active") or (str(the_status) == 'Created') or (str(the_status) == 'Non KYC'):
				if (str(the_amount) == '0') or (str(the_amount) == '0.0'):
					button1 = ctk.CTkButton(my_Frame, text="Add BTC", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.add_AmountToBitcoinwallet, the_addr))
					button1.place(relx=0.5, rely=0.57, anchor="center")	
			if str(the_status) == 'Created':
				button2 = ctk.CTkButton(my_Frame, text="Change status to Active", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Active, the_addr))
				button2.place(relx=0.5, rely=0.62, anchor="center")	
			if str(the_status) == 'Active' or str(the_status) == 'Non KYC':
				button3 = ctk.CTkButton(my_Frame, text="Change status to Spent", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.changeStatusForBitcoinwallet_to_Spent, the_addr))
				button3.place(relx=0.5, rely=0.62, anchor="center")	
			button4 = ctk.CTkButton(my_Frame, text="Delete", text_color="white", fg_color="red", border_width=2, border_color="white", font=my_font, command=partial(self.do_deleteBitcoinwallet, the_addr))
			button4.place(relx=0.5, rely=0.67, anchor="center")	
			button5 = ctk.CTkButton(my_Frame, text="Back", text_color="white", fg_color=SecUSB_button_color, border_width=2, border_color="white", font=my_font, command=partial(self.create_Bitcointextbox, notset_str))
			button5.place(relx=0.5, rely=0.88, anchor="center")			
		
	def add_AmountToBitcoinwallet(self, bechaddr):
		global filepathdestinationfolder
		
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr: # Its the line to change status for
						new_paperwallet = [
										row[0],
										row[1],
										row[2],
										row[3],
										row[4],
										row[5],
										row[6]]
										
						USER_INP = simpledialog.askfloat(title="Add amount!", prompt="Input the amount intended for the paper wallet (in sats or BTC)", initialvalue=0.0)
						
						if float(USER_INP) > 100:
							SATs_value = float(USER_INP) / 100000000
							SATs_value_rounded = round(SATs_value, 7)
							SATs_value_int = int(SATs_value_rounded)
							new_paperwallet[5] = SATs_value
						else:
							new_paperwallet[5] = USER_INP
						answer = messagebox.askquestion('Important!', 'Are the Bitcoin you intend to load to this wallet Non KYC?')
						
						if answer == 'yes':
							new_paperwallet[0] = 'Non KYC'
							csvwriter.writerow(new_paperwallet)
						else:
							new_paperwallet[0] = 'Active'
							csvwriter.writerow(new_paperwallet)	
					else:					
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.create_Bitcointextbox(notset_str)
	
	def changeStatusForBitcoinwallet_to_Payed(self, bechaddr):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr: 
						new_paperwallet = [
										row[0],
										row[1],
										row[2],
										row[3],
										row[4],
										row[5],
										row[6]]
						new_paperwallet[6] = 'Payed'
						csvwriter.writerow(new_paperwallet)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.create_Bitcointextbox(notset_str)
		
	def changeStatusForBitcoinwallet_to_Payed2(self, bechaddr):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr: 
						new_paperwallet = [
										row[0],
										row[1],
										row[2],
										row[3],
										row[4],
										row[5],
										row[6]]
						new_paperwallet[6] = 'Payed'
						csvwriter.writerow(new_paperwallet)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.do_show_Bitcoinwallets_start()
			
	def changeStatusForBitcoinwallet_to_Spent(self, bechaddr):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr: 
						new_paperwallet = [
										row[0],
										row[1],
										row[2],
										row[3],
										row[4],
										row[5],
										row[6]]
						answer = messagebox.askquestion('Important!', 'Are you sure you want to change this wallet to spent?')
						if answer == 'yes':
							new_paperwallet[0] = 'Spent'
							csvwriter.writerow(new_paperwallet)
						else:
							csvwriter.writerow(new_paperwallet)
					else:

						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.create_Bitcointextbox(notset_str)
	
	def changeStatusForBitcoinwallet_to_Active(self, bechaddr):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr:
						new_paperwallet = [
										row[0],
										row[1],
										row[2],
										row[3],
										row[4],
										row[5],
										row[6]]
						answer = messagebox.askquestion('Privacy matter!', 'Are the Bitcoin you intend to load this wallet with non KYC?')
						if answer == 'yes':
							new_paperwallet[0] = 'Non KYC'
							csvwriter.writerow(new_paperwallet)
						else:
							new_paperwallet[0] = 'Active'
							csvwriter.writerow(new_paperwallet)	
					else:

						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.create_Bitcointextbox(notset_str)
			
	def do_deleteBitcoinwallet(self, bechaddr):
		global filepathdestinationfolder
		notset_str = 'all'
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		updated_path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/updatedpaperwallets.csv"
		with open(path_to_wallets, 'r') as source, open(updated_path_to_wallets, 'w') as result:
			csvreader = csv.reader(source)
			csvwriter = csv.writer(result)
			for row in csv.reader(source):
				try:
					if row[2] == bechaddr:
						answer = messagebox.askquestion('Important!', 'Are you sure you want to delete the wallet?')
						if answer == 'yes':
							print("Not sure")
						else:
							csvwriter.writerow(row)
					else:
						csvwriter.writerow(row)						
				except:
					continue
		shutil.copy(updated_path_to_wallets, path_to_wallets)
		os.remove(updated_path_to_wallets)	
		self.create_Bitcointextbox(notset_str)
	
	def do_new_Bitcoinwallet(self):
		global PersonalGPGKey
		global filepathdestinationfolder
		global path_to_USB_secure
		global timeSecUSBLastModified
		global System_button_color
		global categories_list
		
		new_paperwallet_amount= 0.0
		notset_str ='all'
		categories_list = []
		path_to_wallets = str(filepathdestinationfolder) + "/secure/wallets/paperwallets/paperwallets.csv"
		
		now = datetime.now()
		dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
		dt_string_short = now.strftime("%Y-%m-%d")
				
		def do_new_wallet():
			KYC_or_not = checkbox.get()
			new_category_v = str(clicked.get())
			entered_value = newCategoryEntry.get()
			
			# If new category
			if new_category_v == "New category":
				new_category_v = entered_value
					
			if KYC_or_not == 'yes':
				new_Bitcoin_wallet_status = 'Non KYC'
			else:
				new_Bitcoin_wallet_status = 'Active'
				
			seed_words = bitcoinlibMnemonic().generate()
			
			w = wallet.create_wallet(network="BTC", seed=seed_words, children=1)

			new_paperwallet = [
								new_Bitcoin_wallet_status,
								dt_string_short,
								w.get("address"),
								w.get("wif"),		#.decode("utf-8")
								w.get("seed"),
								new_paperwallet_amount,
								new_category_v]

			with open(path_to_wallets, 'a') as f:
				writer = csv.writer(f)
				writer.writerow(new_paperwallet)
			self.do_edit_Bitcoinwallets(w.get("address"))
		
		def get_categories():
			global categories_list
			categories_list.append('New category')
			with open(path_to_wallets, 'r') as file:
				csvfile = csv.reader(file)
				for row in csvfile:
					if row[6] not in categories_list and row[6] != "Not payed" and row[6] != "Payed":
						categories_list.append(row[6])
				
		my_Frame = ctk.CTkFrame(self, 
		width=1200, 
		height=650,
		border_width=3,
		border_color="white"
		)
		
		pathtobackg = self.get_background_image()
				
		backg = ctk.CTkImage(light_image=Image.open(pathtobackg), dark_image=Image.open(pathtobackg), size=(1200, 650))
		Label_backg = ctk.CTkLabel(my_Frame, image=backg, text = "")
		Label_backg.place(x=0, y=0)
		my_Frame.place(relx=0.5, rely=0.6, anchor="center")
		my_Frame.focus_set()
		my_Frame.focus_force()
		
		if path_to_USB_secure == 'Secure USB folder is available':
			completeName = str(filepathdestinationfolder) + "/secure/settings.csv"
			
			USER_INP = simpledialog.askfloat(title="Add amount!", prompt="Input the amount intended for the paper wallet (in sats or BTC)", initialvalue=0.0)
		
			if float(USER_INP) > 100:
				USER_INP = int(USER_INP)
				SATs_value = float(USER_INP) / 100000000
				new_paperwallet_amount = round(SATs_value, 8)
			else:
				new_paperwallet_amount = USER_INP
			
			clicked = StringVar()
			clicked.set("Others") 
			check_var = ctk.StringVar(value="on")
			
			my_font = ctk.CTkFont(family="Arial", size=24, weight="bold", slant="roman", underline=True, overstrike=False)
			
			Label1 = ctk.CTkLabel(my_Frame, text="Create a new Bitcoin wallet:", text_color="white", fg_color="black", font=my_font)
			Label1.place(relx=0.3, rely=0.1, anchor="e")
			
			my_font = ctk.CTkFont(family="Arial", size=20, weight="bold", slant="roman", underline=False, overstrike=False)
			
			nameLabel = ctk.CTkLabel(my_Frame, text="Created:", text_color="white", fg_color="black", font=my_font)
			nameLabel.place(relx=0.18, rely=0.18, anchor="e")
			
			Label2 = ctk.CTkLabel(my_Frame, text=str(dt_string_short), font=my_font, text_color="white", fg_color="black")
			Label2.place(relx=0.28, rely=0.18, anchor="w")
			
			nameLabel = ctk.CTkLabel(my_Frame, text="Amount:", text_color="white", fg_color="black", font=my_font)
			nameLabel.place(relx=0.18, rely=0.24, anchor="e")
			
			if float(USER_INP) > 100:
				Label3 = ctk.CTkLabel(my_Frame, text=str(int(USER_INP)) + ' sats', font=my_font, text_color="white", fg_color="black")
				Label3.place(relx=0.28, rely=0.24, anchor="w")
			else:
				Label3 = ctk.CTkLabel(my_Frame, text=str(new_paperwallet_amount) + ' BTC' , font=my_font, text_color="white", fg_color="black")
				Label3.place(relx=0.28, rely=0.24, anchor="w")
			
			checkbox = ctk.CTkCheckBox(my_Frame, text="The Bitcoins are KYC free!", font=my_font, variable=check_var, onvalue="yes", offvalue="no", text_color="white", fg_color="black")
			checkbox.place(relx=0.46, rely=0.32, anchor="e")

			# Get the current cataegories (if any)			
			get_categories()
			categoryLabel = ctk.CTkLabel(my_Frame, text="Select a category:", text_color="white", fg_color="black", font=my_font)
			categoryLabel.place(relx=0.25, rely=0.5, anchor="e")
		
			drop = OptionMenu(my_Frame, clicked, *categories_list)
			drop.place(relx=0.34, rely=0.5, anchor="w")
			
			categoryLabel = ctk.CTkLabel(my_Frame, text="Create a new category:", text_color="white", fg_color="black", font=my_font)
			categoryLabel.place(relx=0.3, rely=0.6, anchor="e")
			
			def limitSizeCategoryname(*args):
				value = new_category_var.get()
				if len(value) > 17: new_category_var.set(value[:17])
			
			new_category_var = ctk.StringVar(value = "New category")
			new_category_var.trace('w', limitSizeCategoryname)
				
			newCategoryEntry = ctk.CTkEntry(my_Frame, placeholder_text="New category", textvariable=new_category_var, width=150, height=25, text_color="white", border_color="white", border_width=3, corner_radius=8, font=my_font)
			newCategoryEntry.place(relx=0.34, rely=0.6, anchor="w")
			
			my_font = ctk.CTkFont(family="Arial", size=22, weight="bold", slant="roman", underline=False, overstrike=False)
			
			updateButton = ctk.CTkButton(my_Frame, text="Create wallet!", text_color="white", fg_color=System_button_color, border_width=3, border_color="white", font=my_font, command=do_new_wallet)
			updateButton.place(relx=0.34, rely=0.74, anchor="w")
App()
